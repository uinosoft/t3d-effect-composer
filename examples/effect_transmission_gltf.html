<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>t3d-effect GLTF Transmission</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
    <div id="info" class="dark">GLTF Transmission Effect</div>
</body>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="./libs/es-module-shims.js"></script>
<script src="./libs/nanobar.min.js"></script>

<script type="importmap">
    {
        "imports": {
            "t3d": "./libs/t3d/build/t3d.module.js",
            "t3d/addons/": "./libs/t3d/examples/jsm/",
            "t3d-effect-composer": "../build/t3d.effectcomposer.module.js"
        }
    }
</script>

<script type="module">
	import * as t3d from 't3d';
	import { GLTFLoader } from 't3d/addons/loaders/glTF/GLTFLoader.js';
	import { OrbitControls } from 't3d/addons/controls/OrbitControls.js';
	import { SkyBox } from 't3d/addons/objects/SkyBox.js';
	import { TextureCubeLoader } from 't3d/addons/loaders/TextureCubeLoader.js';
	import { DefaultEffectComposer } from 't3d-effect-composer';
	import { KHR_materials_transmission } from 't3d/addons/loaders/glTF/extensions/KHR_materials_transmission.js';
	import { KHR_materials_ior } from 't3d/addons/loaders/glTF/extensions/KHR_materials_ior.js';
	import { KHR_materials_volume } from 't3d/addons/loaders/glTF/extensions/KHR_materials_volume.js';

	import { GUI } from './libs/lil-gui.esm.min.js';
	import Stats from './libs/stats.module.js';

	let width = window.innerWidth || 2;
	let height = window.innerHeight || 2;

	const canvas = document.createElement('canvas');
	canvas.width = width;
	canvas.height = height;
	document.body.appendChild(canvas);

	const contextParams = { antialias: true, alpha: false, stencil: true };
	const gl = canvas.getContext('webgl2', contextParams) || canvas.getContext('webgl', contextParams);
	const renderer = new t3d.WebGLRenderer(gl);
	renderer.setClearColor(0, 0, 0, 1);
	const backRenderTarget = new t3d.RenderTargetBack(canvas);
	const shadowMapPass = new t3d.ShadowMapPass();

	const effectComposer = new DefaultEffectComposer(width, height, {
		samplerNumber: Math.min(renderer.capabilities.maxSamples, 5),
		webgl2: renderer.capabilities.version > 1
	});
	effectComposer.sceneMSAA = true;

	const sceneBuffer = effectComposer.getBuffer('SceneBuffer');
	sceneBuffer.setOutputEncoding(t3d.TEXEL_ENCODING_TYPE.SRGB);
	sceneBuffer.postRenderLayers.transmission.id = 20;

	const cubeTexture = new TextureCubeLoader().load([
		'./resources/cube/BlueSky/posx.jpg',
		'./resources/cube/BlueSky/negx.jpg',
		'./resources/cube/BlueSky/posy.jpg',
		'./resources/cube/BlueSky/negy.jpg',
		'./resources/cube/BlueSky/posz.jpg',
		'./resources/cube/BlueSky/negz.jpg'
	]);
	cubeTexture.encoding = t3d.TEXEL_ENCODING_TYPE.SRGB;

	const scene = new t3d.Scene();
	scene.environment = cubeTexture;

	const skyBox = new SkyBox(cubeTexture);
	skyBox.gamma = true;
	scene.add(skyBox);

	const directionalLight = new t3d.DirectionalLight(0xffffff, 1);
	directionalLight.castShadow = true;
	directionalLight.shadow.windowSize = 10;
	directionalLight.shadow.mapSize.set(512, 512);
	directionalLight.shadow.bias = -0.001;
	directionalLight.shadow.normalBias = 0.2;
	directionalLight.shadow.cameraNear = 10;
	directionalLight.position.set(-20, 20, 30);
	directionalLight.lookAt(new t3d.Vector3(), new t3d.Vector3(0, 1, 0));
	scene.add(directionalLight);

	const camera = new t3d.Camera();
	camera.outputEncoding = t3d.TEXEL_ENCODING_TYPE.SRGB;
	camera.position.set(0, 5, 15);
	camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 1000);
	scene.add(camera);

	const controller = new OrbitControls(camera, canvas);
	controller.target.set(0, 1, 0);

	// load model

	const nanobar = new Nanobar();
	nanobar.el.style.background = 'gray';

	const loadingManager = new t3d.LoadingManager(function() {
		nanobar.go(100);
		nanobar.el.style.background = 'transparent';
	}, function(url, itemsLoaded, itemsTotal) {
		if (itemsLoaded < itemsTotal) {
			nanobar.go(itemsLoaded / itemsTotal * 100);
		}
	});

	const loader = new GLTFLoader(loadingManager);
	loader.extensions.set('KHR_materials_transmission', KHR_materials_transmission);
	loader.extensions.set('KHR_materials_ior', KHR_materials_ior);
	loader.extensions.set('KHR_materials_volume', KHR_materials_volume);

	const baseUri = './resources/gltf/DragonAttenuation/';
	loader.load(baseUri + 'DragonAttenuation.gltf').then(function(result) {
		const object = result.root;
		const scalar = 3;

		let material;

		object.traverse(function(node) {
			if (node.isMesh) {
				node.castShadow = true;
				node.receiveShadow = true;

				if (node.material.shaderName === 'TransmissionPBR') {
					material = node.material;
					material.uniforms.thickness /= scalar;
					node.renderLayer = 20;
				}
			}
		});

		object.scale.setScalar(scalar);
		scene.add(object);

		const gui = new GUI();
		const basicFolder = gui.addFolder('Basic');
		basicFolder.addColor(material, 'diffuse');
		basicFolder.add(material, 'opacity', 0, 1, 0.01);
		basicFolder.add(material, 'metalness', 0, 1, 0.01);
		basicFolder.add(material, 'roughness', 0, 1, 0.01);
		basicFolder.close();
		const transmissionFolder = gui.addFolder('Transmission');
		transmissionFolder.add(material.uniforms, 'transmission', 0, 1, 0.01);
		transmissionFolder.add(material.uniforms, 'thickness', 0, 5, 0.01);
		transmissionFolder.addColor(material.uniforms, 'attenuationColor');
		transmissionFolder.add(material.uniforms, 'attenuationDistance', 0, 1, 0.01);
		transmissionFolder.add(material.uniforms, 'ior', 1, 3, 0.01);
	}).catch(e => console.error(e));

	//

	const stats = new Stats();
	stats.dom.style.cssText = 'position:fixed;bottom:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';
	stats.showPanel(0);
	document.body.appendChild(stats.dom);

	function loop(count) {
		requestAnimationFrame(loop);

		stats.begin();

		controller.update();

		scene.updateMatrix();
		scene.updateRenderStates(camera);
		scene.updateRenderQueue(camera);

		shadowMapPass.render(renderer, scene);

		effectComposer.render(renderer, scene, camera, backRenderTarget);

		stats.end();
	}
	requestAnimationFrame(loop);

	function onWindowResize() {
		width = window.innerWidth || 2;
		height = window.innerHeight || 2;

		camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 1000);

		backRenderTarget.resize(width, height);
		effectComposer.resize(width, height);
	}
	window.addEventListener('resize', onWindowResize, false);
</script>
</html>