// t3d-effect-composer
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("t3d")):"function"==typeof define&&define.amd?define(["exports","t3d"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).t3d=t.t3d||{},t.t3d)}(this,(function(t,e){"use strict";class n{constructor(t,e,n){this.autoUpdate=!0,this.needsUpdate=!0,this.enableCameraJitter=!1}needRender(){return!!this.autoUpdate||!!this.needsUpdate&&(this.needsUpdate=!1,!0)}setGeometryReplaceFunction(t){}setIfRenderReplaceFunction(t){}render(t,e,n,r){}output(t){}resize(t,e){this.needsUpdate=!0}dispose(){this.needsUpdate=!0}}const r="\n\t\tattribute vec3 a_Position;\n\t\tattribute vec2 a_Uv;\n\n\t\tuniform mat4 u_ProjectionView;\n\t\tuniform mat4 u_Model;\n\n\t\tvarying vec2 v_Uv;\n\n\t\tvoid main() {\n\t\t\t\tv_Uv = a_Uv;\n\t\t\t\tgl_Position = u_ProjectionView * u_Model * vec4(a_Position, 1.0);\n\t\t}\n",a="\nvec2 unitVectorToOctahedron(vec3 v) {\n\t\tvec2 up = v.xz / dot(vec3(1.0), abs(v));\n\t\tvec2 down = (1.0 - abs(up.yx)) * sign(up.xy);\n\t\treturn mix(up, down, step(0.0, -v.y));\n}",s="\nvec3 octahedronToUnitVector(vec2 p) {\n\t\tvec3 v = vec3(p.x, 1.0 - dot(abs(p), vec2(1.0)), p.y);\n\t\tv.xz = mix(v.xz, (1.0 - abs(v.zx)) * sign(v.xz), step(0.0, -v.y));\n\t\treturn normalize(v);\n}",i={name:"ec_blur",defines:{NORMALTEX_ENABLED:0,DEPTHTEX_ENABLED:0,DEPTH_PACKING:0,KERNEL_SIZE_INT:"5",KERNEL_SIZE_FLOAT:"5.0"},uniforms:{tDiffuse:null,textureSize:[512,512],direction:0,blurSize:1,kernel:[.122581,.233062,.288713,.233062,.122581],normalTex:null,depthTex:null,projection:new Float32Array(16),viewInverseTranspose:new Float32Array(16),depthRange:1},vertexShader:r,fragmentShader:`\n\t\t\t\tuniform vec2 textureSize;\n\t\t\t\tuniform int direction;\n\t\t\t\tuniform float blurSize;\n\t\t\t\tuniform float kernel[KERNEL_SIZE_INT];\n\n\t\t\t\t#if NORMALTEX_ENABLED == 1\n\t\t\t\t\t\tuniform sampler2D normalTex;\n\t\t\t\t\t\tuniform mat4 viewInverseTranspose;\n\n\t\t\t\t\t\t${s}\n\n\t\t\t\t\t\tvec3 getViewNormal(const in vec2 screenPosition) {\n\t\t\t\t\t\t\t\tvec3 normal = octahedronToUnitVector(texture2D(normalTex, screenPosition).rg);\n\t\t\t\t\t\t\t\t// Convert to view space\n\t\t\t\t\t\t\t\treturn (viewInverseTranspose * vec4(normal, 0.0)).xyz;\n\t\t\t\t\t\t}\n\t\t\t\t#endif\n\n\t\t\t\t#if DEPTHTEX_ENABLED == 1\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\t\t#include <packing>\n\t\t\t#endif\n\t\t\tuniform sampler2D depthTex;\n\t\t\tuniform mat4 projection;\n\t\t\tuniform float depthRange;\n\t\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t\t#if DEPTH_PACKING == 1\n\t\t\t\t\treturn unpackRGBAToDepth( texture2D( depthTex, screenPosition ) );\n\t\t\t\t#else\n\t\t\t\t\treturn texture2D( depthTex, screenPosition ).r;\n\t\t\t\t#endif\n\t\t\t}\n\t\t\tfloat getLinearDepth(vec2 coord) {\n\t\t\t\tfloat depth = getDepth(coord) * 2.0 - 1.0;\n\t\t\t\treturn projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n\t\t\t}\n\t\t#endif\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec2 off = vec2(0.0);\n\t\t\t\t\t\tif (direction == 0) {\n\t\t\t\t\t\t\t\toff[0] = blurSize / textureSize.x;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\toff[1] = blurSize / textureSize.y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec4 sum = vec4(0.0);\n\t\t\t\t\t\tfloat weightAll = 0.0;\n\n\t\t\t\t\t\t#if NORMALTEX_ENABLED == 1\n\t\t\t\t\t\t\t\tvec3 centerNormal = getViewNormal(v_Uv);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if DEPTHTEX_ENABLED == 1\n\t\t\t\t\t\t\t\tfloat centerDepth = getLinearDepth(v_Uv);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tfor (int i = 0; i < KERNEL_SIZE_INT; i++) {\n\t\t\t\tvec2 coord = clamp(v_Uv + vec2(float(i) - (KERNEL_SIZE_FLOAT - 1.) / 2.) * off, vec2(0.0), vec2(1.0));\n\t\t\t\tfloat w = kernel[i];\n\n\t\t\t\t#if NORMALTEX_ENABLED == 1\n\t\t\t\t\tvec3 normal = getViewNormal(coord);\n\t\t\t\t\tw *= clamp(dot(normal, centerNormal), 0.0, 1.0);\n\t\t\t\t#endif\n\t\t\t\t#if DEPTHTEX_ENABLED == 1\n\t\t\t\t\tfloat d = getLinearDepth(coord);\n\t\t\t\t\t\t\t\t// PENDING Better equation?\n\t\t\t\t\t\t\t\t// w *= (1.0 - smoothstep(abs(centerDepth - d) / depthRange, 0.0, 1.0));\n\t\t\t\t\tw *= (1.0 - smoothstep(0.0, 1.0, abs(centerDepth - d) / depthRange));\n\t\t\t\t#endif\n\n\t\t\t\tweightAll += w;\n\t\t\t\tsum += w * texture2D(tDiffuse, coord);\n\t\t\t}\n\n\t\t\tgl_FragColor = sum / weightAll;\n\t\t\t\t}\n\t\t`},o={name:"ec_additive",defines:{},uniforms:{texture1:null,colorWeight1:1,alphaWeight1:1,texture2:null,colorWeight2:1,alphaWeight2:1},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D texture1;\n\t\t\t\tuniform float colorWeight1;\n\t\t\t\tuniform float alphaWeight1;\n\n\t\t\t\tuniform sampler2D texture2;\n\t\t\t\tuniform float colorWeight2;\n\t\t\t\tuniform float alphaWeight2;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 texel1 = texture2D(texture1, v_Uv);\n\t\t\t\t\t\tvec4 texel2 = texture2D(texture2, v_Uv);\n\t\t\t\t\t\tvec3 color = texel1.rgb * colorWeight1 + texel2.rgb * colorWeight2;\n\t\t\t\t\t\tfloat alpha = texel1.a * alphaWeight1 + texel2.a * alphaWeight2;\n\t\t\t\t\t\tgl_FragColor = vec4(color, alpha);\n\t\t\t\t}\n\t\t"},l={name:"ec_multiply",defines:{},uniforms:{texture1:null,texture2:null},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D texture1;\n\t\t\t\tuniform sampler2D texture2;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 texel1 = texture2D(texture1, v_Uv);\n\t\t\t\t\t\tvec4 texel2 = texture2D(texture2, v_Uv);\n\t\t\t\t\t\tgl_FragColor = texel1 * texel2;\n\t\t\t\t}\n\t\t"},f={name:"ec_copy",defines:{},uniforms:{tDiffuse:null},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D tDiffuse;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tgl_FragColor = texture2D(tDiffuse, v_Uv);\n\t\t\t\t}\n\t\t"},u={name:"ec_channel",defines:{},uniforms:{tDiffuse:null,channelMask:[1,0,0,0]},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec4 channelMask;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\tfloat value = dot(texture2D(tDiffuse, v_Uv), channelMask);\n\t\t\t\t\t\tgl_FragColor = vec4(vec3(value), 1.0);\n\t\t\t\t}\n\t\t"},c={name:"ec_mask",defines:{},uniforms:{colorTexture:null,maskTexture:null,channel:[1,0,0,0],additiveTexture:null,additiveStrength:1},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D colorTexture;\n\n\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec4 channel;\n\n\t\tuniform sampler2D additiveTexture;\n\t\t\t\tuniform float additiveStrength;\n\t\t\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\tvec4 colorTex = texture2D(colorTexture, v_Uv);\n\t\t\tvec4 maskTex = texture2D(maskTexture, v_Uv);\n\t\t\tvec4 addTex = texture2D(additiveTexture, v_Uv);\n\t\t\t\t\t\tgl_FragColor = colorTex * dot(maskTex, channel) + addTex * additiveStrength;\n\t\t\t\t}\n\t\t"},d={name:"ec_highlight",defines:{},uniforms:{tDiffuse:null,diffuseStrength:1,threshold:1,smoothWidth:.01},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform float threshold;\n\t\tuniform float smoothWidth;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform float diffuseStrength;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 texel = texture2D(tDiffuse, v_Uv) * diffuseStrength;\n\t\t\t\t\t\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\t\t\t\t\t\tfloat v = dot(texel.xyz, luma);\n\t\t\t\t\t\tgl_FragColor = smoothstep(threshold, threshold + smoothWidth, v) * texel;\n\t\t\t\t}\n\t\t"},h={name:"ec_seperable_blur",defines:{MAX_RADIUS:4},uniforms:{tDiffuse:null,texSize:[.5,.5],direction:[.5,.5],kernelRadius:1},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\treturn 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\tvec4 diffuseColor = texture2D(tDiffuse, v_Uv);\n\t\t\tvec4 diffuseSum = diffuseColor * weightSum;\n\t\t\tvec2 delta = direction * invSize * kernelRadius / float(MAX_RADIUS);\n\t\t\tvec2 uvOffset = delta;\n\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\tvec4 sample1 = texture2D(tDiffuse, v_Uv + uvOffset);\n\t\t\t\tvec4 sample2 = texture2D(tDiffuse, v_Uv - uvOffset);\n\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\tuvOffset += delta;\n\t\t\t}\n\t\t\tvec4 color = diffuseSum / weightSum;\n\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"},_={name:"ec_h_blur",uniforms:{tDiffuse:null,h:1/512},vertexShader:r,fragmentShader:"\n\t\tuniform float h;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 sum = vec4(0.0);\n\t\t\t\t\t \n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * h, v_Uv.y)) * 0.051;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * h, v_Uv.y)) * 0.0918;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * h, v_Uv.y)) * 0.12245;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * h, v_Uv.y)) * 0.1531;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)) * 0.1633;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x + 1.0 * h, v_Uv.y)) * 0.1531;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * h, v_Uv.y)) * 0.12245;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * h, v_Uv.y)) * 0.0918;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * h, v_Uv.y)) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\t\t\t\t}\n\t\t"},m={name:"ec_v_blur",uniforms:{tDiffuse:null,v:1/512},vertexShader:r,fragmentShader:"\n\t\tuniform float v;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 sum = vec4(0.0);\n\t\t\t\t\t \n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y - 4.0 * v)) * 0.051;\n\t\t\t\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y - 3.0 * v)) * 0.0918;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y - 2.0 * v)) * 0.12245;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y - 1.0 * v)) * 0.1531;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)) * 0.1633;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y + 1.0 * v)) * 0.1531;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y + 2.0 * v)) * 0.12245;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y + 3.0 * v)) * 0.0918;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y + 4.0 * v)) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\t\t\t\t}\n\t\t"},p={name:"ec_fxaa",defines:{},uniforms:{tDiffuse:null,resolution:[1/1024,1/512]},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\t\t\t\t\n\t\t\t\tuniform vec2 resolution;\t\n\t\t\t\t\n\t\t\t\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\t\t\t\t\n\t\t\t\t//----------------------------------------------------------------------------------\n\t\t\t\t// File:\t\t\t\tes3-kepler/FXAA/assets/shaders/FXAA_DefaultES.frag\n\t\t\t\t// SDK Version: v3.00\n\t\t\t\t// Email:\t\t\t gameworks@nvidia.com\n\t\t\t\t// Site:\t\t\t\thttp://developer.nvidia.com/\n\t\t\t\t//\n\t\t\t\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t\t\t\t//\n\t\t\t\t// Redistribution and use in source and binary forms, with or without\n\t\t\t\t// modification, are permitted provided that the following conditions\n\t\t\t\t// are met:\n\t\t\t\t//\t* Redistributions of source code must retain the above copyright\n\t\t\t\t//\t\tnotice, this list of conditions and the following disclaimer.\n\t\t\t\t//\t* Redistributions in binary form must reproduce the above copyright\n\t\t\t\t//\t\tnotice, this list of conditions and the following disclaimer in the\n\t\t\t\t//\t\tdocumentation and/or other materials provided with the distribution.\n\t\t\t\t//\t* Neither the name of NVIDIA CORPORATION nor the names of its\n\t\t\t\t//\t\tcontributors may be used to endorse or promote products derived\n\t\t\t\t//\t\tfrom this software without specific prior written permission.\n\t\t\t\t//\n\t\t\t\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS \"AS IS\" AND ANY\n\t\t\t\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t\t\t\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t\t\t\t// PURPOSE ARE DISCLAIMED.\tIN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t\t\t\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t\t\t\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t\t\t\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t\t\t\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t\t\t\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t\t\t\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t\t\t\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t\t\t\t//\n\t\t\t\t//----------------------------------------------------------------------------------\n\t\t\t\t\n\t\t\t\t#define FXAA_PC 1\n\t\t\t\t#define FXAA_GLSL_100 1\n\t\t\t\t#define FXAA_QUALITY_PRESET 39\n\t\t\t\t\n\t\t\t\t#define FXAA_GREEN_AS_LUMA 1\n\t\t\t\t\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_PC_CONSOLE\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// The console algorithm for PC is included\n\t\t\t\t\t\t// for developers targeting really low spec machines.\n\t\t\t\t\t\t// Likely better to just run FXAA_PC, and use a really low preset.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_PC_CONSOLE 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_GLSL_120\n\t\t\t\t\t\t#define FXAA_GLSL_120 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_GLSL_130\n\t\t\t\t\t\t#define FXAA_GLSL_130 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_HLSL_3\n\t\t\t\t\t\t#define FXAA_HLSL_3 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_HLSL_4\n\t\t\t\t\t\t#define FXAA_HLSL_4 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_HLSL_5\n\t\t\t\t\t\t#define FXAA_HLSL_5 0\n\t\t\t\t#endif\n\t\t\t\t/*==========================================================================*/\n\t\t\t\t#ifndef FXAA_GREEN_AS_LUMA\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// For those using non-linear color,\n\t\t\t\t\t\t// and either not able to get luma in alpha, or not wanting to,\n\t\t\t\t\t\t// this enables FXAA to run using green as a proxy for luma.\n\t\t\t\t\t\t// So with this enabled, no need to pack luma in alpha.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// This will turn off AA on anything which lacks some amount of green.\n\t\t\t\t\t\t// Pure red and blue or combination of only R and B, will get no AA.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Might want to lower the settings for both,\n\t\t\t\t\t\t//\t\tfxaaConsoleEdgeThresholdMin\n\t\t\t\t\t\t//\t\tfxaaQualityEdgeThresholdMin\n\t\t\t\t\t\t// In order to insure AA does not get turned off on colors\n\t\t\t\t\t\t// which contain a minor amount of green.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = On.\n\t\t\t\t\t\t// 0 = Off.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_GREEN_AS_LUMA 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_EARLY_EXIT\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Controls algorithm's early exit path.\n\t\t\t\t\t\t// On PS3 turning this ON adds 2 cycles to the shader.\n\t\t\t\t\t\t// On 360 turning this OFF adds 10ths of a millisecond to the shader.\n\t\t\t\t\t\t// Turning this off on console will result in a more blurry image.\n\t\t\t\t\t\t// So this defaults to on.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = On.\n\t\t\t\t\t\t// 0 = Off.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_EARLY_EXIT 1\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_DISCARD\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t\t\t\t//\t\t For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_DISCARD 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Used for GLSL 120 only.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = GL API supports fast pixel offsets\n\t\t\t\t\t\t// 0 = do not use fast pixel offsets\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#ifdef GL_EXT_gpu_shader4\n\t\t\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 0\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = API supports gather4 on alpha channel.\n\t\t\t\t\t\t// 0 = API does not support gather4 on alpha channel.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 0\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - TUNING KNOBS\n\t\t\t\t------------------------------------------------------------------------------\n\t\t\t\tNOTE the other tuning knobs are now in the shader function inputs!\n\t\t\t\t============================================================================*/\n\t\t\t\t#ifndef FXAA_QUALITY_PRESET\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Choose the quality preset.\n\t\t\t\t\t\t// This needs to be compiled into the shader as it effects code.\n\t\t\t\t\t\t// Best option to include multiple presets is to\n\t\t\t\t\t\t// in each shader define the preset, then include this file.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// OPTIONS\n\t\t\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t\t\t// 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n\t\t\t\t\t\t// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n\t\t\t\t\t\t// 39\t\t\t - no dither, very expensive\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// NOTES\n\t\t\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t\t\t// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n\t\t\t\t\t\t// 13 = about same speed as FXAA 3.9 and better than 12\n\t\t\t\t\t\t// 23 = closest to FXAA 3.9 visually and performance wise\n\t\t\t\t\t\t//\t_ = the lowest digit is directly related to performance\n\t\t\t\t\t\t// _\t= the highest digit is directly related to style\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_QUALITY_PRESET 12\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - PRESETS\n\t\t\t\t\n\t\t\t\t============================================================================*/\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - MEDIUM DITHER PRESETS\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 10)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 3.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 11)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 3.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 12)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 13)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 14)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 15)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 12.0\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - LOW DITHER PRESETS\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 20)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 21)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 22)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 23)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 24)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 3.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 25)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 26)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 9\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 27)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 10\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P9 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 28)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 11\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P9 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P10 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 29)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - EXTREME QUALITY\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 39)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAPI PORTING\n\t\t\t\t\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n\t\t\t\t\t\t#define FxaaBool bool\n\t\t\t\t\t\t#define FxaaDiscard discard\n\t\t\t\t\t\t#define FxaaFloat float\n\t\t\t\t\t\t#define FxaaFloat2 vec2\n\t\t\t\t\t\t#define FxaaFloat3 vec3\n\t\t\t\t\t\t#define FxaaFloat4 vec4\n\t\t\t\t\t\t#define FxaaHalf float\n\t\t\t\t\t\t#define FxaaHalf2 vec2\n\t\t\t\t\t\t#define FxaaHalf3 vec3\n\t\t\t\t\t\t#define FxaaHalf4 vec4\n\t\t\t\t\t\t#define FxaaInt2 ivec2\n\t\t\t\t\t\t#define FxaaSat(x) clamp(x, 0.0, 1.0)\n\t\t\t\t\t\t#define FxaaTex sampler2D\n\t\t\t\t#else\n\t\t\t\t\t\t#define FxaaBool bool\n\t\t\t\t\t\t#define FxaaDiscard clip(-1)\n\t\t\t\t\t\t#define FxaaFloat float\n\t\t\t\t\t\t#define FxaaFloat2 float2\n\t\t\t\t\t\t#define FxaaFloat3 float3\n\t\t\t\t\t\t#define FxaaFloat4 float4\n\t\t\t\t\t\t#define FxaaHalf half\n\t\t\t\t\t\t#define FxaaHalf2 half2\n\t\t\t\t\t\t#define FxaaHalf3 half3\n\t\t\t\t\t\t#define FxaaHalf4 half4\n\t\t\t\t\t\t#define FxaaSat(x) saturate(x)\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t#define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_GLSL_120 == 1)\n\t\t\t\t\t\t// Requires,\n\t\t\t\t\t\t//\t#version 120\n\t\t\t\t\t\t// And at least,\n\t\t\t\t\t\t//\t#extension GL_EXT_gpu_shader4 : enable\n\t\t\t\t\t\t//\t(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n\t\t\t\t\t\t#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n\t\t\t\t\t\t#if (FXAA_FAST_PIXEL_OFFSET == 1)\n\t\t\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_GLSL_130 == 1)\n\t\t\t\t\t\t// Requires '#version 130' or better\n\t\t\t\t\t\t#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n\t\t\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_HLSL_3 == 1)\n\t\t\t\t\t\t#define FxaaInt2 float2\n\t\t\t\t\t\t#define FxaaTex sampler2D\n\t\t\t\t\t\t#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_HLSL_4 == 1)\n\t\t\t\t\t\t#define FxaaInt2 int2\n\t\t\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t\t\t#define FxaaInt2 int2\n\t\t\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n\t\t\t\t\t\t#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\tGREEN AS LUMA OPTION SUPPORT FUNCTION\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n\t\t\t\t#else\n\t\t\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\t\t\t\t\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_PC == 1)\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat4 FxaaPixelShader(\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t\t\t// {xy} = center of pixel\n\t\t\t\t\t\tFxaaFloat2 pos,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Used only for FXAA Console, and not used on the 360 version.\n\t\t\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t\t\t// {xy_} = upper left of pixel\n\t\t\t\t\t\t// {_zw} = lower right of pixel\n\t\t\t\t\t\tFxaaFloat4 fxaaConsolePosPos,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Input color texture.\n\t\t\t\t\t\t// {rgb_} = color in linear or perceptual color space\n\t\t\t\t\t\t// if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t//\t\t {__a} = luma in perceptual color space (not linear)\n\t\t\t\t\t\tFxaaTex tex,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t\t\t// For everything but 360, just use the same input here as for 'tex'.\n\t\t\t\t\t\t// For 360, same diffuseMap, just alias with a 2nd sampler.\n\t\t\t\t\t\t// This sampler needs to have an exponent bias of -1.\n\t\t\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t\t\t// For everything but 360, just use the same input here as for 'tex'.\n\t\t\t\t\t\t// For 360, same diffuseMap, just alias with a 3nd sampler.\n\t\t\t\t\t\t// This sampler needs to have an exponent bias of -2.\n\t\t\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t\t\t// {x_} = 1.0/screenWidthInPixels\n\t\t\t\t\t\t// {_y} = 1.0/screenHeightInPixels\n\t\t\t\t\t\tFxaaFloat2 fxaaQualityRcpFrame,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t\t\t// This effects sub-pixel AA quality and inversely sharpness.\n\t\t\t\t\t\t//\t Where N ranges between,\n\t\t\t\t\t\t//\t\t N = 0.50 (default)\n\t\t\t\t\t\t//\t\t N = 0.33 (sharper)\n\t\t\t\t\t\t// {x__} = -N/screenWidthInPixels\n\t\t\t\t\t\t// {_y_} = -N/screenHeightInPixels\n\t\t\t\t\t\t// {_z_} =\tN/screenWidthInPixels\n\t\t\t\t\t\t// {__w} =\tN/screenHeightInPixels\n\t\t\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// Not used on 360, but used on PS3 and PC.\n\t\t\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t\t\t// {x__} = -2.0/screenWidthInPixels\n\t\t\t\t\t\t// {_y_} = -2.0/screenHeightInPixels\n\t\t\t\t\t\t// {_z_} =\t2.0/screenWidthInPixels\n\t\t\t\t\t\t// {__w} =\t2.0/screenHeightInPixels\n\t\t\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n\t\t\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t\t\t// {x__} =\t8.0/screenWidthInPixels\n\t\t\t\t\t\t// {_y_} =\t8.0/screenHeightInPixels\n\t\t\t\t\t\t// {_z_} = -4.0/screenWidthInPixels\n\t\t\t\t\t\t// {__w} = -4.0/screenHeightInPixels\n\t\t\t\t\t\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t\t\t// This used to be the FXAA_QUALITY_SUBPIX define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// Choose the amount of sub-pixel aliasing removal.\n\t\t\t\t\t\t// This can effect sharpness.\n\t\t\t\t\t\t//\t 1.00 - upper limit (softer)\n\t\t\t\t\t\t//\t 0.75 - default amount of filtering\n\t\t\t\t\t\t//\t 0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n\t\t\t\t\t\t//\t 0.25 - almost off\n\t\t\t\t\t\t//\t 0.00 - completely off\n\t\t\t\t\t\tFxaaFloat fxaaQualitySubpix,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// The minimum amount of local contrast required to apply algorithm.\n\t\t\t\t\t\t//\t 0.333 - too little (faster)\n\t\t\t\t\t\t//\t 0.250 - low quality\n\t\t\t\t\t\t//\t 0.166 - default\n\t\t\t\t\t\t//\t 0.125 - high quality\n\t\t\t\t\t\t//\t 0.063 - overkill (slower)\n\t\t\t\t\t\tFxaaFloat fxaaQualityEdgeThreshold,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t\t\t//\t 0.0833 - upper limit (default, the start of visible unfiltered edges)\n\t\t\t\t\t\t//\t 0.0625 - high quality (faster)\n\t\t\t\t\t\t//\t 0.0312 - visible limit (slower)\n\t\t\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\t\t\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n\t\t\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t\t\t//\t there are only three safe values here: 2 and 4 and 8.\n\t\t\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t\t\t// For all other platforms can be a non-power of two.\n\t\t\t\t\t\t//\t 8.0 is sharper (default!!!)\n\t\t\t\t\t\t//\t 4.0 is softer\n\t\t\t\t\t\t//\t 2.0 is really soft (good only for vector graphics inputs)\n\t\t\t\t\t\tFxaaFloat fxaaConsoleEdgeSharpness,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n\t\t\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t\t\t//\t there are only two safe values here: 1/4 and 1/8.\n\t\t\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t\t\t// Other platforms can use other values.\n\t\t\t\t\t\t//\t 0.125 leaves less aliasing, but is softer (default!!!)\n\t\t\t\t\t\t//\t 0.25 leaves more aliasing, and is sharper\n\t\t\t\t\t\tFxaaFloat fxaaConsoleEdgeThreshold,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t\t\t// This only applies when FXAA_EARLY_EXIT is 1.\n\t\t\t\t\t\t// This does not apply to PS3,\n\t\t\t\t\t\t// PS3 was simplified to avoid more shader instructions.\n\t\t\t\t\t\t//\t 0.06 - faster but more aliasing in darks\n\t\t\t\t\t\t//\t 0.05 - default\n\t\t\t\t\t\t//\t 0.04 - slower and less aliasing in darks\n\t\t\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\t\t\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Extra constants for 360 FXAA Console only.\n\t\t\t\t\t\t// Use zeros or anything else for other platforms.\n\t\t\t\t\t\t// These must be in physical constant registers and NOT immedates.\n\t\t\t\t\t\t// Immedates will result in compiler un-optimizing.\n\t\t\t\t\t\t// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n\t\t\t\t\t\tFxaaFloat4 fxaaConsole360ConstDir\n\t\t\t\t) {\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat2 posM;\n\t\t\t\t\t\tposM.x = pos.x;\n\t\t\t\t\t\tposM.y = pos.y;\n\t\t\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t\t\t#if (FXAA_DISCARD == 0)\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\t\t\t#define lumaM luma4A.w\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#define lumaE luma4A.z\n\t\t\t\t\t\t\t\t#define lumaS luma4A.x\n\t\t\t\t\t\t\t\t#define lumaSE luma4A.y\n\t\t\t\t\t\t\t\t#define lumaNW luma4B.w\n\t\t\t\t\t\t\t\t#define lumaN luma4B.z\n\t\t\t\t\t\t\t\t#define lumaW luma4B.x\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat maxSM = max(lumaS, lumaM);\n\t\t\t\t\t\tFxaaFloat minSM = min(lumaS, lumaM);\n\t\t\t\t\t\tFxaaFloat maxESM = max(lumaE, maxSM);\n\t\t\t\t\t\tFxaaFloat minESM = min(lumaE, minSM);\n\t\t\t\t\t\tFxaaFloat maxWN = max(lumaN, lumaW);\n\t\t\t\t\t\tFxaaFloat minWN = min(lumaN, lumaW);\n\t\t\t\t\t\tFxaaFloat rangeMax = max(maxWN, maxESM);\n\t\t\t\t\t\tFxaaFloat rangeMin = min(minWN, minESM);\n\t\t\t\t\t\tFxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n\t\t\t\t\t\tFxaaFloat range = rangeMax - rangeMin;\n\t\t\t\t\t\tFxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n\t\t\t\t\t\tFxaaBool earlyExit = range < rangeMaxClamped;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tif(earlyExit)\n\t\t\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\t\t\tFxaaDiscard;\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\treturn rgbyM;\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_GATHER4_ALPHA == 0)\n\t\t\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat lumaNS = lumaN + lumaS;\n\t\t\t\t\t\tFxaaFloat lumaWE = lumaW + lumaE;\n\t\t\t\t\t\tFxaaFloat subpixRcpRange = 1.0/range;\n\t\t\t\t\t\tFxaaFloat subpixNSWE = lumaNS + lumaWE;\n\t\t\t\t\t\tFxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n\t\t\t\t\t\tFxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat lumaNESE = lumaNE + lumaSE;\n\t\t\t\t\t\tFxaaFloat lumaNWNE = lumaNW + lumaNE;\n\t\t\t\t\t\tFxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n\t\t\t\t\t\tFxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat lumaNWSW = lumaNW + lumaSW;\n\t\t\t\t\t\tFxaaFloat lumaSWSE = lumaSW + lumaSE;\n\t\t\t\t\t\tFxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n\t\t\t\t\t\tFxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n\t\t\t\t\t\tFxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n\t\t\t\t\t\tFxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n\t\t\t\t\t\tFxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n\t\t\t\t\t\tFxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n\t\t\t\t\t\tFxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n\t\t\t\t\t\tFxaaBool horzSpan = edgeHorz >= edgeVert;\n\t\t\t\t\t\tFxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tif(!horzSpan) lumaN = lumaW;\n\t\t\t\t\t\tif(!horzSpan) lumaS = lumaE;\n\t\t\t\t\t\tif(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n\t\t\t\t\t\tFxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat gradientN = lumaN - lumaM;\n\t\t\t\t\t\tFxaaFloat gradientS = lumaS - lumaM;\n\t\t\t\t\t\tFxaaFloat lumaNN = lumaN + lumaM;\n\t\t\t\t\t\tFxaaFloat lumaSS = lumaS + lumaM;\n\t\t\t\t\t\tFxaaBool pairN = abs(gradientN) >= abs(gradientS);\n\t\t\t\t\t\tFxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n\t\t\t\t\t\tif(pairN) lengthSign = -lengthSign;\n\t\t\t\t\t\tFxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat2 posB;\n\t\t\t\t\t\tposB.x = posM.x;\n\t\t\t\t\t\tposB.y = posM.y;\n\t\t\t\t\t\tFxaaFloat2 offNP;\n\t\t\t\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\t\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\t\t\t\t\t\tif(!horzSpan) posB.x += lengthSign * 0.5;\n\t\t\t\t\t\tif( horzSpan) posB.y += lengthSign * 0.5;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat2 posN;\n\t\t\t\t\t\tposN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n\t\t\t\t\t\tposN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n\t\t\t\t\t\tFxaaFloat2 posP;\n\t\t\t\t\t\tposP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n\t\t\t\t\t\tposP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n\t\t\t\t\t\tFxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n\t\t\t\t\t\tFxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n\t\t\t\t\t\tFxaaFloat subpixE = subpixC * subpixC;\n\t\t\t\t\t\tFxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tif(!pairN) lumaNN = lumaSS;\n\t\t\t\t\t\tFxaaFloat gradientScaled = gradient * 1.0/4.0;\n\t\t\t\t\t\tFxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n\t\t\t\t\t\tFxaaFloat subpixF = subpixD * subpixE;\n\t\t\t\t\t\tFxaaBool lumaMLTZero = lumaMM < 0.0;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tlumaEndN -= lumaNN * 0.5;\n\t\t\t\t\t\tlumaEndP -= lumaNN * 0.5;\n\t\t\t\t\t\tFxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\tFxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n\t\t\t\t\t\tFxaaBool doneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 3)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 4)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 5)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 6)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 7)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 8)\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 9)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 10)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 11)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 12)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat dstN = posM.x - posN.x;\n\t\t\t\t\t\tFxaaFloat dstP = posP.x - posM.x;\n\t\t\t\t\t\tif(!horzSpan) dstN = posM.y - posN.y;\n\t\t\t\t\t\tif(!horzSpan) dstP = posP.y - posM.y;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n\t\t\t\t\t\tFxaaFloat spanLength = (dstP + dstN);\n\t\t\t\t\t\tFxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n\t\t\t\t\t\tFxaaFloat spanLengthRcp = 1.0/spanLength;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaBool directionN = dstN < dstP;\n\t\t\t\t\t\tFxaaFloat dst = min(dstN, dstP);\n\t\t\t\t\t\tFxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n\t\t\t\t\t\tFxaaFloat subpixG = subpixF * subpixF;\n\t\t\t\t\t\tFxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n\t\t\t\t\t\tFxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n\t\t\t\t\t\tFxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n\t\t\t\t\t\tif(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n\t\t\t\t\t\tif( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\treturn FxaaTexTop(tex, posM);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\treturn FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n\t\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t/*==========================================================================*/\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\t\tv_Uv,\n\t\t\t\t\t\tvec4(0.0),\n\t\t\t\t\t\ttDiffuse,\n\t\t\t\t\t\ttDiffuse,\n\t\t\t\t\t\ttDiffuse,\n\t\t\t\t\t\tresolution,\n\t\t\t\t\t\tvec4(0.0),\n\t\t\t\t\t\tvec4(0.0),\n\t\t\t\t\t\tvec4(0.0),\n\t\t\t\t\t\t0.75,\n\t\t\t\t\t\t0.166,\n\t\t\t\t\t\t0.0833,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\tvec4(0.0)\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t// TODO avoid querying texture twice for same texel\n\t\t\t\tgl_FragColor.a = texture2D(tDiffuse, v_Uv).a;\n\t\t\t\t}\n\t\t"},x={None:0,Linear:1,Reinhard:2,Cineon:3,ACESFilmic:4,Neutral:5,AgX:6};function A(t){return t.format===e.PIXEL_FORMAT.DEPTH_STENCIL||t.format===e.PIXEL_FORMAT.DEPTH24_STENCIL8}function T(t){return t.highDynamicRange?t.hdrMode===E.R11G11B10?e.PIXEL_FORMAT.R11F_G11F_B10F:e.PIXEL_FORMAT.RGBA16F:e.PIXEL_FORMAT.RGBA8}function g(t,n){t.type=e.PIXEL_TYPE.UNSIGNED_BYTE,t.format=e.PIXEL_FORMAT.RGBA,n.highDynamicRange&&(t.type=e.PIXEL_TYPE.HALF_FLOAT,n.hdrMode===E.R11G11B10&&(t.format=e.PIXEL_FORMAT.RGB,t.internalformat=e.PIXEL_FORMAT.R11F_G11F_B10F))}function v(t,n=!1){t.type=n?e.PIXEL_TYPE.UNSIGNED_INT_24_8:e.PIXEL_TYPE.UNSIGNED_INT,t.format=n?e.PIXEL_FORMAT.DEPTH_STENCIL:e.PIXEL_FORMAT.DEPTH_COMPONENT,t.magFilter=t.minFilter=e.TEXTURE_FILTER.NEAREST,t.generateMipmaps=!1,t.flipY=!1}const P={OPAQUE:1,TRANSPARENT:2,ALL:15},E={RGBA16:1,R11G11B10:2};class F{constructor(){this.name="",this.bufferDependencies=[],this.active=!0,this.needCameraJitter=!1}render(t,e,n,r,a){console.error("Effect: .render() must be implemented in subclass.")}resize(t,e){}dispose(){}}class S extends F{constructor(){super(),this.threshold=.7,this.smoothWidth=.01,this.blurSize=2,this.strength=1,this._highlightPass=new e.ShaderPostPass(d),this._blurPass=new e.ShaderPostPass(i),this._blendPass=new e.ShaderPostPass(o),this._blendPass.material.premultipliedAlpha=!0}resize(t,e){this._blurPass.uniforms.textureSize[0]=t,this._blurPass.uniforms.textureSize[1]=e}render(t,e,n,r,a){const s=e._renderTargetCache.allocate(0),i=e._renderTargetCache.allocate(1),o=e._renderTargetCache.allocate(1);t.setRenderTarget(s),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._highlightPass.uniforms.tDiffuse=n.texture,this._highlightPass.uniforms.threshold=this.threshold,this._highlightPass.uniforms.smoothWidth=this.smoothWidth,this._highlightPass.render(t),t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=s.texture,this._blurPass.uniforms.direction=0,this._blurPass.uniforms.blurSize=this.blurSize,this._blurPass.render(t),t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=i.texture,this._blurPass.uniforms.direction=1,this._blurPass.uniforms.blurSize=this.blurSize,this._blurPass.render(t),t.setRenderTarget(r),t.setClearColor(0,0,0,0),a?t.clear(e.clearColor,e.clearDepth,e.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=n.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=this.strength,this._blendPass.uniforms.alphaWeight2=this.strength,a&&(this._blendPass.material.transparent=e._tempClearColor[3]<1||!e.clearColor,this._blendPass.renderStates.camera.rect.fromArray(e._tempViewport)),this._blendPass.render(t),a&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),e._renderTargetCache.release(s,0),e._renderTargetCache.release(i,1),e._renderTargetCache.release(o,1)}dispose(){this._highlightPass.dispose(),this._blurPass.dispose(),this._blendPass.dispose()}}class N extends F{constructor(){super(),this.chromaFactor=.025,this._mainPass=new e.ShaderPostPass(C),this._mainPass.material.premultipliedAlpha=!0}resize(t,e){this._mainPass.uniforms.resolution[0]=1/t,this._mainPass.uniforms.resolution[1]=1/e}render(t,e,n,r,a){t.setRenderTarget(r),t.setClearColor(0,0,0,0),a?t.clear(e.clearColor,e.clearDepth,e.clearStencil):t.clear(!0,!0,!1);const s=this._mainPass;s.uniforms.tDiffuse=n.texture,s.uniforms.uChromaFactor=this.chromaFactor,a&&(s.material.transparent=e._tempClearColor[3]<1||!e.clearColor,s.renderStates.camera.rect.fromArray(e._tempViewport)),s.render(t),a&&(s.material.transparent=!1,s.renderStates.camera.rect.set(0,0,1,1))}dispose(){this._mainPass.dispose()}}const C={name:"ec_chromatic_aberration",defines:{},uniforms:{tDiffuse:null,uChromaFactor:.025,uResolutionRatio:[1,1],resolution:[1/1024,1/512]},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform float uChromaFactor;\n\t\t\t\tuniform vec2 uResolutionRatio;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec2 uv = v_Uv;\n\t\t\t\t\t\tvec2 dist = uv - 0.5;\n\t\t\t\t\t\tvec2 offset = uChromaFactor * dist * length(dist);\n\t\t\t\t\t\tvec4 col = texture2D(tDiffuse, min(uv, 1.0 - resolution) * uResolutionRatio);\n\t\t\t\t\t\tcol.r = texture2D(tDiffuse, min(uv - offset, 1.0 - resolution) * uResolutionRatio).r;\n\t\t\t\t\t\tcol.b = texture2D(tDiffuse, min(uv + offset, 1.0 - resolution) * uResolutionRatio).b;\n\t\t\t\t\t\tgl_FragColor = col;\n\t\t\t\t}\n\t\t"};class b extends F{constructor(){super(),this.brightness=0,this.contrast=1.02,this.exposure=0,this.gamma=1,this.saturation=1.02,this._mainPass=new e.ShaderPostPass(I),this._mainPass.material.premultipliedAlpha=!0,this._mainPass.uniforms.contrast=1.02,this._mainPass.uniforms.saturation=1.02}render(t,e,n,r,a){t.setRenderTarget(r),t.setClearColor(0,0,0,0),a?t.clear(e.clearColor,e.clearDepth,e.clearStencil):t.clear(!0,!0,!1);const s=this._mainPass;s.uniforms.tDiffuse=n.texture,s.uniforms.brightness=this.brightness,s.uniforms.contrast=this.contrast,s.uniforms.exposure=this.exposure,s.uniforms.gamma=this.gamma,s.uniforms.saturation=this.saturation,a&&(s.material.transparent=e._tempClearColor[3]<1||!e.clearColor,s.renderStates.camera.rect.fromArray(e._tempViewport)),s.render(t),a&&(s.material.transparent=!1,s.renderStates.camera.rect.set(0,0,1,1))}dispose(){this._mainPass.dispose()}}const I={name:"ec_color_correction",defines:{},uniforms:{tDiffuse:null,brightness:0,contrast:1,exposure:0,gamma:1,saturation:1},vertexShader:r,fragmentShader:'\n\t\t\t\tuniform float brightness;\n\t\t\t\tuniform float contrast;\n\t\t\t\tuniform float exposure;\n\t\t\t\tuniform float gamma;\n\t\t\t\tuniform float saturation;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\t// Values from "Graphics Shaders: Theory and Practice" by Bailey and Cunningham\n\t\t\t\tconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 tex = texture2D(tDiffuse, v_Uv);\n\t\t\t\t\t\t// brightness\n\t\t\t\t\t\tvec3 color = clamp(tex.rgb + vec3(brightness), 0.0, 1.0);\n\t\t\t\t\t\t// contrast\n\t\t\t\t\t\tcolor = clamp((color - vec3(0.5)) * contrast + vec3(0.5), 0.0, 1.0);\n\t\t\t\t\t\t// exposure\n\t\t\t\t\t\tcolor = clamp(color * pow(2.0, exposure), 0.0, 1.0);\n\t\t\t\t\t\t// gamma\n\t\t\t\t\t\tcolor = clamp(pow(color, vec3(gamma)), 0.0, 1.0);\n\t\t\t\t\t\tfloat luminance = dot(color, w);\n\t\t\t\t\t\tcolor = mix(vec3(luminance), color, saturation);\n\t\t\t\t\t\tgl_FragColor = vec4(color, tex.a);\n\t\t\t\t}\n\t\t'};class M extends F{constructor(){super(),this.bufferDependencies=[{key:"GBuffer"}],this.focalDepth=1,this.focalLength=24,this.fstop=.9,this.maxblur=1,this.threshold=.9,this.gain=1,this.bias=.5,this.dithering=1e-4,this._mainPass=new e.ShaderPostPass(y),this._mainPass.material.premultipliedAlpha=!0}resize(t,e){this._mainPass.uniforms.resolution[0]=1/t,this._mainPass.uniforms.resolution[1]=1/e}render(t,n,r,a,s){t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1);const i=n.getBuffer("GBuffer"),o=i.getCurrentRenderStates();this._mainPass.uniforms.tColor=r.texture,this._mainPass.uniforms.tDepth=i.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._mainPass.uniforms.znear=o.camera.near,this._mainPass.uniforms.zfar=o.camera.far,this._mainPass.uniforms.focalDepth=this.focalDepth,this._mainPass.uniforms.focalLength=this.focalLength,this._mainPass.uniforms.fstop=this.fstop,this._mainPass.uniforms.maxblur=this.maxblur,this._mainPass.uniforms.threshold=this.threshold,this._mainPass.uniforms.gain=this.gain,this._mainPass.uniforms.bias=this.bias,this._mainPass.uniforms.dithering=this.dithering,s&&(this._mainPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._mainPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._mainPass.render(t),s&&(this._mainPass.material.transparent=!1,this._mainPass.renderStates.camera.rect.set(0,0,1,1))}dispose(){this._mainPass.dispose()}}const y={name:"ec_bokeh",defines:{RINGS:3,SAMPLES:4},uniforms:{tColor:null,tDepth:null,resolution:[1/1024,1/512],znear:.1,zfar:100,focalDepth:1,focalLength:24,fstop:.9,maxblur:1,threshold:.5,gain:2,bias:.5,dithering:1e-4},vertexShader:r,fragmentShader:"\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tuniform sampler2D tColor;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\t\n\t\t\t\tuniform vec2 resolution;\t\n\t\t\t\t\n\t\t\t\tuniform float znear;\n\t\t\t\tuniform float zfar;\n\n\t\t\t\tuniform float focalDepth;\n\t\t\t\tuniform float focalLength;\n\t\t\t\tuniform float fstop;\n\n\t\t\t\tuniform float maxblur; // clamp value of max blur (0.0 = no blur, 1.0 default)\n\t\t\t\tuniform float threshold; // highlight threshold\n\t\t\t\tuniform float gain; // highlight gain\n\t\t\t\tuniform float bias; // bokeh edge bias\n\t\t\t\tuniform float dithering;\n\n\t\t\t\tconst int samples = SAMPLES;\n\t\t\t\tconst int rings = RINGS;\n\t\t\t\tconst int maxringsamples = rings * samples;\n\n\t\t\t\tfloat CoC = 0.03; // circle of confusion size in mm (35mm film = 0.03mm)\n\n\t\t\t\tvec4 color(vec2 coords, float blur) {\n\t\t\t\t\t\tvec4 col = texture2D(tColor, coords);\n\t\t\t\t\t\tvec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n\t\t\t\t\t\tfloat lum = dot(col.rgb, lumcoeff);\n\t\t\t\t\t\tfloat thresh = max((lum - threshold) * gain, 0.0);\n\t\t\t\t\t\treturn vec4(col.rgb + mix(vec3(0.0), col.rgb, thresh * blur), col.a);\n\t\t\t\t}\n\n\t\t\t\tfloat linearize(float depth) {\n\t\t\t\t\t\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\n\t\t\t\t}\n\n\t\t\t\tfloat gather(float i, float j, int ringsamples, inout vec3 colorSum, float w, float h, float blur) {\n\t\t\t\t\t\tfloat rings2 = float(rings);\n\t\t\t\t\t\tfloat step = PI * 2.0 / float(ringsamples);\n\t\t\t\t\t\tfloat pw = cos(j * step) * i;\n\t\t\t\t\t\tfloat ph = sin(j * step) * i;\n\t\t\tvec4 sampleColor = color(v_Uv + vec2(pw * w, ph * h), blur);\n\t\t\tfloat weight = mix(1.0, i / rings2, bias) * sampleColor.a;\n\t\t\t\t\t\tcolorSum += sampleColor.rgb\t* weight;\n\t\t\t\t\t\treturn weight;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tfloat depth = linearize(texture2D(tDepth,\tv_Uv).x);\n\t\t\t\t\t\tfloat fDepth = focalDepth;\n\n\t\t\t\t\t\t// dof blur factor calculation\n\n\t\t\t\t\t\tfloat f = focalLength; // focal length in mm\n\t\t\t\t\t\tfloat d = fDepth * 1000.; // focal plane in mm\n\t\t\t\t\t\tfloat o = depth * 1000.; // depth in mm\n\n\t\t\t\t\t\tfloat a = (o * f) / (o - f);\n\t\t\t\t\t\tfloat b = (d * f) / (d - f);\n\t\t\t\t\t\tfloat c = (d - f) / (d * fstop * CoC);\n\n\t\t\t\t\t\tfloat blur = abs(a - b) * c;\n\t\t\t\t\t\tblur = clamp(blur, 0.0, 1.0);\n\n\t\t\t\t\t\t// calculation of pattern for dithering\n\n\t\t\t\t\t\tvec2 noise = vec2(rand( v_Uv), rand( v_Uv + vec2(0.4, 0.6))) * dithering * blur;\n\n\t\t\t\t\t\t// getting blur x and y step factor\n\n\t\t\t\t\t\tfloat w = resolution.x * blur * maxblur + noise.x;\n\t\t\t\t\t\tfloat h = resolution.y * blur * maxblur + noise.y;\n\n\t\t\t\t\t\t// calculation of final color\n\n\t\t\t\t\t\tvec3 col = vec3(0.0);\n\t\t\tvec4 centerColor = texture2D(tColor,\tv_Uv);\n\n\t\t\t\t\t\tif (blur < 0.05) {\n\t\t\t\t\t\t\t\tcol = centerColor.rgb;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcol = centerColor.rgb;\n\n\t\t\t\t\t\t\t\tfloat s = 1.0;\n\t\t\t\t\t\t\t\tint ringsamples;\n\n\t\t\t\t\t\t\t\tfor(int i = 1; i <= rings; i++) {\n\t\t\t\t\t\t\t\t\t\tringsamples = i * samples;\n\n\t\t\t\t\t\t\t\t\t\tfor (int j = 0; j < maxringsamples; j++) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (j >= ringsamples) break;\n\t\t\t\t\t\t\t\t\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcol /= s; // divide by sample count\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl_FragColor = vec4(col, centerColor.a);\n\t\t\t\t}\n\t\t"};class L extends F{constructor(){super(),this.noiseIntensity=.35,this.scanlinesIntensity=.5,this.scanlinesCount=2048,this.grayscale=!0,this._time=0,this._mainPass=new e.ShaderPostPass(D),this._mainPass.material.premultipliedAlpha=!0}render(t,e,n,r,a){t.setRenderTarget(r),t.setClearColor(0,0,0,0),a?t.clear(e.clearColor,e.clearDepth,e.clearStencil):t.clear(!0,!0,!1);const s=this._mainPass;s.uniforms.tDiffuse=n.texture,s.uniforms.nIntensity=this.noiseIntensity,s.uniforms.sIntensity=this.scanlinesIntensity,s.uniforms.sCount=this.scanlinesCount,s.uniforms.grayscale=this.grayscale,this._time+=.01667,s.uniforms.time=this._time,a&&(s.material.transparent=e._tempClearColor[3]<1||!e.clearColor,s.renderStates.camera.rect.fromArray(e._tempViewport)),s.render(t),a&&(s.material.transparent=!1,s.renderStates.camera.rect.set(0,0,1,1))}dispose(){this._mainPass.dispose()}}const D={name:"ec_film",defines:{},uniforms:{tDiffuse:null,time:0,nIntensity:.5,sIntensity:.05,sCount:4096,grayscale:!0},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float nIntensity;\n\t\t\t\tuniform float sIntensity;\n\t\t\t\tuniform float sCount;\n\t\t\t\tuniform bool grayscale;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\t// sample the source\n\t\t\t\t\t\tvec4 cTextureScreen = texture2D(tDiffuse, v_Uv);\n\t\t\t\t\t\t// make some noise\n\t\t\t\t\t\tfloat dx = rand(v_Uv + time);\n\t\t\t\t\t\t// add noise\n\t\t\t\t\t\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp(0.1 + dx, 0.0, 1.0);\n\t\t\t\t\t\t// get us a sine and cosine\n\t\t\t\t\t\tvec2 sc = vec2(sin(v_Uv.y * sCount), cos(v_Uv.y * sCount));\n\t\t\t\t\t\t// add scanlines\n\t\t\t\t\t\tcResult += cTextureScreen.rgb * vec3(sc.x, sc.y, sc.x) * sIntensity;\n\t\t\t\t\t\t// interpolate between source and result by intensity\n\t\t\t\t\t\tcResult = cTextureScreen.rgb + clamp(nIntensity, 0.0, 1.0) * (cResult - cTextureScreen.rgb);\n\t\t\t\t\t\t// convert to grayscale if desired\n\t\t\t\t\t\tif(grayscale) {\n\t\t\t\t\t\t\t\tcResult = vec3(cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgl_FragColor = vec4(cResult, cTextureScreen.a);\n\t\t\t\t}\n\t\t"};class R extends F{constructor(){super(),this._mainPass=new e.ShaderPostPass(p),this._mainPass.material.premultipliedAlpha=!0}resize(t,e){this._mainPass.uniforms.resolution[0]=1/t,this._mainPass.uniforms.resolution[1]=1/e}render(t,e,n,r,a){t.setRenderTarget(r),t.setClearColor(0,0,0,0),a?t.clear(e.clearColor,e.clearDepth,e.clearStencil):t.clear(!0,!0,!1),this._mainPass.uniforms.tDiffuse=n.texture,a&&(this._mainPass.material.transparent=e._tempClearColor[3]<1||!e.clearColor,this._mainPass.renderStates.camera.rect.fromArray(e._tempViewport)),this._mainPass.render(t),a&&(this._mainPass.material.transparent=!1,this._mainPass.renderStates.camera.rect.set(0,0,1,1))}dispose(){this._mainPass.dispose()}}class U extends F{constructor(){super(),this.bufferDependencies=[{key:"GBuffer"}],this._ssaoPass=new e.ShaderPostPass(Y),this.radius=.5,this.power=1,this.bias=.1,this.intensity=1,this.autoSampleWeight=!1,this.quality="Medium",this._kernelCode="",this._kernelSize=-1,this._setNoiseSize(64),this._setKernelSize(16),this._blurPass=new e.ShaderPostPass(i),this._blurPass.material.defines.NORMALTEX_ENABLED=1,this._blurPass.material.defines.DEPTHTEX_ENABLED=1,this.blurSize=1,this.depthRange=1,this.jitter=!0,this._blendPass=new e.ShaderPostPass(l),this._blendPass.material.premultipliedAlpha=!0}render(t,n,r,a,s){const i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("GBuffer"),f=l.getCurrentRenderStates();O.copy(f.camera.projectionMatrix),w.copy(f.camera.projectionMatrix).inverse(),X.copy(f.camera.viewMatrix).inverse().transpose(),t.setRenderTarget(i),t.setClearColor(1,1,1,1),t.clear(!0,!0,!1),this._ssaoPass.uniforms.normalTex=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._ssaoPass.uniforms.depthTex=l.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._ssaoPass.uniforms.texSize[0]=l.output().width,this._ssaoPass.uniforms.texSize[1]=l.output().height,O.toArray(this._ssaoPass.uniforms.projection),w.toArray(this._ssaoPass.uniforms.projectionInv),X.toArray(this._ssaoPass.uniforms.viewInverseTranspose);const u=n.$cameraJitter;this._setKernelSize(H[this.quality],this.jitter&&u.accumulating()?u.frame():0),this._ssaoPass.uniforms.radius=this.radius,this._ssaoPass.uniforms.power=this.power,this._ssaoPass.uniforms.bias=this.bias,this._ssaoPass.uniforms.intensity=this.intensity,this._ssaoPass.material.defines.AUTO_SAMPLE_WEIGHT!=this.autoSampleWeight&&(this._ssaoPass.material.needsUpdate=!0,this._ssaoPass.material.defines.AUTO_SAMPLE_WEIGHT=this.autoSampleWeight),this._ssaoPass.render(t),t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurPass.uniforms.normalTex=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._blurPass.uniforms.depthTex=l.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._blurPass.uniforms.textureSize[0]=l.output().width,this._blurPass.uniforms.textureSize[1]=l.output().height,O.toArray(this._blurPass.uniforms.projection),X.toArray(this._blurPass.uniforms.viewInverseTranspose),this._blurPass.uniforms.blurSize=this.blurSize,this._blurPass.uniforms.depthRange=this.depthRange,this._blurPass.uniforms.direction=0,this._blurPass.uniforms.tDiffuse=i.texture,this._blurPass.render(t),t.setRenderTarget(r?i:a),t.clear(!0,!0,!1),this._blurPass.uniforms.direction=1,this._blurPass.uniforms.tDiffuse=o.texture,this._blurPass.render(t),r&&(t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=i.texture,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1))),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)}dispose(){this._ssaoPass.dispose(),this._blurPass.dispose(),this._blendPass.dispose()}_setKernelSize(t,e=0){const n=t+"_"+e;this._kernelCode!==n&&(this._kernelCode=n,B[n]||(B[n]=function(t,e=0){const n=new Float32Array(3*t);for(let r=0;r<t;r++){const t=k(r+e,2)*Math.PI*2,a=1-(.85*k(r+e,3)+.15),s=Math.sqrt(1-a*a),i=Math.random(),o=Math.cos(t)*s*i,l=Math.sin(t)*s*i,f=a*i;n[3*r]=o,n[3*r+1]=l,n[3*r+2]=f}return n}(t,e*t)),this._ssaoPass.uniforms.kernel=B[n],this._ssaoPass.material.defines.KERNEL_SIZE!==t&&(this._ssaoPass.material.defines.KERNEL_SIZE=t,this._ssaoPass.material.needsUpdate=!0))}_setNoiseSize(t){if(this._noiseSize===t)return;this._noiseSize=t;const n=this._ssaoPass.uniforms;n.noiseTex?(n.noiseTex.image.data=Q(t),n.noiseTex.image.width=t,n.noiseTex.image.height=t,n.noiseTex.version++):n.noiseTex=function(t){const n=new e.Texture2D;return n.image={data:Q(t),width:t,height:t},n.type=e.PIXEL_TYPE.UNSIGNED_BYTE,n.magFilter=e.TEXTURE_FILTER.NEAREST,n.minFilter=e.TEXTURE_FILTER.NEAREST,n.wrapS=e.TEXTURE_WRAP.REPEAT,n.wrapT=e.TEXTURE_WRAP.REPEAT,n.generateMipmaps=!1,n.flipY=!1,n.version++,n}(t),n.noiseTexSize[0]=t,n.noiseTexSize[1]=t}}const O=new e.Matrix4,w=new e.Matrix4,X=new e.Matrix4,H={Low:6,Medium:12,High:32,Ultra:64};function k(t,e){let n=0,r=1/e,a=t;for(;a>0;)n+=r*(a%e),a=Math.floor(a/e),r/=e;return n}const B={};function Q(t){const n=new Uint8Array(t*t*4);let r=0;const a=new e.Vector3;for(let e=0;e<t;e++)for(let e=0;e<t;e++)a.set(2*Math.random()-1,2*Math.random()-1,0).normalize(),n[r++]=255*(.5*a.x+.5),n[r++]=255*(.5*a.y+.5),n[r++]=0,n[r++]=255;return n}const Y={name:"ec_ssao",defines:{ALCHEMY:!1,DEPTH_PACKING:0,KERNEL_SIZE:64,AUTO_SAMPLE_WEIGHT:!1},uniforms:{normalTex:null,depthTex:null,texSize:[512,512],noiseTex:null,noiseTexSize:[4,4],projection:new Float32Array(16),projectionInv:new Float32Array(16),viewInverseTranspose:new Float32Array(16),kernel:null,radius:.2,power:1,bias:1e-4,intensity:1},vertexShader:r,fragmentShader:`\n\t\t\t\t#include <packing>\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tuniform sampler2D normalTex;\n\t\t\t\tuniform sampler2D depthTex;\n\t\t\t\tuniform vec2 texSize;\n\n\t\t\t\tuniform sampler2D noiseTex;\n\t\t\t\tuniform vec2 noiseTexSize;\n\n\t\t\t\tuniform mat4 projection;\n\t\t\t\tuniform mat4 projectionInv;\n\t\t\t\tuniform mat4 viewInverseTranspose;\n\n\t\t\t\tuniform vec3 kernel[KERNEL_SIZE];\n\n\t\t\t\tuniform float radius;\n\t\t\t\tuniform float power;\n\t\t\t\tuniform float bias;\n\t\t\t\tuniform float intensity;\n\n\t\t${s}\n\n\t\t\t\tfloat getDepth(const in vec2 screenPosition) {\n\t\t\t\t\t\t#if DEPTH_PACKING == 1\n\t\t\t\t\t\t\t\treturn unpackRGBAToDepth(texture2D(depthTex, screenPosition));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\treturn texture2D(depthTex, screenPosition).r;\n\t\t\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tvec3 getViewNormal(const in vec2 screenPosition) {\n\t\t\t\t\t\tvec3 normal = octahedronToUnitVector(texture2D(normalTex, screenPosition).rg);\n\t\t\t\t\t\t// Convert to view space\n\t\t\t\t\t\treturn (viewInverseTranspose * vec4(normal, 0.0)).xyz;\n\t\t\t\t}\n\n\t\t\t\tfloat ssaoEstimator(in mat3 kernelBasis, in vec3 originPos, in vec3 N) {\n\t\t\t\t\t\tfloat occlusion = 0.0;\n\n\t\t\tfloat allWeight = 0.0;\n\n\t\t\t\t\t\tfor (int i = 0; i < KERNEL_SIZE; i++) {\n\t\t\t\t\t\t\t\tvec3 samplePos = kernel[i];\n\t\t\t\t\t\t\t\tsamplePos = kernelBasis * samplePos;\n\t\t\t\t\t\t\t\tsamplePos = samplePos * radius + originPos;\n\n\t\t\t\t\t\t\t\tvec4 texCoord = projection * vec4(samplePos, 1.0);\n\t\t\t\t\t\t\t\ttexCoord.xy /= texCoord.w;\n\t\t\t\t\t\t\t\ttexCoord.xy = texCoord.xy * 0.5 + 0.5;\n\n\t\t\t\t\t\t\t\tfloat sampleDepth = getDepth(texCoord.xy);\n\t\t\t\t\t\t\t\tfloat z = sampleDepth * 2.0 - 1.0;\n\n\t\t\t\tvec4 projectedPos = vec4(texCoord.xy * 2.0 - 1.0, z, 1.0);\n\t\t\t\tvec4 p4 = projectionInv * projectedPos;\n\t\t\t\tp4.xyz /= p4.w;\n\n\t\t\t\t\t\t\t\t#ifdef ALCHEMY\n\t\t\t\t\t\t\t\t\t\tvec3 cDir = p4.xyz - originPos;\n\n\t\t\t\t\t\t\t\t\t\tfloat vv = dot(cDir, cDir);\n\t\t\t\t\t\t\t\t\t\tfloat vn = dot(cDir, N);\n\n\t\t\t\t\t\t\t\t\t\tfloat radius2 = radius * radius;\n\t\t\t\t\t\t\t\t\t\tvn = max(vn + p4.z * bias, 0.0);\n\t\t\t\t\t\t\t\t\t\tfloat f = max(radius2 - vv, 0.0) / radius2;\n\t\t\t\t\t\t\t\t\t\tocclusion += f * f * f * max(vn / (0.01 + vv), 0.0);\n\n\t\t\t\t\tallWeight += 1.0;\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\tfloat factor = step(samplePos.z, p4.z - bias);\n\t\t\t\t\tfloat rangeCheck = smoothstep(0.0, 1.0, radius / abs(originPos.z - p4.z));\n\n\t\t\t\t\t#ifdef AUTO_SAMPLE_WEIGHT\n\t\t\t\t\t\tfloat weight = smoothstep(0., radius, radius - length(originPos.xy - samplePos.xy));\n\t\t\t\t\t#else\n\t\t\t\t\t\tfloat weight = 1.0;\n\t\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tocclusion += rangeCheck * factor * weight;\n\t\t\t\t\tallWeight += weight;\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tocclusion = 1.0 - occlusion / allWeight;\n\n\t\t\t\t\t\treturn pow(occlusion, power);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tfloat centerDepth = getDepth(v_Uv);\n\t\t\t\t\t\tif(centerDepth >= (1.0 - EPSILON)) {\n\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec3 N = getViewNormal(v_Uv);\n\n\t\t\t\t\t\tvec2 noiseTexCoord = texSize / vec2(noiseTexSize) * v_Uv;\n\t\t\t\t\t\tvec3 rvec = texture2D(noiseTex, noiseTexCoord).rgb * 2.0 - 1.0;\n\n\t\t\t\t\t\t// Tangent\n\t\t\t\t\t\tvec3 T = normalize(rvec - N * dot(rvec, N));\n\t\t\t\t\t\t// Bitangent\n\t\t\t\t\t\tvec3 BT = normalize(cross(N, T));\n\n\t\t\t\t\t\tmat3 kernelBasis = mat3(T, BT, N);\n\n\t\t\t\t\t\t// view position\n\t\t\t\t\t\tfloat z = centerDepth * 2.0 - 1.0;\n\t\t\t\t\t\tvec4 projectedPos = vec4(v_Uv * 2.0 - 1.0, z, 1.0);\n\t\t\t\t\t\tvec4 p4 = projectionInv * projectedPos;\n\t\t\t\t\t\tvec3 position = p4.xyz / p4.w;\n\n\t\t\t\t\t\tfloat ao = ssaoEstimator(kernelBasis, position, N);\n\t\t\t\t\t\tao = clamp(1.0 - (1.0 - ao) * intensity, 0.0, 1.0);\n\n\t\t\t\t\t\tgl_FragColor = vec4(vec3(ao), 1.0);\n\t\t\t\t}\n\t\t`};class W extends F{constructor(){super(),this.bufferDependencies=[{key:"SceneBuffer"},{key:"GBuffer"}],this.pixelStride=8,this.maxIteration=5,this.maxSteps=50,this.maxRayDistance=200,this.enablePixelStrideZCutoff=!0,this.pixelStrideZCutoff=50,this.screenEdgeFadeStart=.9,this.eyeFadeStart=.99,this.eyeFadeEnd=1,this.minGlossiness=.2,this.strength=.2,this.falloff=0,this.importanceSampling=!1,this.blurSize=2,this.depthRange=1,this.jitter=!0,this._copyRGBPass=new e.ShaderPostPass(V),this._ssrPass=new e.ShaderPostPass(j),this._blurPass=new e.ShaderPostPass(i),this._blurPass.material.defines.NORMALTEX_ENABLED=1,this._blurPass.material.defines.DEPTHTEX_ENABLED=1,this._blendPass=new e.ShaderPostPass(q),this._blendPass.material.premultipliedAlpha=!0}render(t,n,r,a,s){const i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("GBuffer"),u=f.getCurrentRenderStates();z.copy(u.camera.projectionMatrix),G.copy(u.camera.projectionMatrix).inverse(),Z.copy(u.camera.viewMatrix).inverse().transpose(),t.setRenderTarget(i),r?(this._copyRGBPass.uniforms.tDiffuse=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._copyRGBPass.render(t)):(t.setClearColor(0,0,0,0),t.clear(!0,!0,!1)),this._ssrPass.uniforms.colorTex=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._ssrPass.uniforms.gBufferTexture1=f.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._ssrPass.uniforms.gBufferTexture2=f.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._ssrPass.uniforms.viewportSize[0]=f.output().width,this._ssrPass.uniforms.viewportSize[1]=f.output().height,z.toArray(this._ssrPass.uniforms.projection),G.toArray(this._ssrPass.uniforms.projectionInv),Z.toArray(this._ssrPass.uniforms.viewInverseTranspose),this._ssrPass.uniforms.pixelStride=this.pixelStride,this._ssrPass.uniforms.maxRayDistance=this.maxRayDistance,this._ssrPass.uniforms.enablePixelStrideZCutoff=this.enablePixelStrideZCutoff?1:0,this._ssrPass.uniforms.pixelStrideZCutoff=this.pixelStrideZCutoff,this._ssrPass.uniforms.screenEdgeFadeStart=this.screenEdgeFadeStart,this._ssrPass.uniforms.eyeFadeStart=this.eyeFadeStart,this._ssrPass.uniforms.eyeFadeEnd=this.eyeFadeEnd,this._ssrPass.uniforms.minGlossiness=this.minGlossiness,this._ssrPass.uniforms.nearZ=u.camera.near;const c=n.$cameraJitter;this._ssrPass.uniforms.jitterOffset=this.jitter&&c.accumulating()?.5*c.frame()/c.totalFrame():0,this._ssrPass.material.defines.MAX_ITERATION==this.maxSteps&&this._ssrPass.material.defines.MAX_BINARY_SEARCH_ITERATION==this.maxIteration||(this._ssrPass.material.needsUpdate=!0,this._ssrPass.material.defines.MAX_ITERATION=this.maxSteps,this._ssrPass.material.defines.MAX_BINARY_SEARCH_ITERATION=this.maxIteration);const d=!!this.importanceSampling;d!==this._ssrPass.material.defines.IMPORTANCE_SAMPLING&&(this._ssrPass.material.needsUpdate=!0,this._ssrPass.material.defines.IMPORTANCE_SAMPLING=d),this._ssrPass.render(t),t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurPass.uniforms.normalTex=f.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._blurPass.uniforms.depthTex=f.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._blurPass.uniforms.textureSize[0]=f.output().width,this._blurPass.uniforms.textureSize[1]=f.output().height,z.toArray(this._blurPass.uniforms.projection),Z.toArray(this._blurPass.uniforms.viewInverseTranspose),this._blurPass.uniforms.blurSize=this.blurSize,this._blurPass.uniforms.depthRange=this.depthRange,this._blurPass.uniforms.direction=0,this._blurPass.uniforms.tDiffuse=i.texture,this._blurPass.render(t),t.setRenderTarget(r?i:a),t.clear(!0,!0,!1),this._blurPass.uniforms.direction=1,this._blurPass.uniforms.tDiffuse=o.texture,this._blurPass.render(t),r&&(t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=i.texture,this._blendPass.uniforms.strength=this.strength,this._blendPass.uniforms.falloff=this.falloff,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1))),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)}dispose(){this._ssrPass.dispose(),this._blurPass.dispose(),this._blendPass.dispose()}}const z=new e.Matrix4,G=new e.Matrix4,Z=new e.Matrix4,j={name:"ec_ssr",defines:{MAX_ITERATION:50,MAX_BINARY_SEARCH_ITERATION:5,IMPORTANCE_SAMPLING:!1},uniforms:{colorTex:null,gBufferTexture1:null,gBufferTexture2:null,projection:new Float32Array(16),projectionInv:new Float32Array(16),viewInverseTranspose:new Float32Array(16),pixelStride:8,maxRayDistance:200,enablePixelStrideZCutoff:1,pixelStrideZCutoff:50,screenEdgeFadeStart:.9,eyeFadeStart:.99,eyeFadeEnd:1,minGlossiness:.2,nearZ:.1,zThicknessThreshold:.1,jitterOffset:0,viewportSize:[512,512]},vertexShader:r,fragmentShader:`\n\t\tvarying vec2 v_Uv;\n\n\t\tuniform sampler2D colorTex;\n\t\tuniform sampler2D gBufferTexture1;\n\t\tuniform sampler2D gBufferTexture2;\n\n\t\tuniform mat4 projection;\n\t\tuniform mat4 projectionInv;\n\t\tuniform mat4 viewInverseTranspose;\n\n\t\tuniform float pixelStride;\n\n\t\tuniform float maxRayDistance;\n\n\t\tuniform float screenEdgeFadeStart;\n\t\n\t\tuniform float enablePixelStrideZCutoff;\n\t\tuniform float pixelStrideZCutoff;\n\n\t\tuniform float eyeFadeStart;\n\t\tuniform float eyeFadeEnd;\n\t\t\n\t\tuniform float minGlossiness;\n\t\tuniform float zThicknessThreshold;\n\t\tuniform float jitterOffset;\n\n\t\tuniform float nearZ;\n\t\tuniform vec2 viewportSize;\n\n\t\t${s}\n\n\t\tfloat fetchDepth(sampler2D depthTexture, vec2 uv) {\n\t\t\tvec4 depthTexel = texture2D(depthTexture, uv);\n\t\t\treturn depthTexel.r * 2.0 - 1.0;\n\t\t}\n\n\t\tfloat linearDepth(float depth) {\n\t\t\treturn projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n\t\t}\n\n\t\tbool rayIntersectDepth(float rayZNear, float rayZFar, vec2 hitPixel) {\n\t\t\t// Swap if bigger\n\t\t\tif (rayZFar > rayZNear) {\n\t\t\t\tfloat t = rayZFar; rayZFar = rayZNear; rayZNear = t;\n\t\t\t}\n\t\t\tfloat cameraZ = linearDepth(fetchDepth(gBufferTexture2, hitPixel));\n\t\t\t// float cameraBackZ = linearDepth(fetchDepth(backDepthTex, hitPixel));\n\t\t\t// Cross z\n\t\t\treturn rayZFar <= cameraZ && rayZNear >= cameraZ - zThicknessThreshold;\n\t\t}\n\n\t\t#ifdef IMPORTANCE_SAMPLING\n\t\t\tfloat interleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {\n\t\t\t\tvec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n\t\t\t\treturn fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy)));\n\t\t\t}\n\n\t\t\tvec3 unrealImportanceSampling(const in float frameMod, const in vec3 tangentX, const in vec3 tangentY, const in vec3 tangentZ, const in vec3 eyeVector, const in float rough4) {\n\t\t\t\tvec2 E;\n\t\t\t\tE.x = interleavedGradientNoise(gl_FragCoord.yx, frameMod);\n\t\t\t\tE.y = fract(E.x * 52.9829189);\n\t\t\t\tE.y = mix(E.y, 1.0, 0.7);\n\n\t\t\t\tfloat phi = 2.0 * 3.14159 * E.x;\n\t\t\t\tfloat cosTheta = pow(max(E.y, 0.000001), rough4 / (2.0 - rough4));\n\t\t\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n\t\t\t\tvec3 h = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t\t\t\th = h.x * tangentX + h.y * tangentY + h.z * tangentZ;\n\t\t\t\treturn normalize((2.0 * dot(eyeVector, h)) * h - eyeVector);\n\t\t\t}\n\t\t#endif\n\n\t\t// Trace a ray in screenspace from rayOrigin (in camera space) pointing in rayDir (in camera space)\n\t\t//\n\t\t// With perspective correct interpolation\n\t\t//\n\t\t// Returns true if the ray hits a pixel in the depth buffer\n\t\t// and outputs the hitPixel (in UV space), the hitPoint (in camera space) and the number\n\t\t// of iterations it took to get there.\n\t\t//\n\t\t// Based on Morgan McGuire & Mike Mara's GLSL implementation:\n\t\t// http://casual-effects.blogspot.com/2014/08/screen-space-ray-tracing.html\n\t\tbool traceScreenSpaceRay(vec3 rayOrigin, vec3 rayDir, float jitter, out vec2 hitPixel, out vec3 hitPoint, out float iterationCount) {\n\t\t\t// Clip to the near plane\n\t\t\tfloat rayLength = ((rayOrigin.z + rayDir.z * maxRayDistance) > -nearZ) ? (-nearZ - rayOrigin.z) / rayDir.z : maxRayDistance;\n\n\t\t\tvec3 rayEnd = rayOrigin + rayDir * rayLength;\n\n\t\t\t// Project into homogeneous clip space\n\t\t\tvec4 H0 = projection * vec4(rayOrigin, 1.0);\n\t\t\tvec4 H1 = projection * vec4(rayEnd, 1.0);\n\n\t\t\tfloat k0 = 1.0 / H0.w, k1 = 1.0 / H1.w;\n\n\t\t\t// The interpolated homogeneous version of the camera space points\n\t\t\tvec3 Q0 = rayOrigin * k0, Q1 = rayEnd * k1;\n\n\t\t\t// Screen space endpoints\n\t\t\t// PENDING viewportSize ?\n\t\t\tvec2 P0 = (H0.xy * k0 * 0.5 + 0.5) * viewportSize;\n\t\t\tvec2 P1 = (H1.xy * k1 * 0.5 + 0.5) * viewportSize;\n\n\t\t\t// If the line is degenerate, make it cover at least one pixel to avoid handling\n\t\t\t// zero-pixel extent as a special case later\n\t\t\tP1 += dot(P1 - P0, P1 - P0) < 0.0001 ? 0.01 : 0.0;\n\t\t\tvec2 delta = P1 - P0;\n\n\t\t\t// Permute so that the primary iteration is in x to collapse\n\t\t\t// all quadrant-specific DDA case later\n\t\t\tbool permute = false;\n\t\t\tif (abs(delta.x) < abs(delta.y)) {\n\t\t\t\t// More vertical line\n\t\t\t\tpermute = true;\n\t\t\t\tdelta = delta.yx;\n\t\t\t\tP0 = P0.yx;\n\t\t\t\tP1 = P1.yx;\n\t\t\t}\n\t\t\tfloat stepDir = sign(delta.x);\n\t\t\tfloat invdx = stepDir / delta.x;\n\n\t\t\t// Track the derivatives of Q and K\n\t\t\tvec3 dQ = (Q1 - Q0) * invdx;\n\t\t\tfloat dk = (k1 - k0) * invdx;\n\n\t\t\tvec2 dP = vec2(stepDir, delta.y * invdx);\n\n\t\t\t// Calculate pixel stride based on distance of ray origin from camera.\n\t\t\t// Since perspective means distant objects will be smaller in screen space\n\t\t\t// we can use this to have higher quality reflections for far away objects\n\t\t\t// while still using a large pixel stride for near objects (and increase performance)\n\t\t\t// this also helps mitigate artifacts on distant reflections when we use a large\n\t\t\t// pixel stride.\n\t\t\tfloat strideScaler = 1.0 - min(1.0, -rayOrigin.z / pixelStrideZCutoff);\n\t\t\tfloat pixStride = mix(pixelStride, 1.0 + strideScaler * pixelStride, enablePixelStrideZCutoff);\n\n\t\t\t// Scale derivatives by the desired pixel stride and the offset the starting values by the jitter fraction\n\t\t\tdP *= pixStride; dQ *= pixStride; dk *= pixStride;\n\n\t\t\t// Track ray step and derivatives in a vec4 to parallelize\n\t\t\tvec4 pqk = vec4(P0, Q0.z, k0);\n\t\t\tvec4 dPQK = vec4(dP, dQ.z, dk);\n\n\t\t\tpqk += dPQK * jitter;\n\t\t\tfloat rayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n\t\t\tfloat rayZNear;\n\n\t\t\tbool intersect = false;\n\n\t\t\tvec2 texelSize = 1.0 / viewportSize;\n\n\t\t\titerationCount = 0.0;\n\t\t\tfloat end = P1.x * stepDir;\n\t\t\tfor (int i = 0; i < MAX_ITERATION; i++) {\n\t\t\t\tpqk += dPQK;\n\t\t\t\tif ((pqk.x * stepDir) >= end) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\trayZNear = rayZFar;\n\t\t\t\trayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n\n\t\t\t\thitPixel = permute ? pqk.yx : pqk.xy;\n\t\t\t\thitPixel *= texelSize;\n\n\t\t\t\tintersect = rayIntersectDepth(rayZNear, rayZFar, hitPixel);\n\n\t\t\t\titerationCount += 1.0;\n\n\t\t\t\t// PENDING Right on all platforms?\n\t\t\t\tif (intersect) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Binary search refinement\n\t\t\t// FIXME If intersect in first iteration binary search may easily lead to the pixel of reflect object it self\n\t\t\tif (pixStride > 1.0 && intersect && iterationCount > 1.0) {\n\t\t\t\t// Roll back\n\t\t\t\tpqk -= dPQK;\n\t\t\t\tdPQK /= pixStride;\n\n\t\t\t\tfloat originalStride = pixStride * 0.5;\n\t\t\t\tfloat stride = originalStride;\n\n\t\t\t\trayZNear = pqk.z / pqk.w;\n\t\t\t\trayZFar = rayZNear;\n\n\t\t\t\tfor (int j = 0; j < MAX_BINARY_SEARCH_ITERATION; j++) {\n\t\t\t\t\tpqk += dPQK * stride;\n\t\t\t\t\trayZNear = rayZFar;\n\t\t\t\t\trayZFar = (dPQK.z * -0.5 + pqk.z) / (dPQK.w * -0.5 + pqk.w);\n\t\t\t\t\thitPixel = permute ? pqk.yx : pqk.xy;\n\t\t\t\t\thitPixel *= texelSize;\n\n\t\t\t\t\toriginalStride *= 0.5;\n\t\t\t\t\tstride = rayIntersectDepth(rayZNear, rayZFar, hitPixel) ? -originalStride : originalStride;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ0.xy += dQ.xy * iterationCount;\n\t\t\tQ0.z = pqk.z;\n\t\t\thitPoint = Q0 / pqk.w;\n\n\t\t\treturn intersect;\n\t\t}\n\n\t\tfloat calculateAlpha(float iterationCount, float reflectivity, vec2 hitPixel, vec3 hitPoint, float dist, vec3 rayDir) {\n\t\t\tfloat alpha = clamp(reflectivity, 0.0, 1.0);\n\n\t\t\t// Fade ray hits that approach the maximum iterations\n\t\t\talpha *= 1.0 - (iterationCount / float(MAX_ITERATION));\n\n\t\t\t// Fade ray hits that approach the screen edge\n\t\t\tvec2 hitPixelNDC = hitPixel * 2.0 - 1.0;\n\t\t\tfloat maxDimension = min(1.0, max(abs(hitPixelNDC.x), abs(hitPixelNDC.y)));\n\t\t\talpha *= 1.0 - max(0.0, maxDimension - screenEdgeFadeStart) / (1.0 - screenEdgeFadeStart);\n\n\t\t\t// Fade ray hits base on how much they face the camera\n\t\t\tfloat _eyeFadeStart = eyeFadeStart;\n\t\t\tfloat _eyeFadeEnd = eyeFadeEnd;\n\t\t\tif (_eyeFadeStart > _eyeFadeEnd) {\n\t\t\t\tfloat tmp = _eyeFadeEnd;\n\t\t\t\t_eyeFadeEnd = _eyeFadeStart;\n\t\t\t\t_eyeFadeStart = tmp;\n\t\t\t}\n\t\t\tfloat eyeDir = clamp(rayDir.z, _eyeFadeStart, _eyeFadeEnd);\n\t\t\talpha *= 1.0 - (eyeDir - _eyeFadeStart) / (_eyeFadeEnd - _eyeFadeStart);\n\n\t\t\t// Fade ray hits based on distance from ray origin\n\t\t\talpha *= 1.0 - clamp(dist / maxRayDistance, 0.0, 1.0);\n\n\t\t\treturn alpha;\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 gBufferTexel = texture2D(gBufferTexture1, v_Uv);\n\n\t\t\tif (gBufferTexel.r < -2.0) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat g = 1. - gBufferTexel.a;\n\t\t\tif (g <= minGlossiness) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat reflectivity = g;\n\n\t\t\tvec3 N = octahedronToUnitVector(gBufferTexel.rg);\n\t\t\tN = normalize((viewInverseTranspose * vec4(N, 0.0)).xyz);\n\n\t\t\t// Position in view\n\t\t\tvec4 projectedPos = vec4(v_Uv * 2.0 - 1.0, fetchDepth(gBufferTexture2, v_Uv), 1.0);\n\t\t\tvec4 pos = projectionInv * projectedPos;\n\t\t\tvec3 rayOrigin = pos.xyz / pos.w;\n\n\t\t\tvec3 rayDir;\n\t\t\t#ifdef IMPORTANCE_SAMPLING\n\t\t\t\tvec3 upVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\t\t\t\tvec3 tangentX = normalize(cross(upVector, N));\n\t\t\t\tvec3 tangentY = normalize(cross(N, tangentX));\n\t\t\t\tvec3 tangentZ = N;\n\t\t\t\trayDir = unrealImportanceSampling(jitterOffset * 20., tangentX, tangentY, tangentZ, -rayOrigin, pow(gBufferTexel.a, 4.0));\n\t\t\t#else\n\t\t\t\trayDir = normalize(reflect(normalize(rayOrigin), N));\n\t\t\t#endif\n\n\t\t\tvec2 hitPixel;\n\t\t\tvec3 hitPoint;\n\t\t\tfloat iterationCount;\n\n\t\t\t// Get jitter\n\t\t\tvec2 uv2 = v_Uv * viewportSize;\n\t\t\tfloat jitter = fract((uv2.x + uv2.y) * 0.25) + jitterOffset;\n\n\t\t\tbool intersect = traceScreenSpaceRay(rayOrigin, rayDir, jitter, hitPixel, hitPoint, iterationCount);\n\t\t\t// Is empty\n\t\t\tif (!intersect) {\n\t\t\t\tdiscard;\n\t\t\t}\n\t\t\tfloat dist = distance(rayOrigin, hitPoint);\n\n\t\t\tfloat alpha = calculateAlpha(iterationCount, reflectivity, hitPixel, hitPoint, dist, rayDir) * float(intersect);\n\n\t\t\tvec3 hitNormal = octahedronToUnitVector(texture2D(gBufferTexture1, hitPixel).rg);\n\t\t\thitNormal = normalize((viewInverseTranspose * vec4(hitNormal, 0.0)).xyz);\n\n\t\t\t// Ignore the pixel not face the ray\n\t\t\t// TODO fadeout ?\n\t\t\t// PENDING Can be configured?\n\t\t\tif (dot(hitNormal, rayDir) >= 0.0) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tvec4 color = texture2D(colorTex, hitPixel);\n\t\t\tgl_FragColor = vec4(color.rgb, color.a * alpha);\n\t\t}\n\t\t`},V={name:"ec_copy_rgb",defines:{},uniforms:{tDiffuse:null},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D tDiffuse;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\tvec3 color = texture2D(tDiffuse, v_Uv).rgb;\n\t\t\t\t\t\tgl_FragColor = vec4(color, 0.0);\n\t\t\t\t}\n\t\t"},q={name:"ec_ssr_mix",defines:{},uniforms:{texture1:null,texture2:null,strength:.15,falloff:1},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D texture1;\n\t\t\t\tuniform sampler2D texture2;\n\t\tuniform float strength;\n\t\tuniform float falloff;\n\t\t\t\tvarying vec2 v_Uv;\n\t\t\t\tvoid main() {\n\t\t\tvec4 baseColor = texture2D(texture1, v_Uv);\n\t\t\tvec4 ssrColor = texture2D(texture2, v_Uv);\n\n\t\t\tfloat reflectivity = ssrColor.a * strength;\n\t\t\tvec3 finalColor = baseColor.rgb * (1.0 - reflectivity * falloff) + ssrColor.rgb * reflectivity;\n\n\t\t\tgl_FragColor = vec4(finalColor, baseColor.a);\n\t\t\t\t}\n\t\t"};const K={name:"accum",defines:{},uniforms:{mixRatio:.9},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D currTexture;\n\t\t\t\tuniform sampler2D prevTexture;\n\n\t\t\t\tuniform float mixRatio;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 texel1 = texture2D(currTexture, v_Uv);\n\t\t\t\t\t\tvec4 texel2 = texture2D(prevTexture, v_Uv);\n\t\t\t\t\t\tgl_FragColor = mix(texel1, texel2, mixRatio);\n\t\t\t\t}\n\t\t"};const $={name:"ec_tone_mapping",defines:{},uniforms:{tDiffuse:null,toneMappingExposure:1},vertexShader:r,fragmentShader:"\n\t\tuniform float toneMappingExposure;\n\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec2 v_Uv;\n\n\t\t#ifdef LINEAR_TONE_MAPPING\n\t\t\t// exposure only\n\t\t\tvec3 LinearToneMapping(vec3 color) {\n\t\t\t\treturn saturate(toneMappingExposure * color);\n\t\t\t}\n\t\t#elif defined(REINHARD_TONE_MAPPING)\n\t\t\t// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf\n\t\t\tvec3 ReinhardToneMapping(vec3 color) {\n\t\t\t\tcolor *= toneMappingExposure;\n\t\t\t\treturn saturate(color / (vec3(1.0) + color));\n\t\t\t}\n\t\t#elif defined(CINEON_TONE_MAPPING)\n\t\t\t// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\t\t\tvec3 OptimizedCineonToneMapping(vec3 color) {\n\t\t\t\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\t\t\t\tcolor *= toneMappingExposure;\n\t\t\t\tcolor = max(vec3(0.0), color - 0.004);\n\t\t\t\treturn pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));\n\t\t\t}\n\t\t#elif defined(ACES_FILMIC_TONE_MAPPING)\n\t\t\t// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\t\t\tvec3 RRTAndODTFit(vec3 v) {\n\t\t\t\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\t\t\t\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\t\t\t\treturn a / b;\n\t\t\t}\n\n\t\t\t// this implementation of ACES is modified to accommodate a brighter viewing environment.\n\t\t\t// the scale factor of 1/0.6 is subjective. see discussion in https://github.com/mrdoob/three.js/pull/19621.\n\t\t\tvec3 ACESFilmicToneMapping(vec3 color) {\n\t\t\t\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n\t\t\t\tconst mat3 ACESInputMat = mat3(\n\t\t\t\t\tvec3(0.59719, 0.07600, 0.02840), // transposed from source\n\t\t\t\t\tvec3(0.35458, 0.90834, 0.13383),\n\t\t\t\t\tvec3(0.04823, 0.01566, 0.83777)\n\t\t\t\t);\n\t\t\t\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\t\t\t\tconst mat3 ACESOutputMat = mat3(\n\t\t\t\t\tvec3( 1.60475, -0.10208, -0.00327), // transposed from source\n\t\t\t\t\tvec3(-0.53108,\t1.10813, -0.07276),\n\t\t\t\t\tvec3(-0.07367, -0.00605,\t1.07602)\n\t\t\t\t);\n\t\t\t\tcolor *= toneMappingExposure / 0.6;\n\t\t\t\tcolor = ACESInputMat * color;\n\t\t\t\t// Apply RRT and ODT\n\t\t\t\tcolor = RRTAndODTFit(color);\n\t\t\t\tcolor = ACESOutputMat * color;\n\t\t\t\t// Clamp to [0, 1]\n\t\t\t\treturn saturate(color);\n\t\t\t}\n\t\t#elif defined(NEUTRAL_TONE_MAPPING)\n\t\t\tvec3 NeutralToneMapping(vec3 color) {\n\t\t\t\tconst float StartCompression = 0.8 - 0.04;\n\t\t\t\tconst float Desaturation = 0.15;\n\t\t\t\tcolor *= toneMappingExposure;\n\t\t\t\tfloat x = min(color.r, min(color.g, color.b));\n\t\t\t\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\t\t\t\tcolor -= offset;\n\t\t\t\tfloat peak = max(color.r, max(color.g, color.b));\n\t\t\t\tif (peak < StartCompression) return color;\n\t\t\t\tfloat d = 1. - StartCompression;\n\t\t\t\tfloat newPeak = 1. - d * d / (peak + d - StartCompression);\n\t\t\t\tcolor *= newPeak / peak;\n\t\t\t\tfloat g = 1. - 1. / (Desaturation * (peak - newPeak) + 1.);\n\t\t\t\treturn mix(color, vec3(newPeak), g);\n\t\t\t}\n\t\t#elif defined(AGX_TONE_MAPPING)\n\t\t\t// Matrices for rec 2020 <> rec 709 color space conversion\n\t\t\t// matrix provided in row-major order so it has been transposed\n\t\t\t// https://www.itu.int/pub/R-REP-BT.2407-2017\n\t\t\tconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\t\t\t\tvec3(1.6605, -0.1246, -0.0182),\n\t\t\t\tvec3(-0.5876, 1.1329, -0.1006),\n\t\t\t\tvec3(-0.0728, -0.0083, 1.1187)\n\t\t\t);\n\n\t\t\tconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\t\t\t\tvec3(0.6274, 0.0691, 0.0164),\n\t\t\t\tvec3(0.3293, 0.9195, 0.0880),\n\t\t\t\tvec3(0.0433, 0.0113, 0.8956)\n\t\t\t);\n\n\t\t\t// https://iolite-engine.com/blog_posts/minimal_agx_implementation\n\t\t\t// Mean error^2: 3.6705141e-06\n\t\t\tvec3 agxDefaultContrastApprox(vec3 x) {\n\t\t\t\tvec3 x2 = x * x;\n\t\t\t\tvec3 x4 = x2 * x2;\n\n\t\t\t\treturn + 15.5 * x4 * x2\n\t\t\t\t\t- 40.14 * x4 * x\n\t\t\t\t\t+ 31.96 * x4\n\t\t\t\t\t- 6.868 * x2 * x\n\t\t\t\t\t+ 0.4298 * x2\n\t\t\t\t\t+ 0.1191 * x\n\t\t\t\t\t- 0.00232;\n\t\t\t}\n\n\t\t\t// AgX Tone Mapping implementation based on Filament, which in turn is based\n\t\t\t// on Blender's implementation using rec 2020 primaries\n\t\t\t// https://github.com/google/filament/pull/7236\n\t\t\t// Inputs and outputs are encoded as Linear-sRGB.\n\t\t\tvec3 AgXToneMapping(vec3 color) {\n\t\t\t\t// AgX constants\n\t\t\t\tconst mat3 AgXInsetMatrix = mat3(\n\t\t\t\t\tvec3(0.856627153315983, 0.137318972929847, 0.11189821299995),\n\t\t\t\t\tvec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903),\n\t\t\t\t\tvec3(0.0482516061458583, 0.101439036467562, 0.811302368396859)\n\t\t\t\t);\n\n\t\t\t\t// explicit AgXOutsetMatrix generated from Filaments AgXOutsetMatrixInv\n\t\t\t\tconst mat3 AgXOutsetMatrix = mat3(\n\t\t\t\t\tvec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826),\n\t\t\t\t\tvec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294),\n\t\t\t\t\tvec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)\n\t\t\t\t);\n\n\t\t\t\t// LOG2_MIN\t\t\t= -10.0\n\t\t\t\t// LOG2_MAX\t\t\t=\t+6.5\n\t\t\t\t// MIDDLE_GRAY\t =\t0.18\n\t\t\t\tconst float AgxMinEv = -12.47393;\t// log2(pow(2, LOG2_MIN) * MIDDLE_GRAY)\n\t\t\t\tconst float AgxMaxEv = 4.026069;\t // log2(pow(2, LOG2_MAX) * MIDDLE_GRAY)\n\n\t\t\t\tcolor *= toneMappingExposure;\n\n\t\t\t\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\n\t\t\t\tcolor = AgXInsetMatrix * color;\n\n\t\t\t\t// Log2 encoding\n\t\t\t\tcolor = max(color, 1e-10); // avoid 0 or negative numbers for log2\n\t\t\t\tcolor = log2(color);\n\t\t\t\tcolor = (color - AgxMinEv) / (AgxMaxEv - AgxMinEv);\n\n\t\t\t\tcolor = clamp(color, 0.0, 1.0);\n\n\t\t\t\t// Apply sigmoid\n\t\t\t\tcolor = agxDefaultContrastApprox(color);\n\n\t\t\t\t// Apply AgX look\n\t\t\t\t// v = agxLook(v, look);\n\n\t\t\t\tcolor = AgXOutsetMatrix * color;\n\n\t\t\t\t// Linearize\n\t\t\t\tcolor = pow(max(vec3(0.0), color), vec3(2.2));\n\n\t\t\t\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\n\t\t\t\t// Gamut mapping. Simple clamp for now.\n\t\t\t\tcolor = clamp(color, 0.0, 1.0);\n\n\t\t\t\treturn color;\n\t\t\t}\n\t\t#endif\n\n\t\tvoid main() {\n\t\t\tgl_FragColor = texture2D(tDiffuse, v_Uv);\n\n\t\t\t// tone mapping\n\n\t\t\t#ifdef LINEAR_TONE_MAPPING\n\t\t\t\tgl_FragColor.rgb = LinearToneMapping(gl_FragColor.rgb);\n\t\t\t#elif defined(REINHARD_TONE_MAPPING)\n\t\t\t\tgl_FragColor.rgb = ReinhardToneMapping(gl_FragColor.rgb);\n\t\t\t#elif defined(CINEON_TONE_MAPPING)\n\t\t\t\tgl_FragColor.rgb = OptimizedCineonToneMapping(gl_FragColor.rgb);\n\t\t\t#elif defined(ACES_FILMIC_TONE_MAPPING)\n\t\t\t\tgl_FragColor.rgb = ACESFilmicToneMapping(gl_FragColor.rgb);\n\t\t\t#elif defined(NEUTRAL_TONE_MAPPING)\n\t\t\t\tgl_FragColor.rgb = NeutralToneMapping(gl_FragColor.rgb);\n\t\t\t#elif defined(AGX_TONE_MAPPING)\n\t\t\t\tgl_FragColor.rgb = AgXToneMapping(gl_FragColor.rgb);\n\t\t\t#endif\n\n\t\t\t// color space\n\n\t\t\t#ifdef SRGB_COLOR_SPACE\n\t\t\t\tgl_FragColor = LinearTosRGB(gl_FragColor);\n\t\t\t#endif\n\t\t}\n\t\t"};class J extends F{constructor(){super(),this.color=new e.Color3(0,0,0),this.offset=1,this._vignettingPass=new e.ShaderPostPass(tt),this._vignettingPass.material.premultipliedAlpha=!0}render(t,e,n,r,a){const s=this._vignettingPass;s.uniforms.tDiffuse=n.texture,this.color.toArray(s.uniforms.vignettingColor),s.uniforms.vignettingOffset=this.offset,t.setRenderTarget(r),t.setClearColor(0,0,0,0),a?t.clear(e.clearColor,e.clearDepth,e.clearStencil):t.clear(!0,!0,!1),a&&(s.material.transparent=e._tempClearColor[3]<1||!e.clearColor,s.renderStates.camera.rect.fromArray(e._tempViewport)),s.render(t),a&&(s.material.transparent=!1,s.renderStates.camera.rect.set(0,0,1,1))}dispose(){this._vignettingPass.dispose()}}const tt={name:"ec_vignetting_blend",defines:{},uniforms:{tDiffuse:null,vignettingColor:[0,0,0],vignettingOffset:1},vertexShader:r,fragmentShader:"\n\t\tuniform vec3 vignettingColor;\n\t\tuniform float vignettingOffset;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 color = texture2D(tDiffuse, v_Uv);\n\t\t\t\t\t\tvec2 uv = (v_Uv - vec2(0.5)) * vec2(vignettingOffset);\n\t\t\tcolor.rgb = mix(color.rgb, vignettingColor, clamp(dot(uv, uv), 0.0, 1.0));\n\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"};class et extends F{constructor(){super(),this.offset=1,this._hBlurPass=new e.ShaderPostPass(_),this._vBlurPass=new e.ShaderPostPass(m),this._blendPass=new e.ShaderPostPass(nt),this._blendPass.material.premultipliedAlpha=!0}resize(t,e){this._hBlurPass.uniforms.h=4/t,this._vBlurPass.uniforms.v=4/e}render(t,e,n,r,a){const s=e._renderTargetCache.allocate(1),i=e._renderTargetCache.allocate(1),o=this._blendPass;t.setRenderTarget(s),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._hBlurPass.uniforms.tDiffuse=n.texture,this._hBlurPass.render(t),t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._vBlurPass.uniforms.tDiffuse=s.texture,this._vBlurPass.render(t),o.uniforms.tDiffuse=n.texture,o.uniforms.blurOffset=this.offset,o.uniforms.blurTexture=i.texture,t.setRenderTarget(r),t.setClearColor(0,0,0,0),a?t.clear(e.clearColor,e.clearDepth,e.clearStencil):t.clear(!0,!0,!1),a&&(o.material.transparent=e._tempClearColor[3]<1||!e.clearColor,o.renderStates.camera.rect.fromArray(e._tempViewport)),o.render(t),a&&(o.material.transparent=!1,o.renderStates.camera.rect.set(0,0,1,1)),e._renderTargetCache.release(s,1),e._renderTargetCache.release(i,1)}dispose(){this._hBlurPass.dispose(),this._vBlurPass.dispose(),this._blendPass.dispose()}}const nt={name:"ec_blur_blend",defines:{},uniforms:{tDiffuse:null,blurOffset:1,blurTexture:null},vertexShader:r,fragmentShader:"\n\t\tuniform float blurOffset;\n\n\t\t\t\tuniform sampler2D blurTexture;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 color = texture2D(tDiffuse, v_Uv);\n\t\t\t\t\t\tvec2 uv = (v_Uv - vec2(0.5)) * vec2(blurOffset);\n\n\t\t\t\t\t\tvec3 color2 = texture2D(blurTexture, v_Uv).rgb;\n\n\t\t\tcolor.rgb = mix(color.rgb, color2, clamp(dot(uv, uv), 0.0, 1.0));\n\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"};const rt={name:"ec_outline_edge",defines:{},uniforms:{tDiffuse:null,texSize:[.5,.5],edgeColor:[1,1,1],channelMask:[1,0,0,0]},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 edgeColor;\n\n\t\tuniform vec4 channelMask;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\tfloat c1 = dot(texture2D(tDiffuse, v_Uv + uvOffset.xy), channelMask);\n\t\t\tfloat c2 = dot(texture2D(tDiffuse, v_Uv - uvOffset.xy), channelMask);\n\t\t\tfloat c3 = dot(texture2D(tDiffuse, v_Uv + uvOffset.yw), channelMask);\n\t\t\tfloat c4 = dot(texture2D(tDiffuse, v_Uv - uvOffset.yw), channelMask);\n\t\t\tfloat b1 = max(c1, c2);\n\t\t\tfloat b2 = max(c3, c4);\n\t\t\tfloat a = max(b1, b2);\n\t\t\tgl_FragColor = vec4(edgeColor, a);\n\t\t\t\t}\n\t\t"},at={name:"ec_outline_blend",defines:{},uniforms:{maskTexture:null,edgeTexture:null,colorTexture:null,strength:1,channelMask:[1,0,0,0]},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture;\n\t\t\t\tuniform float strength;\n\n\t\tuniform vec4 channelMask;\n\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 edgeColor = texture2D(edgeTexture, v_Uv);\n\t\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, v_Uv);\n\n\t\t\t\t\t\tvec4 outlineColor = edgeColor * strength;\n\t\t\toutlineColor.a *= (1.0 - dot(maskColor, channelMask));\n\n\t\t\t\t\t\tvec4 color = texture2D(colorTexture, v_Uv);\n\t\t\t\n\t\t\t\t\t\tcolor.rgb = outlineColor.rgb * outlineColor.a + color.rgb * (1. - outlineColor.a);\n\t\t\tcolor.a = outlineColor.a + color.a * (1. - outlineColor.a);\n\n\t\t\t\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"};class st extends F{constructor(){super(),this.bufferDependencies=[{key:"MarkBuffer"}],this.color=new e.Color3(1,1,1),this.strength=1.5,this.stride=5,this._channelPass=new e.ShaderPostPass(u),this._blurXPass=new e.ShaderPostPass(it),this._blurYPass=new e.ShaderPostPass(ot),this._blendPass=new e.ShaderPostPass(lt),this._blendPass.material.premultipliedAlpha=!0}resize(t,e){this._blurXPass.uniforms.texSize[0]=t,this._blurXPass.uniforms.texSize[1]=e,this._blurYPass.uniforms.texSize[0]=t,this._blurYPass.uniforms.texSize[1]=e}render(t,n,r,a,s){const i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n._renderTargetCache.allocate(0),f=n.getBuffer("MarkBuffer"),u=f.attachManager.getAttachIndex(this.name),c=f.attachManager.getChannelIndex(this.name);t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._channelPass.uniforms.tDiffuse=f.output(u)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];for(let t=0;t<4;t++)this._channelPass.uniforms.channelMask[t]=t===c?1:0;this._channelPass.render(t),t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurXPass.uniforms.tDiffuse=i.texture,this._blurXPass.uniforms.stride=this.stride,this._blurXPass.render(t),t.setRenderTarget(l),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurYPass.uniforms.tDiffuse=i.texture,this._blurYPass.uniforms.blurX=o.texture,this._blurYPass.uniforms.stride=this.stride,this._blurYPass.uniforms.glowness=this.strength,this.color.toArray(this._blurYPass.uniforms.glowColor),this._blurYPass.render(t),t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=l.texture,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0),n._renderTargetCache.release(l,0)}dispose(){this._channelPass.dispose(),this._blurXPass.dispose(),this._blurYPass.dispose(),this._blendPass.dispose()}}const it={name:"ec_innerglow_x",defines:{},uniforms:{tDiffuse:null,texSize:[1,1],stride:10},vertexShader:r,fragmentShader:"\n\t\t#define WT9_0 1.0\n\t\t#define WT9_1 0.8\n\t\t#define WT9_2 0.6\n\t\t#define WT9_3 0.4\n\t\t#define WT9_4 0.2\n\t\t#define WT9_NORMALIZE 5.2\n\n\t\tvarying vec2 v_Uv;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 texSize;\n\t\tuniform float stride;\n\n\t\tvoid main() {\n\t\t\tfloat texelIncrement = 0.25 * stride / texSize.x;\n\n\t\t\tfloat colour = texture2D(tDiffuse,vec2(v_Uv.x + texelIncrement, v_Uv.y)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * texelIncrement, v_Uv.y)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * texelIncrement, v_Uv.y)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = 0.5 * stride / texSize.x;\n\t\t\tcolour += texture2D(tDiffuse,vec2(v_Uv.x + texelIncrement, v_Uv.y)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * texelIncrement, v_Uv.y)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * texelIncrement, v_Uv.y)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = 0.75 * stride / texSize.x;\n\t\t\tcolour += texture2D(tDiffuse,vec2(v_Uv.x + texelIncrement, v_Uv.y)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * texelIncrement, v_Uv.y)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * texelIncrement, v_Uv.y)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = stride / texSize.x;\n\t\t\tcolour += texture2D(tDiffuse,vec2(v_Uv.x + texelIncrement, v_Uv.y)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * texelIncrement, v_Uv.y)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * texelIncrement, v_Uv.y)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\tfloat col = 1.0 - colour * 0.25;\n\n\t\t\tgl_FragColor = vec4(col,col,col,col);\n\t\t}\n\t\t"},ot={name:"ec_innerglow_y",defines:{},uniforms:{tDiffuse:null,blurX:null,texSize:[1,1],stride:10,glowness:2,glowColor:[1,0,0]},vertexShader:r,fragmentShader:"\n\t\t#define WT9_0 1.0\n\t\t#define WT9_1 0.8\n\t\t#define WT9_2 0.6\n\t\t#define WT9_3 0.4\n\t\t#define WT9_4 0.2\n\t\t#define WT9_NORMALIZE 5.2\n\n\t\tvarying vec2 v_Uv;\n\t\tuniform vec2 texSize;\n\t\tuniform float stride;\n\t\tuniform float glowness;\n\t\tuniform vec3 glowColor;\n\t\tuniform sampler2D blurX;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvoid main() {\n\t\t\tfloat texelIncrement = 0.25 * stride / texSize.y;\n\n\t\t\tfloat colour = texture2D(blurX, vec2(v_Uv.x , v_Uv.y + texelIncrement)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y + 2.0 * texelIncrement)).x* (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 3.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 4.0 * texelIncrement)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y - 1.0 * texelIncrement)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 2.0 * texelIncrement)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 3.0 * texelIncrement)).x* (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y- 4.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = 0.5 * stride / texSize.y;\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + texelIncrement)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y + 2.0 * texelIncrement)).x* (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 3.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 4.0 * texelIncrement)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y - 1.0 * texelIncrement)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 2.0 * texelIncrement)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 3.0 * texelIncrement)).x* (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y- 4.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = 0.75 * stride / texSize.y;\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + texelIncrement)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y + 2.0 * texelIncrement)).x* (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 3.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 4.0 * texelIncrement)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y - 1.0 * texelIncrement)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 2.0 * texelIncrement)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 3.0 * texelIncrement)).x* (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y- 4.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = stride / texSize.y;\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + texelIncrement)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y + 2.0 * texelIncrement)).x* (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 3.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 4.0 * texelIncrement)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y - 1.0 * texelIncrement)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 2.0 * texelIncrement)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 3.0 * texelIncrement)).x* (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y- 4.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\tvec3 glo = (0.25 * glowness * colour) * glowColor;\n\t\t\tvec4 maskTexel = texture2D(tDiffuse, v_Uv);\n\t\t\t\n\t\t\tgl_FragColor = vec4(maskTexel.x * glo, 1.);\n\t\t}\n\t\t"},lt={name:"ec_tint",defines:{},uniforms:{texture1:null,texture2:null},vertexShader:r,fragmentShader:"\n\t\t\t\tuniform sampler2D texture1;\n\t\t\t\tuniform sampler2D texture2;\n\t\t\t\tvarying vec2 v_Uv;\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 texel1 = texture2D(texture1, v_Uv);\n\t\t\t\t\t\tvec4 texel2 = texture2D(texture2, v_Uv);\n\n\t\t\t\t\t\tfloat v = max(max(texel2.x, texel2.y), texel2.z);\n\n\t\t\t\t\t\tvec4 color = mix(texel1, vec4(texel2.rgb, texel1.a), v);\n\t\t\t\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"};class ft extends F{constructor(){super(),this.bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],this.strength=1,this.radius=.4,this.threshold=.01,this.smoothWidth=.1,this.maskStrength=1,this._maskPass=new e.ShaderPostPass(c),this._highlightPass=new e.ShaderPostPass(d),this._blurPass=new e.ShaderPostPass(h),this._compositePass=new e.ShaderPostPass(ct),this._blendPass=new e.ShaderPostPass(o),this._blendPass.material.premultipliedAlpha=!0,this._compositePass.uniforms.bloomFactors=new Float32Array([1,.8,.6,.4,.2]),this._compositePass.uniforms.bloomTintColors=new Float32Array([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]),this._tempRTList=[]}render(t,n,r,a,s){const i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(1),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("MarkBuffer"),u=n.getBuffer("ColorMarkBuffer"),c=f.attachManager.has(this.name),d=u.attachManager.getAttachIndex(this.name),h=u.output(d)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(c){const n=f.attachManager.getAttachIndex(this.name),r=f.attachManager.getChannelIndex(this.name);t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=f.output(n)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=h,this._maskPass.uniforms.additiveStrength=this.maskStrength;for(let t=0;t<4;t++)this._maskPass.uniforms.channel[t]=t===r?this.maskStrength:0;this._maskPass.render(t)}t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._highlightPass.uniforms.tDiffuse=c?o.texture:h,this._highlightPass.uniforms.diffuseStrength=c?1:this.maskStrength,this._highlightPass.uniforms.threshold=this.threshold,this._highlightPass.uniforms.smoothWidth=this.smoothWidth,this._highlightPass.render(t);let _=i;for(let e=0;e<ut.length;e++){const r=n._renderTargetCache.allocate(e+1);t.setRenderTarget(r),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=_.texture,this._blurPass.uniforms.texSize[0]=_.width,this._blurPass.uniforms.texSize[1]=_.height,this._blurPass.uniforms.direction[0]=1,this._blurPass.uniforms.direction[1]=0,this._blurPass.uniforms.kernelRadius=ut[e],this._blurPass.render(t);const a=n._renderTargetCache.allocate(e+1);t.setRenderTarget(a),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=r.texture,this._blurPass.uniforms.direction[0]=0,this._blurPass.uniforms.direction[1]=1,this._blurPass.render(t),n._renderTargetCache.release(r,e+1),_=a,this._tempRTList[e]=a}t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._compositePass.uniforms.blurTexture1=this._tempRTList[0].texture,this._compositePass.uniforms.blurTexture2=this._tempRTList[1].texture,this._compositePass.uniforms.blurTexture3=this._tempRTList[2].texture,this._compositePass.uniforms.blurTexture4=this._tempRTList[3].texture,this._compositePass.uniforms.blurTexture5=this._tempRTList[4].texture,this._compositePass.uniforms.bloomRadius=this.radius,this._compositePass.uniforms.bloomStrength=this.strength,this._compositePass.render(t),t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,1),this._tempRTList.forEach(((t,e)=>n._renderTargetCache.release(t,e+1)))}dispose(){this._maskPass.dispose(),this._highlightPass.dispose(),this._blurPass.dispose(),this._compositePass.dispose(),this._blendPass.dispose()}}const ut=[3,5,7,9,11],ct={name:"ec_bloom_composite",defines:{NUM_MIPS:5},uniforms:{blurTexture1:null,blurTexture2:null,blurTexture3:null,blurTexture4:null,blurTexture5:null,bloomStrength:1,bloomRadius:0,bloomFactors:null,bloomTintColors:null},vertexShader:r,fragmentShader:"\n\t\tuniform sampler2D blurTexture1;\n\t\tuniform sampler2D blurTexture2;\n\t\tuniform sampler2D blurTexture3;\n\t\tuniform sampler2D blurTexture4;\n\t\tuniform sampler2D blurTexture5;\n\t\tuniform float bloomStrength;\n\t\tuniform float bloomRadius;\n\t\tuniform float bloomFactors[NUM_MIPS];\n\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tgl_FragColor = bloomStrength * (\n\t\t\t\tlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, v_Uv) +\n\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, v_Uv) +\n\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, v_Uv) +\n\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, v_Uv) +\n\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, v_Uv)\n\t\t\t);\n\t\t\t\t}\n\t\t"};class dt extends F{constructor(){super(),this.bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],this.strength=.5,this.blendRate=.4,this.blurSize=1,this.maskStrength=1,this._maskPass=new e.ShaderPostPass(c),this._downSamplerPass=new e.ShaderPostPass(ht),this._hBlurPass=new e.ShaderPostPass(_),this._vBlurPass=new e.ShaderPostPass(m),this._blendPass=new e.ShaderPostPass(o),this._blendPass.material.premultipliedAlpha=!0,this._tempRTList=[],this._tempRTList2=[]}render(t,n,r,a,s){for(let t=0;t<6;t++)this._tempRTList[t]=n._renderTargetCache.allocate(t),this._tempRTList2[t]=n._renderTargetCache.allocate(t);const i=n.getBuffer("SceneBuffer"),o=n.getBuffer("MarkBuffer"),l=n.getBuffer("ColorMarkBuffer"),f=o.attachManager.has(this.name),u=l.attachManager.getAttachIndex(this.name),c=l.output(u)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(f){const n=o.attachManager.getAttachIndex(this.name),r=o.attachManager.getChannelIndex(this.name);t.setRenderTarget(this._tempRTList[0]),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=i.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=o.output(n)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=c,this._maskPass.uniforms.additiveStrength=this.maskStrength;for(let t=0;t<4;t++)this._maskPass.uniforms.channel[t]=t===r?this.maskStrength:0;this._maskPass.render(t)}t.setRenderTarget(this._tempRTList[1]),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._downSamplerPass.uniforms.tDiffuse=f?this._tempRTList[0].texture:c,this._downSamplerPass.uniforms.bright=4*(f?1:this.maskStrength),this._downSamplerPass.uniforms.texSize[0]=this._tempRTList[0].width,this._downSamplerPass.uniforms.texSize[1]=this._tempRTList[0].height,this._downSamplerPass.render(t);for(let e=2;e<6;e++)t.setRenderTarget(this._tempRTList[e]),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._downSamplerPass.uniforms.tDiffuse=this._tempRTList[e-1].texture,this._downSamplerPass.uniforms.texSize[0]=this._tempRTList[e-1].width,this._downSamplerPass.uniforms.texSize[1]=this._tempRTList[e-1].height,this._downSamplerPass.uniforms.bright=1,this._downSamplerPass.render(t);for(let e=0;e<5;e++)t.setRenderTarget(this._tempRTList[e]),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._hBlurPass.uniforms.tDiffuse=this._tempRTList[e+1].texture,this._hBlurPass.uniforms.h=2*this.blurSize/this._tempRTList[e].width,this._hBlurPass.render(t);for(let e=0;e<5;e++)t.setRenderTarget(this._tempRTList2[e]),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._vBlurPass.uniforms.tDiffuse=this._tempRTList[e].texture,this._vBlurPass.uniforms.v=2*this.blurSize/this._tempRTList[e].height,this._vBlurPass.render(t);for(let e=3;e>=0;e--)t.setRenderTarget(this._tempRTList[e]),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=this._tempRTList2[e].texture,this._blendPass.uniforms.texture2=e<3?this._tempRTList[e+1].texture:this._tempRTList2[e+1].texture,this._blendPass.uniforms.colorWeight1=(1-this.blendRate)*this.strength,this._blendPass.uniforms.alphaWeight1=(1-this.blendRate)*this.strength,this._blendPass.uniforms.colorWeight2=this.blendRate*this.strength,this._blendPass.uniforms.alphaWeight2=this.blendRate*this.strength,this._blendPass.render(t);t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=this._tempRTList[0].texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),this._tempRTList.forEach(((t,e)=>n._renderTargetCache.release(t,e))),this._tempRTList2.forEach(((t,e)=>n._renderTargetCache.release(t,e)))}dispose(){this._maskPass.dispose(),this._downSamplerPass.dispose(),this._hBlurPass.dispose(),this._vBlurPass.dispose(),this._blendPass.dispose()}}const ht={name:"ec_sg_downsample",defines:{},uniforms:{tDiffuse:null,texSize:[512,512],bright:1},vertexShader:r,fragmentShader:"\n\t\tvarying vec2 v_Uv;\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 texSize;\n\t\n\t\tuniform float bright;\n\t\t\n\t\tvoid main() {\n\t\t\t\tvec4 d = vec4(-1.0, -1.0, 1.0, 1.0) / texSize.xyxy;\n\t\t\tgl_FragColor = (texture2D(tDiffuse, v_Uv + d.xy) +\n\t\t\t\ttexture2D(tDiffuse, v_Uv + d.zy) +\n\t\t\t\ttexture2D(tDiffuse, v_Uv + d.xw) +\n\t\t\t\ttexture2D(tDiffuse, v_Uv + d.zw)) * bright * 0.25;\n\t\t}\n\t"};class _t extends F{constructor(){super(),this.bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],this.center=new e.Vector2(.5,.5),this.direction=new e.Vector2(0,1),this.strength=1,this._maskPass=new e.ShaderPostPass(c),this._tailingPass=new e.ShaderPostPass(mt),this._blendPass=new e.ShaderPostPass(o),this._blendPass.material.premultipliedAlpha=!0}render(t,n,r,a,s){const i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("MarkBuffer"),u=n.getBuffer("ColorMarkBuffer"),c=f.attachManager.has(this.name),d=u.attachManager.getAttachIndex(this.name),h=u.output(d)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(c){const n=f.attachManager.getAttachIndex(this.name),r=f.attachManager.getChannelIndex(this.name);t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=f.output(n)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=h;for(let t=0;t<4;t++)this._maskPass.uniforms.channel[t]=t===r?1:0;this._maskPass.render(t)}t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._tailingPass.uniforms.blurMap=c?i.texture:h,this._tailingPass.uniforms.center[0]=this.center.x,this._tailingPass.uniforms.center[1]=this.center.y,this._tailingPass.uniforms.direction[0]=this.direction.x,this._tailingPass.uniforms.direction[1]=this.direction.y,this._tailingPass.uniforms.intensity=10*this.strength,this._tailingPass.render(t),t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)}dispose(){this._maskPass.dispose(),this._tailingPass.dispose(),this._blendPass.dispose()}}const mt={name:"ec_tailing",defines:{},uniforms:{blurMap:null,blurStart:1,blurWidth:-.1,direction:[0,1],intensity:10,glowGamma:.8,center:[.5,.5]},vertexShader:r,fragmentShader:"\n\t\tvarying vec2 v_Uv;\n\t\tuniform sampler2D blurMap;\n\t\tuniform float blurStart;\n\t\tuniform float blurWidth;\n\t\tuniform vec2 direction;\n\t\tuniform float intensity;\n\t\tuniform float glowGamma;\n\t\tuniform vec2 center;\n\n\t\tvoid main() {\n\t\t\tvec2 texCoord = v_Uv;\n\t\t\tvec4 blurred = texture2D(blurMap, texCoord);\n\t\t\tvec2 resCoord = vec2(0.0);\n\n\t\t\tfor(float i = 0.0; i < 31.0; i++) {\n\t\t\t\tfloat scale = blurStart + blurWidth * ((31.0 - i) / (31.0 - 1.0));\n\t\t\t\tvec2 tmp = texCoord * scale;\n\t\t\t\tresCoord = mix(texCoord, tmp, direction);\n\t\t\t\tvec4 tmpc = texture2D(blurMap, resCoord) * (i / 31.0) * (i / 31.0);\n\t\t\t\tblurred += tmpc / 31.0;\n\t\t\t}\n\n\t\t\tblurred.r = pow(blurred.r, glowGamma);\n\t\t\tblurred.g = pow(blurred.g, glowGamma);\n\t\t\tblurred.b = pow(blurred.b, glowGamma);\n\t\t\tblurred.rgb *= intensity;\n\t\t\tblurred.rgb = clamp(blurred.rgb, 0.0, 1.0);\n\n\t\t\tvec4 origTex = texture2D(blurMap, texCoord);\n\t\t\tvec4 blurResult = origTex + blurred;\n\t\t\t// blurResult *= 2;\n\n\t\t\tvec2 dir = texCoord - center;\n\t\t\tfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\n\t\t\tfloat t = dist * 1.0;\n\t\t\tt = clamp(t, 0.0, 1.0); // We need 0 <= t <= 1\n\n\t\t\tgl_FragColor = blurResult * t;\n\t\t}\n\t\t"};class pt extends F{constructor(){super(),this.bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],this.center=new e.Vector2(.5,.5),this.strength=1,this._maskPass=new e.ShaderPostPass(c),this._radialTailingPass=new e.ShaderPostPass(xt),this._blendPass=new e.ShaderPostPass(o),this._blendPass.material.premultipliedAlpha=!0}render(t,n,r,a,s){const i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("MarkBuffer"),u=n.getBuffer("ColorMarkBuffer"),c=f.attachManager.has(this.name),d=u.attachManager.getAttachIndex(this.name),h=u.output(d)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(c){const n=f.attachManager.getAttachIndex(this.name),r=f.attachManager.getChannelIndex(this.name);t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=f.output(n)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=h;for(let t=0;t<4;t++)this._maskPass.uniforms.channel[t]=t===r?1:0;this._maskPass.render(t)}t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._radialTailingPass.uniforms.blurMap=c?i.texture:h,this._radialTailingPass.uniforms.center[0]=this.center.x,this._radialTailingPass.uniforms.center[1]=this.center.y,this._radialTailingPass.uniforms.intensity=10*this.strength,this._radialTailingPass.render(t),t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)}dispose(){this._maskPass.dispose(),this._radialTailingPass.dispose(),this._blendPass.dispose()}}const xt={name:"ec_radial_tailing",defines:{},uniforms:{blurMap:null,blurStart:1,blurWidth:-.1,intensity:10,glowGamma:.8,center:[.5,.5]},vertexShader:r,fragmentShader:"\n\t\tvarying vec2 v_Uv;\n\t\tuniform sampler2D blurMap;\n\t\tuniform float blurStart;\n\t\tuniform float blurWidth;\n\t\tuniform float intensity;\n\t\tuniform float glowGamma;\n\t\tuniform vec2 center;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 texCoord = v_Uv;\n\t\t\tvec2 ctrPt = center;\n\t\t\tvec4 blurred = texture2D(blurMap, texCoord);\n\t\t\n\t\t\tfor(float i = 0.0; i < 31.0; i++) {\n\t\t\t\tfloat scale = blurStart + blurWidth * ((31.0 - i) / (31.0 - 1.0));\n\t\t\t\tvec2 tmp = (texCoord - ctrPt) * scale + ctrPt;\n\t\t\t\tvec4 tmpc = texture2D(blurMap, tmp) * (i / 31.0) * (i / 31.0);\n\t\t\n\t\t\t\tblurred += tmpc / 31.0;\n\t\t\t}\n\t\t\n\t\t\tblurred.r = pow(blurred.r, glowGamma);\n\t\t\tblurred.g = pow(blurred.g, glowGamma);\n\t\t\tblurred.b = pow(blurred.b, glowGamma);\n\t\t\tblurred.rgb *= intensity;\n\t\t\tblurred.rgb = clamp(blurred.rgb, 0.0, 1.0);\n\t\t\n\t\t\tvec4 origTex = texture2D(blurMap, texCoord);\n\t\t\tvec4 blurResult = origTex + blurred;\n\t\t\t// blurResult *= 2;\n\t\t\n\t\t\tvec2 dir = texCoord - ctrPt;\n\t\t\tfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\n\t\t\tfloat t = dist * 1.0;\n\t\t\tt = clamp(t, 0.0, 1.0); // We need 0 <= t <= 1\n\t\t\n\t\t\tgl_FragColor = blurResult * t;\n\t\t}\n\t\t"};class At extends F{constructor(){super(),this.bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],this.center=new e.Vector2(.5,.5),this.strength=1,this._maskPass=new e.ShaderPostPass(c),this._ghostingPass=new e.ShaderPostPass(Tt),this._blendPass=new e.ShaderPostPass(o),this._blendPass.material.premultipliedAlpha=!0}render(t,n,r,a,s){const i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("MarkBuffer"),u=n.getBuffer("ColorMarkBuffer"),c=f.attachManager.has(this.name),d=u.attachManager.getAttachIndex(this.name),h=u.output(d)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(c){const n=f.attachManager.getAttachIndex(this.name),r=f.attachManager.getChannelIndex(this.name);t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=f.output(n)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=h;for(let t=0;t<4;t++)this._maskPass.uniforms.channel[t]=t===r?1:0;this._maskPass.render(t)}t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._ghostingPass.uniforms.blurMap=c?i.texture:h,this._ghostingPass.uniforms.center[0]=this.center.x,this._ghostingPass.uniforms.center[1]=this.center.y,this._ghostingPass.uniforms.intensity=3*this.strength,this._ghostingPass.render(t),t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)}dispose(){this._maskPass.dispose(),this._ghostingPass.dispose(),this._blendPass.dispose()}}const Tt={name:"ec_ghosting",defines:{},uniforms:{blurMap:null,blurStart:1,blurWidth:-.1,intensity:3,glowGamma:.8,center:[.5,.5]},vertexShader:r,fragmentShader:"\n\t\tvarying vec2 v_Uv;\n\t\tuniform sampler2D blurMap;\n\t\tuniform float blurStart;\n\t\tuniform float blurWidth;\n\t\tuniform float intensity;\n\t\tuniform float glowGamma;\n\t\tuniform vec2 center;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 uv = v_Uv;\n\t\t\tvec2 ctrPt = center;\n\t\t\n\t\t\tfloat scale = blurStart + blurWidth * 1.0;\n\t\t\tvec2 tmp = (uv - ctrPt) * scale + ctrPt;\n\n\t\t\tvec4 blurred = texture2D(blurMap, tmp);\n\t\t\tblurred.rgb = pow(blurred.rgb, vec3(glowGamma));\n\t\t\tblurred.rgb *= intensity;\n\t\t\tblurred.rgb = clamp(blurred.rgb, 0.0, 1.0);\n\t\t\t\n\t\t\tvec2 dir = uv - ctrPt;\n\t\t\tfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\n\t\t\n\t\t\tgl_FragColor = blurred * clamp(dist, 0.0, 1.0);\n\t\t}\n\t\t"};class gt extends n{constructor(t,n,r){super(t,n,r),this.enableCameraJitter=!0,this._rt=new e.RenderTarget2D(t,n),this._rt.texture.minFilter=e.TEXTURE_FILTER.NEAREST,this._rt.texture.magFilter=e.TEXTURE_FILTER.NEAREST,this._rt.texture.generateMipmaps=!1,r.floatColorBuffer?this._rt.texture.type=e.PIXEL_TYPE.FLOAT:this._rt.texture.type=e.PIXEL_TYPE.HALF_FLOAT;const a=new e.Texture2D;v(a,!0),this._rt.attach(a,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),this._renderOptions={getMaterial:vt()},this._fixedRenderStates={scene:null,lights:null,camera:{id:0,version:0,near:0,far:0,position:new e.Vector3,logDepthCameraNear:0,logDepthBufFC:0,viewMatrix:new e.Matrix4,projectionMatrix:new e.Matrix4,projectionViewMatrix:new e.Matrix4,rect:new e.Vector4(0,0,1,1)},gammaFactor:2,outputEncoding:null},this.layers=[0],this.cameraNear=-1,this.cameraFar=-1}setIfRenderReplaceFunction(t){t?this._renderOptions.ifRender=t:delete this._renderOptions.ifRender}setGeometryReplaceFunction(t){t?this._renderOptions.getGeometry=t:delete this._renderOptions.getGeometry}setMaterialReplaceFunction(t){this._renderOptions.getMaterial=t?vt(t):vt()}render(t,e,n,r){if(!this.needRender())return;const a=e.$cameraJitter,s=this.enableCameraJitter&&a.accumulating();t.setRenderTarget(this._rt),t.setClearColor(-2.1,-2.1,.5,.5),t.clear(!0,!0,!1);const i=this._renderOptions,o=n.getRenderStates(r),l=n.getRenderQueue(r),f=this._getFixedRenderStates(o);s&&a.jitterProjectionMatrix(f.camera,this._rt.width,this._rt.height),t.beginRender();const u=this.layers;for(let e=0,n=u.length;e<n;e++){const n=l.getLayer(u[e]);t.renderRenderableList(n.opaque,f,i),t.renderRenderableList(n.transparent,f,i)}t.endRender()}output(){return this._rt}getCurrentRenderStates(){return this._fixedRenderStates}resize(t,e){super.resize(t,e),this._rt.resize(t,e)}dispose(){super.dispose(),this._rt.dispose()}_getFixedRenderStates(t){const e=this._fixedRenderStates;e.scene=t.scene,e.lights=t.lights,e.gammaFactor=t.gammaFactor,e.outputEncoding=t.outputEncoding;const n=e.camera,r=t.camera;n.id=r.id,n.version=r.version,n.position=r.position,n.logDepthCameraNear=r.logDepthCameraNear,n.logDepthBufFC=r.logDepthBufFC,n.viewMatrix=r.viewMatrix,n.rect=r.rect;const a=this.cameraNear>0?this.cameraNear:r.near,s=this.cameraFar>0?this.cameraFar:r.far;return n.near=a,n.far=s,n.projectionMatrix.copy(r.projectionMatrix),this.cameraNear>0||this.cameraFar>0?(n.projectionMatrix.elements[10]=-(s+a)/(s-a),n.projectionMatrix.elements[14]=-2*s*a/(s-a),n.projectionViewMatrix.multiplyMatrices(n.projectionMatrix,n.viewMatrix)):n.projectionViewMatrix.copy(r.projectionViewMatrix),e}}function vt(t=Ft){return function(e){const n=t(e);return n.diffuseMap=e.material.diffuseMap,n.uniforms.metalness=void 0!==e.material.metalness?e.material.metalness:.5,n.uniforms.roughness=void 0!==e.material.roughness?e.material.roughness:.5,n.metalnessMap=e.material.metalnessMap,n.roughnessMap=e.material.roughnessMap,n.side=e.material.side,n}}const Pt=new Map,Et=new WeakMap;function Ft(t){let n=Et.get(t.material);if(!n){const r=!t.geometry.attributes.a_Normal||t.material.shading===e.SHADING_TYPE.FLAT_SHADING,a=!!t.material.diffuseMap,s=!!t.material.metalnessMap,i=!!t.material.roughnessMap,o=t.object.isSkinnedMesh&&t.object.skeleton,l=!!t.object.morphTargetInfluences,f=!!t.object.morphTargetInfluences&&t.object.geometry.morphAttributes.normal,u=t.material.side;let c=0;o&&(c=t.object.skeleton.boneTexture?1024:t.object.skeleton.bones.length);const d=r+"_"+a+"_"+s+"_"+i+"_"+o+"_"+c+"_"+l+"_"+f+"_"+u;if(n=Pt.get(d),!n){const _=new e.ShaderMaterial(St);_.shading=r?e.SHADING_TYPE.FLAT_SHADING:e.SHADING_TYPE.SMOOTH_SHADING,_.alphaTest=a?.999:0,_.side=u,n={refCount:0,material:_},Pt.set(d,n)}function h(){t.material.removeEventListener("dispose",h),Et.delete(t.material),n.refCount--,n.refCount<=0&&Pt.delete(d)}Et.set(t.material,n),n.refCount++,t.material.addEventListener("dispose",h)}return n.material}const St={name:"ec_gbuffer",defines:{},uniforms:{metalness:.5,roughness:.5},vertexShader:"\n\t\t\t\t#include <common_vert>\n\t\t\t\t#include <morphtarget_pars_vert>\n\t\t\t\t#include <skinning_pars_vert>\n\t\t\t\t#include <normal_pars_vert>\n\t\t\t\t#include <uv_pars_vert>\n\t\t#include <diffuseMap_pars_vert>\n\t\t#include <modelPos_pars_frag>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <uv_vert>\n\t\t\t#include <diffuseMap_vert>\n\t\t\t\t\t#include <begin_vert>\n\t\t\t\t\t#include <morphtarget_vert>\n\t\t\t\t\t#include <morphnormal_vert>\n\t\t\t\t\t#include <skinning_vert>\n\t\t\t\t\t#include <skinnormal_vert>\n\t\t\t\t\t#include <normal_vert>\n\t\t\t\t\t#include <pvm_vert>\n\t\t\t#include <modelPos_vert>\n\t\t\t\t}\n\t\t",fragmentShader:`\n\t\t\t\t#include <common_frag>\n\t\t\t\t#include <diffuseMap_pars_frag>\n\t\t#include <alphaTest_pars_frag>\n\n\t\t\t\t#include <uv_pars_frag>\n\n\t\t\t\t#include <packing>\n\t\t\t\t#include <normal_pars_frag>\n\n\t\t${a}\n\n\t\t\t\tuniform float metalness;\n\t\t\n\t\t#ifdef USE_METALNESSMAP\n\t\t\t\t\t\tuniform sampler2D metalnessMap;\n\t\t\t\t#endif\n\n\t\tuniform float roughness;\n\n\t\t\t\t#ifdef USE_ROUGHNESSMAP\n\t\t\t\t\t\tuniform sampler2D roughnessMap;\n\t\t\t\t#endif\n\n\t\t#include <modelPos_pars_frag>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\t#if defined(USE_DIFFUSE_MAP) && defined(ALPHATEST)\n\t\t\t\t\t\t\t\tvec4 texelColor = texture2D(diffuseMap, vDiffuseMapUV);\n\t\t\t\t\t\t\t\tfloat alpha = texelColor.a * u_Opacity;\n\t\t\t\t\t\t\t\tif(alpha < u_AlphaTest) discard;\n\t\t\t\t\t\t#endif\n\n\t\t\t#ifdef FLAT_SHADED\n\t\t\t\tvec3 fdx = dFdx(v_modelPos);\n\t\t\t\tvec3 fdy = dFdy(v_modelPos);\n\t\t\t\tvec3 normal = normalize(cross(fdx, fdy));\n\t\t\t#else\n\t\t\t\t\t\t\tvec3 normal = normalize(v_Normal);\n\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\tnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t\t\t#endif \n\t\t\t#endif\n\n\t\t\tfloat metalnessFactor = metalness;\n\t\t\t\t\t\t#ifdef USE_METALNESSMAP\n\t\t\t\tmetalnessFactor *= texture2D(metalnessMap, v_Uv).b;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tfloat roughnessFactor = roughness;\n\t\t\t\t\t\t#ifdef USE_ROUGHNESSMAP\n\t\t\t\t\t\t\t\troughnessFactor *= texture2D(roughnessMap, v_Uv).g;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tvec4 outputColor;\n\t\t\t\t\t\toutputColor.xy = unitVectorToOctahedron(normal);\n\t\t\toutputColor.z = saturate(metalnessFactor);\n\t\t\t\t\t\toutputColor.w = saturate(roughnessFactor);\n\t\t\t\t\t\t\n\t\t\t\t\t\tgl_FragColor = outputColor;\n\t\t\t\t}\n\t\t`};class Nt{constructor(t){this.keys=new Array,this.masks=new Array,this.attachChannelSize=t}allocate(t,e=P.ALL){return this.keys.push(t),this.masks.push(e),this.keys.length-1}getAttachIndex(t){const e=this.keys.indexOf(t);return Math.max(0,Math.floor(e/this.attachChannelSize))}getChannelIndex(t){const e=this.keys.indexOf(t);return Math.max(0,e%this.attachChannelSize)}has(t){return this.keys.indexOf(t)>-1}count(){return this.keys.length}attachCount(){return Math.ceil(this.keys.length/this.attachChannelSize)}getKey(t,e){return this.keys[t*this.attachChannelSize+e]}getMask(t,e){return this.masks[t*this.attachChannelSize+e]}getAttachInfo(t,e={count:0,keys:[],masks:[]}){e.count=0;for(let n=0;n<this.attachChannelSize;n++){const r=this.getKey(t,n),a=this.getMask(t,n);void 0!==r&&void 0!==a&&(e.keys[e.count]=r,e.masks[e.count]=a,e.count++)}return e}reset(){this.keys.length=0,this.masks.length=0}}class Ct extends n{constructor(t,n,r){super(t,n,r);const a=r.bufferMipmaps;this._rts=[];for(let s=0;s<r.maxMarkAttachment;s++){const s=new e.RenderTarget2D(t,n);s.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),g(s.texture,r),a||(s.texture.generateMipmaps=!1,s.texture.minFilter=e.TEXTURE_FILTER.LINEAR),this._rts.push(s)}const s=T(r);this._mrts=[];for(let a=0;a<r.maxMarkAttachment;a++){const a=new e.RenderTarget2D(t,n);a.attach(new e.RenderBuffer(t,n,s,r.samplerNumber),e.ATTACHMENT.COLOR_ATTACHMENT0),a.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),this._mrts.push(a)}this._state={attachIndex:0,attachInfo:{count:0,keys:[],masks:[]}};const i=new Nt(4);this._opacityRenderOptions={getMaterial:Mt(void 0,this._state,i,P.OPAQUE),ifRender:bt(void 0,this._state,P.OPAQUE)},this._transparentRenderOptions={getMaterial:Mt(void 0,this._state,i,P.TRANSPARENT),ifRender:bt(void 0,this._state,P.TRANSPARENT)},this.attachManager=i,this.layers=[0]}setIfRenderReplaceFunction(t){t?(this._opacityRenderOptions.ifRender=bt(t,this._state,P.OPAQUE),this._transparentRenderOptions.ifRender=bt(t,this._state,P.TRANSPARENT)):(this._opacityRenderOptions.ifRender=bt(void 0,this._state,P.OPAQUE),this._transparentRenderOptions.ifRender=bt(void 0,this._state,P.TRANSPARENT))}setGeometryReplaceFunction(t){t?(this._opacityRenderOptions.getGeometry=t,this._transparentRenderOptions.getGeometry=t):(delete this._opacityRenderOptions.getGeometry,delete this._transparentRenderOptions.getGeometry)}setMaterialReplaceFunction(t){t?(this._opacityRenderOptions.getMaterial=Mt(t,this._state,this.attachManager,P.OPAQUE),this._transparentRenderOptions.getMaterial=Mt(t,this._state,this.attachManager,P.TRANSPARENT)):(this._opacityRenderOptions.getMaterial=Mt(void 0,this._state,this.attachManager,P.OPAQUE),this._transparentRenderOptions.getMaterial=Mt(void 0,this._state,this.attachManager,P.TRANSPARENT))}render(t,e,n,r){if(!this.needRender())return;const a=this.attachManager.attachCount();a>this._rts.length&&console.error("XXMarkBuffer: attachCount<"+a+"> bigger then options.maxMarkAttachment<"+this._rts.length+">.");for(let s=0;s<a;s++){const a=this._rts[s],i=this._mrts[s];e.$useMSAA?(t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!1,!1)):(t.setRenderTarget(a),t.setClearColor(0,0,0,0),t.clear(!0,!1,!1));const o=n.getRenderStates(r),l=n.getRenderQueue(r);this._state.attachIndex=s,this.attachManager.getAttachInfo(s,this._state.attachInfo);let f=0;const u=this._state.attachInfo.masks,c=this._state.attachInfo.count;for(let t=0;t<c;t++)f|=u[t];t.beginRender();const d=this.layers;for(let e=0,n=d.length;e<n;e++){const n=l.getLayer(d[e]);f&P.OPAQUE&&t.renderRenderableList(n.opaque,o,this._opacityRenderOptions),f&P.TRANSPARENT&&t.renderRenderableList(n.transparent,o,this._transparentRenderOptions)}t.endRender(),e.$useMSAA&&(t.setRenderTarget(a),t.blitRenderTarget(i,a,!0,!1,!1)),t.updateRenderTargetMipmap(a)}}output(t=0){return this._rts[t]}resize(t,e){super.resize(t,e),this._rts.forEach((n=>n.resize(t,e))),this._mrts.forEach((n=>n.resize(t,e)))}dispose(){super.dispose(),this._rts.forEach((t=>t.dispose())),this._mrts.forEach((t=>t.dispose()))}}function bt(t=It,e,n){return function(r){if(!t(r))return!1;if(!r.object.effects)return!1;let a=0;for(let t=0;t<e.attachInfo.count;t++){const n=e.attachInfo.keys[t];r.object.effects[n]&&(a|=e.attachInfo.masks[t])}return a&n}}function It(t){return!0}function Mt(t=Lt,n,r,a){return function(s){const i=t(s);i.side=e.DRAW_SIDE.DOUBLE;for(let t=0;t<4;t++){const e=r.getKey(n.attachIndex,t),o=r.getMask(n.attachIndex,t);i.uniforms.mColor[t]=o&a&&s.object.effects[e]||0}return i}}const yt=new Map;function Lt(t){const n=t.object.isSkinnedMesh&&t.object.skeleton,r=!!t.object.morphTargetInfluences,a=t.material.drawMode,s=n+"_"+r+"_"+a;let i;return yt.has(s)?i=yt.get(s):(i=new e.ShaderMaterial(Dt),i.premultipliedAlpha=!0,i.transparent=!0,i.blending=e.BLEND_TYPE.ADD,i.drawMode=a,yt.set(s,i)),i}const Dt={name:"ec_mark",defines:{},uniforms:{mColor:[1,1,1,1]},vertexShader:"\n\t\t\t\t#include <common_vert>\n\t\t\t\t#include <morphtarget_pars_vert>\n\t\t\t\t#include <skinning_pars_vert>\n\t\t\t\t#include <uv_pars_vert>\n\t\t#include <diffuseMap_pars_vert>\n\t\t#include <logdepthbuf_pars_vert>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <uv_vert>\n\t\t\t#include <diffuseMap_vert>\n\t\t\t\t\t#include <begin_vert>\n\t\t\t\t\t#include <morphtarget_vert>\n\t\t\t\t\t#include <skinning_vert>\n\t\t\t\t\t#include <pvm_vert>\n\t\t\t#include <logdepthbuf_vert>\n\t\t\t\t}\n\t\t",fragmentShader:"\n\t\t\t\t#include <common_frag>\n\t\t\t\t#include <diffuseMap_pars_frag>\n\t\t#include <alphaTest_pars_frag>\n\n\t\t\t\t#include <uv_pars_frag>\n\n\t\t#include <logdepthbuf_pars_frag>\n\n\t\tuniform vec4 mColor;\n\n\t\t\t\tvoid main() {\n\t\t\t#include <logdepthbuf_frag>\n\t\t\t\n\t\t\t\t\t\t#if defined(USE_DIFFUSE_MAP) && defined(ALPHATEST)\n\t\t\t\t\t\t\t\tvec4 texelColor = texture2D(diffuseMap, vDiffuseMapUV);\n\t\t\t\t\t\t\t\tfloat alpha = texelColor.a * u_Opacity;\n\t\t\t\t\t\t\t\tif(alpha < u_AlphaTest) discard;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tgl_FragColor = mColor;\n\t\t\t\t}\n\t\t"};class Rt extends Ct{constructor(t,e,n){super(t,e,n)}syncDepthAttachments(t,n){this._rts.forEach((t=>t.dispose())),this._mrts.forEach((t=>t.dispose())),A(t)?this._rts.forEach((n=>{n.attach(t,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),n.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)})):this._rts.forEach((n=>{n.attach(t,e.ATTACHMENT.DEPTH_ATTACHMENT),n.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)})),A(n)?this._mrts.forEach((t=>{t.attach(n,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),t.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)})):this._mrts.forEach((t=>{t.attach(n,e.ATTACHMENT.DEPTH_ATTACHMENT),t.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)})),this.needsUpdate=!0}}class Ut extends n{constructor(t,n,r){super(t,n,r);const a=r.bufferMipmaps;this._rts=[];for(let s=0;s<r.maxColorAttachment;s++){const s=new e.RenderTarget2D(t,n);s.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),g(s.texture,r),a||(s.texture.generateMipmaps=!1,s.texture.minFilter=e.TEXTURE_FILTER.LINEAR),this._rts.push(s)}const s=T(r);this._mrts=[];for(let a=0;a<r.maxColorAttachment;a++){const a=new e.RenderTarget2D(t,n);a.attach(new e.RenderBuffer(t,n,s,r.samplerNumber),e.ATTACHMENT.COLOR_ATTACHMENT0),a.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),this._mrts.push(a)}const i={key:null};this._state=i;const o=new Nt(1);this._renderOptions={getMaterial:Xt(void 0,i),ifRender:Ot(void 0,i)},this.attachManager=o,this.layers=[0]}setIfRenderReplaceFunction(t){this._renderOptions.ifRender=Ot(t||void 0,this._state)}setGeometryReplaceFunction(t){t?this._renderOptions.getGeometry=t:delete this._renderOptions.getGeometry}setMaterialReplaceFunction(t){this._renderOptions.getMaterial=Xt(t||void 0,this._state)}syncDepthAttachments(t,n){this._rts.forEach((t=>t.dispose())),this._mrts.forEach((t=>t.dispose())),A(t)?this._rts.forEach((n=>{n.attach(t,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),n.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)})):this._rts.forEach((n=>{n.attach(t,e.ATTACHMENT.DEPTH_ATTACHMENT),n.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)})),A(n)?this._mrts.forEach((t=>{t.attach(n,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),t.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)})):this._mrts.forEach((t=>{t.attach(n,e.ATTACHMENT.DEPTH_ATTACHMENT),t.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)})),this.needsUpdate=!0}render(t,e,n,r){if(!this.needRender())return;const a=this.attachManager.attachCount();a>this._rts.length&&console.error("ColorMarkBuffer: attachCount<"+a+"> bigger then options.maxColorAttachment<"+this._rts.length+">.");for(let s=0;s<a;s++){const a=this._rts[s],i=this._mrts[s];e.$useMSAA?(t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!1,!1)):(t.setRenderTarget(a),t.setClearColor(0,0,0,0),t.clear(!0,!1,!1));const o=this._renderOptions,l=this.attachManager,f=n.getRenderStates(r),u=n.getRenderQueue(r);this._state.key=l.getKey(s,0);const c=l.getMask(s,0);t.beginRender();const d=this.layers;for(let e=0,n=d.length;e<n;e++){const n=u.getLayer(d[e]);c&P.OPAQUE&&t.renderRenderableList(n.opaque,f,o),c&P.TRANSPARENT&&t.renderRenderableList(n.transparent,f,o)}t.endRender(),e.$useMSAA&&(t.setRenderTarget(a),t.blitRenderTarget(i,a,!0,!1,!1)),t.updateRenderTargetMipmap(a)}}output(t=0){return this._rts[t]}resize(t,e){super.resize(t,e),this._rts.forEach((n=>n.resize(t,e))),this._mrts.forEach((n=>n.resize(t,e)))}dispose(){super.dispose(),this._rts.forEach((t=>t.dispose())),this._mrts.forEach((t=>t.dispose()))}}function Ot(t=wt,e){return function(n){return!!t(n)&&(!!n.object.effects&&!!n.object.effects[e.key])}}function wt(t){return!0}function Xt(t=kt,n){return function(r){const a=t(r);return a.side=e.DRAW_SIDE.DOUBLE,a.uniforms.strength=r.object.effects[n.key]||0,a}}const Ht=new Map;function kt(t){const n=t.object.isSkinnedMesh&&t.object.skeleton,r=!!t.object.morphTargetInfluences,a=t.material.drawMode,s=n+"_"+r+"_"+a+!!t.material.diffuseMap;let i;return Ht.has(s)?i=Ht.get(s):(i=new e.ShaderMaterial(Bt),i.premultipliedAlpha=!1,i.drawMode=a,Ht.set(s,i)),i.transparent=t.material.transparent,i.blending=t.material.blending,i.opacity=t.material.opacity,i.diffuse.copy(t.material.diffuse),i.diffuseMap=t.material.diffuseMap,i}const Bt={name:"ec_color",defines:{},uniforms:{strength:1},vertexShader:"\n\t\t\t\t#include <common_vert>\n\t\t\t\t#include <morphtarget_pars_vert>\n\t\t\t\t#include <skinning_pars_vert>\n\t\t\t\t#include <uv_pars_vert>\n\t\t#include <diffuseMap_pars_vert>\n\t\t#include <logdepthbuf_pars_vert>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <uv_vert>\n\t\t\t#include <diffuseMap_vert>\n\t\t\t\t\t#include <begin_vert>\n\t\t\t\t\t#include <morphtarget_vert>\n\t\t\t\t\t#include <skinning_vert>\n\t\t\t\t\t#include <pvm_vert>\n\t\t\t#include <logdepthbuf_vert>\n\t\t\t\t}\n\t\t",fragmentShader:"\n\t\t\t\t#include <common_frag>\n\t\t\t\t#include <diffuseMap_pars_frag>\n\t\t#include <alphaTest_pars_frag>\n\n\t\t\t\t#include <uv_pars_frag>\n\n\t\t#include <logdepthbuf_pars_frag>\n\n\t\tuniform float strength;\n\n\t\t\t\tvoid main() {\n\t\t\t#include <logdepthbuf_frag>\n\n\t\t\tvec4 outColor = vec4(u_Color, u_Opacity);\n\n\t\t\t#ifdef USE_DIFFUSE_MAP\n\t\t\t\toutColor *= texture2D(diffuseMap, vDiffuseMapUV);\n\t\t\t#endif\n\n\t\t\t#ifdef ALPHATEST\n\t\t\t\tif(outColor.a < u_AlphaTest) discard;\n\t\t\t#endif\n\n\t\t\toutColor.a *= strength;\n\n\t\t\t\t\t\tgl_FragColor = outColor;\n\t\t\t\t}\n\t\t"};class Qt extends n{constructor(t,n,r){super(t,n,r),this.enableCameraJitter=!0,this._rt=new e.RenderTarget2D(t,n),this._rt.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),this._mrt=new e.RenderTarget2D(t,n),this._mrt.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),this.clearColor=!0,this.clearDepth=!0,this.clearStencil=!0,this.renderLayers=[{id:0,mask:P.ALL}],this._sceneRenderOptions={},this._renderStates=null}syncAttachments(t,n,r,a){this._rt.dispose(),this._mrt.dispose(),this._rt.attach(t,e.ATTACHMENT.COLOR_ATTACHMENT0),A(n)?(this._rt.attach(n,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),this._rt.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)):(this._rt.attach(n,e.ATTACHMENT.DEPTH_ATTACHMENT),this._rt.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)),this._mrt.attach(r,e.ATTACHMENT.COLOR_ATTACHMENT0),A(a)?(this._mrt.attach(a,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),this._mrt.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)):(this._mrt.attach(a,e.ATTACHMENT.DEPTH_ATTACHMENT),this._mrt.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)),this.needsUpdate=!0}setIfRenderReplaceFunction(t){t?this._sceneRenderOptions.ifRender=t:delete this._sceneRenderOptions.ifRender}setGeometryReplaceFunction(t){t?this._sceneRenderOptions.getGeometry=t:delete this._sceneRenderOptions.getGeometry}setOutputEncoding(t){this._rt.texture.encoding=t}getOutputEncoding(){return this._rt.texture.encoding}render(t,n,r,a){if(!this.needRender())return;const s=n.$useMSAA,i=s?this._mrt:this._rt,o=!!i._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],l=n.$cameraJitter,f=this.enableCameraJitter&&l.accumulating();t.setRenderTarget(i),n.clearColor?t.setClearColor(...n._tempClearColor):t.setClearColor(0,0,0,0),t.clear(this.clearColor,this.clearDepth,this.clearStencil&&o);const u=r.getRenderStates(a),c=r.getRenderQueue(a);f&&l.jitterProjectionMatrix(u.camera,this._rt.width,this._rt.height),this.$renderScene(t,c,u),f&&l.restoreProjectionMatrix(u.camera),s&&(t.setRenderTarget(this._rt),t.blitRenderTarget(this._mrt,this._rt,!0,!0,o)),t.updateRenderTargetMipmap(this._rt),this._renderStates=u}output(){return this._rt}getCurrentRenderStates(){return this._renderStates}resize(t,e){super.resize(t,e),this._rt.resize(t,e),this._mrt.resize(t,e)}dispose(){super.dispose(),this._rt.dispose(),this._mrt.dispose()}$renderScene(t,e,n){const r=this._sceneRenderOptions;t.beginRender();const a=this.renderLayers;for(let s=0,i=a.length;s<i;s++){const{id:i,mask:o,options:l=r}=a[s],f=e.getLayer(i);f&&(f.opaqueCount>0&&o&P.OPAQUE&&t.renderRenderableList(f.opaque,n,l),f.transparentCount>0&&o&P.TRANSPARENT&&t.renderRenderableList(f.transparent,n,l))}t.endRender();const s=e.getLayer(1);s&&s.opaqueCount+s.transparentCount>0&&(t.clear(!1,!0,!1),t.beginRender(),t.renderRenderableList(s.opaque,n,r),t.renderRenderableList(s.transparent,n,r),t.endRender())}}class Yt{constructor(t,e,n){this._width=t,this._height=e,this._options=n,this._map=new Map}allocate(t=0){let n=this._map.get(t);if(n||(n=[],this._map.set(t,n)),n.length>0)return n.shift();{const n=Math.pow(2,t),r=Math.ceil(this._width/n),a=Math.ceil(this._height/n),s=new e.RenderTarget2D(r,a),i=s._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];return g(i,this._options),i.minFilter=e.TEXTURE_FILTER.LINEAR,i.magFilter=e.TEXTURE_FILTER.LINEAR,i.generateMipmaps=!1,s.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),s}}release(t,e=0){this._map.get(e).push(t)}resize(t,e){this._width=t,this._height=e,this._map.forEach(((t,e)=>{const n=Math.pow(2,e),r=Math.ceil(this._width/n),a=Math.ceil(this._height/n);t.forEach((t=>{t.resize(r,a)}))}))}updateStats(t){let e=0;this._map.forEach(((t,n)=>{const r=Math.pow(2,n);e+=t.length/(r*r)})),t.fboCache=e}dispose(){this._map.forEach((t=>{t.forEach((t=>{t.dispose()}))})),this._map.clear()}}class Wt{constructor(t=30){this._enabled=!1,this._state=zt.DISABLED,this._totalFrame=0,this._haltonSequenece=[],this._frame=0,this._jitterMatrix=new e.Matrix4,this._originMatrix=new e.Matrix4,this.setTotalFrame(t)}setTotalFrame(t){this._totalFrame=t;const e=[];for(let n=0;n<t;n++)e.push([Gt(n,2),Gt(n,3)]);this._haltonSequence=e}set enable(t){this._state===zt.DISABLED?t&&(this._frame=0,this._state=zt.ACCUMULATING):(this._state===zt.ACCUMULATING||this._state===zt.FINISHED)&&(t||(this._frame=0,this._state=zt.DISABLED))}get enable(){return this._state!==zt.DISABLED}reset(){this._state!==zt.DISABLED&&(this._state===zt.ACCUMULATING?this._frame=0:this._state===zt.FINISHED&&(this._state=zt.ACCUMULATING))}update(){this._state===zt.ACCUMULATING&&(this._frame++,this._frame>=this._totalFrame&&(this._state=zt.FINISHED,this._frame=0))}finished(){return this._state===zt.FINISHED}accumulating(){return this._state===zt.ACCUMULATING}frame(){return this._frame}totalFrame(){return this._totalFrame}jitterProjectionMatrix(t,e,n){if(this._state!==zt.ACCUMULATING)return;const r=this._haltonSequence[this._frame],a=this._jitterMatrix;a.elements[12]=(2*r[0]-1)/e,a.elements[13]=(2*r[1]-1)/n,this._originMatrix.copy(t.projectionMatrix),t.projectionMatrix.premultiply(a),t.projectionViewMatrix.multiplyMatrices(t.projectionMatrix,t.viewMatrix)}restoreProjectionMatrix(t){this._state===zt.ACCUMULATING&&(t.projectionMatrix.copy(this._originMatrix),t.projectionViewMatrix.multiplyMatrices(t.projectionMatrix,t.viewMatrix))}}const zt={DISABLED:1,ACCUMULATING:2,FINISHED:3};function Gt(t,e){let n=0,r=1/e,a=t;for(;a>0;)n+=r*(a%e),a=Math.floor(a/e),r/=e;return n}class Zt{constructor(t,n,r={}){this._size=new e.Vector2(t,n),r.webgl2=r.webgl2||!1,r.samplerNumber=r.samplerNumber||8,r.maxMarkAttachment=r.maxMarkAttachment||5,r.maxColorAttachment=r.maxColorAttachment||5,r.depthTextureAttachment=r.depthTextureAttachment||!1,r.bufferMipmaps=r.bufferMipmaps||!1,r.floatColorBuffer=r.floatColorBuffer||!1,r.highDynamicRange=r.highDynamicRange||!1,r.hdrMode=r.hdrMode||E.RGBA16,r.webgl2||r.hdrMode!==E.R11G11B10||(console.warn("EffectComposer: HDRMode.R11G11B10 is only supported in WebGL2, fallback to HDRMode.RGBA16."),r.hdrMode=E.RGBA16),r.halfFloatMarkBuffer&&console.warn("EffectComposer: The `halfFloatMarkBuffer` option is deprecated. Override mark buffer class to impltement this.");const a=new Qt(t,n,r),s=new gt(t,n,r),i=new Ct(t,n,r),o=new Rt(t,n,r),l=new Ut(t,n,r);this._bufferMap=new Map([["SceneBuffer",a],["GBuffer",s],["NonDepthMarkBuffer",i],["MarkBuffer",o],["ColorMarkBuffer",l]]),this._defaultColorTexture=new e.Texture2D,g(this._defaultColorTexture,r),this._defaultMSColorRenderBuffer=new e.RenderBuffer(t,n,T(r),r.samplerNumber),r.bufferMipmaps||(this._defaultColorTexture.generateMipmaps=!1,this._defaultColorTexture.minFilter=e.TEXTURE_FILTER.LINEAR);const u=r.webgl2?e.PIXEL_FORMAT.DEPTH_COMPONENT24:e.PIXEL_FORMAT.DEPTH_COMPONENT16;r.depthTextureAttachment?(this._defaultDepthAttachment=new e.Texture2D,v(this._defaultDepthAttachment)):this._defaultDepthAttachment=new e.RenderBuffer(t,n,u),this._defaultMSDepthRenderBuffer=new e.RenderBuffer(t,n,u,r.samplerNumber),r.depthTextureAttachment?(this._defaultDepthStencilAttachment=new e.Texture2D,v(this._defaultDepthStencilAttachment,!0)):this._defaultDepthStencilAttachment=new e.RenderBuffer(t,n,e.PIXEL_FORMAT.DEPTH_STENCIL),this._defaultMSDepthStencilRenderBuffer=new e.RenderBuffer(t,n,e.PIXEL_FORMAT.DEPTH24_STENCIL8,r.samplerNumber),this._externalColorAttachment=null,this._externalDepthAttachment=null,this._samplerNumber=r.samplerNumber,this._externalMSAA=null,this._stencilBuffer=!1,this._syncAttachments(),this._copyPass=new e.ShaderPostPass(f),this._copyPass.material.premultipliedAlpha=!0,this._renderTargetCache=new Yt(t,n,r),this._cameraJitter=new Wt,this._effectList=[],this._tempClearColor=[0,0,0,1],this._tempViewport=[0,0,1,1],this._tempBufferNames=new Set,this._stats={fboCache:0,markBuffers:0,colorMarkBuffers:0,currentBufferUsage:{}},this.sceneMSAA=!1,this.clearColor=!0,this.clearDepth=!0,this.clearStencil=!1,this.debugger=null}getSize(){return this._size}_syncAttachments(){const t=this._externalColorAttachment,e=this._externalDepthAttachment,n=!!t&&!!e,r=this._externalMSAA;let a=this._stencilBuffer;n&&(a=A(e));const s=a?this._defaultDepthStencilAttachment:this._defaultDepthAttachment,i=a?this._defaultMSDepthStencilRenderBuffer:this._defaultMSDepthRenderBuffer;let o,l,f,u,c,d;n?r?(o=this._defaultColorTexture,l=s,f=t,u=e,c=s,d=e):(o=t,l=e,f=this._defaultMSColorRenderBuffer,u=i,c=e,d=i):(o=this._defaultColorTexture,l=s,f=this._defaultMSColorRenderBuffer,u=i,c=s,d=i),this._bufferMap.forEach((t=>{t.syncAttachments?t.syncAttachments(o,l,f,u):t.syncDepthAttachments&&t.syncDepthAttachments(c,d)}))}set stencilBuffer(t){this._stencilBuffer=t,this._syncAttachments()}get stencilBuffer(){return this._stencilBuffer}setExternalAttachment(t,e){const n=qt(t);n===qt(e)?(this._externalColorAttachment=t,this._externalDepthAttachment=e,this._externalMSAA=n>0,this._syncAttachments()):console.warn("EffectComposer.setExternalAttachment: color and depth attachment MultipleSampling not match.")}clearExternalAttachment(){this._externalColorAttachment=null,this._externalDepthAttachment=null,this._externalMSAA=null,this._syncAttachments()}addBuffer(t,e){this._bufferMap.set(t,e)}removeBuffer(t){this._bufferMap.delete(t)}getBuffer(t){return this._bufferMap.get(t)}addEffect(t,e,n=0){this.getEffect(t)?console.warn(""):(e.name=t,this._effectList.push({name:t,effect:e,order:n}),e.resize(this._size.x,this._size.y))}removeEffect(t){const e=this._effectList.findIndex((e=>e.name===t));e>-1&&this._effectList.splice(e,1)}getEffect(t){const e=this._effectList.find((e=>e.name===t));return e?e.effect:null}render(t,e,n,r){const a=e.getRenderStates(n);if(t.getClearColor().toArray(this._tempClearColor),n.rect.toArray(this._tempViewport),n.rect.set(0,0,1,1),a.camera.rect.set(0,0,1,1),this._bufferMap.forEach((t=>{t.attachManager&&t.attachManager.reset()})),this.debugger)return this.debugger.bufferDependencies.forEach((r=>{const a=this._bufferMap.get(r);this.debugger.channel&&a.attachManager&&a.attachManager.allocate(this.debugger.channel,this.debugger.mask),a.render(t,this,e,n)})),this.debugger.render(t,this,r),void t.setClearColor(...this._tempClearColor);this._effectList.sort(Vt);let s=this._effectList.findIndex((t=>t.effect.active));const i=s>-1;if(this._tempBufferNames.clear(),i){this._tempBufferNames.add("SceneBuffer");let a=!1;this._effectList.forEach((t=>{t.effect.active&&(t.effect.bufferDependencies.forEach((({key:e,mask:n})=>{this._tempBufferNames.add(e),this._bufferMap.get(e).attachManager&&this._bufferMap.get(e).attachManager.allocate(t.name,n)})),a=a||t.effect.needCameraJitter)})),this._cameraJitter.enable=a,this._tempBufferNames.forEach((r=>{this._bufferMap.get(r).render(t,this,e,n)}));let i,o=this._renderTargetCache.allocate(),l=this._renderTargetCache.allocate();this._effectList.sort(jt);const f=this._effectList.length,u=this._effectList.findIndex((t=>t.effect.active));s=f-1-s,this._effectList.forEach(((e,n)=>{if(!e.effect.active)return;const a=n<s;e.effect.render(t,this,n===u?this._bufferMap.get("SceneBuffer").output():o,a?l:r,!a),i=o,o=l,l=i})),this._renderTargetCache.release(o),this._renderTargetCache.release(l),this._cameraJitter.update()}else if(this._externalColorAttachment&&this._externalDepthAttachment){const a=this._bufferMap.get("SceneBuffer");a.render(t,this,e,n),t.setRenderTarget(r),t.setClearColor(0,0,0,0),t.clear(this.clearColor,this.clearDepth,this.clearStencil);const s=this._copyPass;s.uniforms.tDiffuse=a.output().texture,s.material.transparent=this._tempClearColor[3]<1||!this.clearColor,s.renderStates.camera.rect.fromArray(this._tempViewport),s.render(t)}else{t.setRenderTarget(r),t.setClearColor(...this._tempClearColor),t.clear(this.clearColor,this.clearDepth,this.clearStencil),a.camera.rect.fromArray(this._tempViewport);const s=e.getRenderQueue(n);this._bufferMap.get("SceneBuffer").$renderScene(t,s,a)}t.setClearColor(...this._tempClearColor),n.rect.fromArray(this._tempViewport),a.camera.rect.fromArray(this._tempViewport)}getStats(){this._renderTargetCache.updateStats(this._stats);const t=this.getBuffer("MarkBuffer").attachManager.attachCount(),e=this.getBuffer("NonDepthMarkBuffer").attachManager.attachCount(),n=this.getBuffer("ColorMarkBuffer").attachManager.attachCount();this._stats.markBuffers=t+e,this._stats.colorMarkBuffers=n;for(const[t,e]of this._bufferMap)e.attachManager||(this._stats.currentBufferUsage[t]=this._tempBufferNames.has(t)?1:0);return this._stats}resize(t,e){this._size.set(t,e),this._bufferMap.forEach((n=>n.resize(t,e))),this._renderTargetCache.resize(t,e),this._effectList.forEach((n=>n.effect.resize(t,e)))}dispose(){this._bufferMap.forEach((t=>t.dispose())),this._renderTargetCache.dispose(),this._effectList.forEach((t=>t.effect.dispose())),this._copyPass.dispose()}get $useMSAA(){return(null!==this._externalMSAA?this._externalMSAA:this.sceneMSAA)&&this._samplerNumber>1}get $cameraJitter(){return this._cameraJitter}}function jt(t,e){return t.order-e.order}function Vt(t,e){return e.order-t.order}function qt(t){return t.isTexture?0:t.multipleSampling}class Kt{constructor(){this.bufferDependencies=[]}render(t,e,n){console.error("Debugger: .render() must be implemented in subclass.")}resize(t,e){}dispose(){}}class $t extends Kt{constructor(){super(),this.bufferDependencies=["GBuffer"],this._mainPass=new e.ShaderPostPass(te),this.debugType=Jt.Normal}render(t,n,r){t.setRenderTarget(r),t.setClearColor(0,0,0,1),t.clear(!0,!0,!1);const a=n.getBuffer("GBuffer"),s=a.getCurrentRenderStates();this._mainPass.uniforms.colorTexture0=a.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._mainPass.uniforms.depthTexture=a.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._mainPass.uniforms.debug=this.debugType||0,s.camera.projectionViewMatrix.toArray(this._mainPass.uniforms.projectionView),this._mainPass.render(t)}}const Jt={Normal:0,Depth:1,Position:2,Metalness:3,Roughness:4};$t.DebugTypes=Jt;const te={name:"ec_debug_gbuffer",defines:{},uniforms:{colorTexture0:null,depthTexture:null,projectionView:new Float32Array(16),debug:0},vertexShader:r,fragmentShader:`\n\t\tuniform sampler2D colorTexture0;\n\t\tuniform sampler2D depthTexture;\n\t\tuniform int debug;\n\n\t\tuniform mat4 projectionView;\n\n\t\tvarying vec2 v_Uv;\n\n\t\t${s}\n\n\t\tvoid main() {\n\t\t\tvec2 texCoord = v_Uv;\n\t\t\tvec4 texel = texture2D(colorTexture0, texCoord);\n\n\t\t\tif (texel.r < -2.0) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tvec3 normal = octahedronToUnitVector(texel.rg);\n\t\t\tfloat depth = texture2D(depthTexture, texCoord).r;\n\n\t\t\tvec2 xy = texCoord * 2.0 - 1.0;\n\t\t\tfloat z = depth * 2.0 - 1.0;\n\n\t\t\tvec4 projectedPos = vec4(xy, z, 1.0);\n\t\t\tvec4 p4 = inverse(projectionView) * projectedPos;\n\n\t\t\tvec3 position = p4.xyz / p4.w;\n\n\t\t\tif (debug == 0) {\n\t\t\t\tgl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);\n\t\t\t} else if (debug == 1) {\n\t\t\t\tgl_FragColor = vec4(vec3(depth), 1.0);\n\t\t\t} else if (debug == 2) {\n\t\t\t\tgl_FragColor = vec4(position, 1.0);\n\t\t\t} else if (debug == 3) {\n\t\t\t\tgl_FragColor = vec4(vec3(texel.b), 1.0);\n\t\t\t} else {\n\t\t\t\tgl_FragColor = vec4(vec3(texel.a), 1.0);\n\t\t\t}\n\t\t}\n\t`};Object.defineProperties(W.prototype,{mixType:{set:function(t){console.warn("SSREffect: mixType has been deprecated, use falloff instead."),this.falloff=t},get:function(){return console.warn("SSREffect: mixType has been deprecated, use falloff instead."),this.falloff}}}),t.AccumulationBuffer=class extends n{constructor(t,n,r){function a(){const a=new e.RenderTarget2D(t,n);return g(a.texture,r),a.texture.minFilter=e.TEXTURE_FILTER.NEAREST,a.texture.magFilter=e.TEXTURE_FILTER.NEAREST,a.texture.generateMipmaps=!1,a.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),a}super(t,n,r),this._prevRT=a(),this._accumRT=a()}swap(){const t=this._prevRT;this._prevRT=this._accumRT,this._accumRT=t}accumRT(){return this._accumRT}output(){return this._prevRT}resize(t,e){super.resize(t,e),this._prevRT.resize(t,e),this._accumRT.resize(t,e)}dispose(){super.dispose(),this._prevRT.dispose(),this._accumRT.dispose()}},t.BloomEffect=S,t.BlurEdgeEffect=et,t.Buffer=n,t.ChromaticAberrationEffect=N,t.ColorCorrectionEffect=b,t.ColorMarkBufferDebugger=class extends Kt{constructor(){super(),this.bufferDependencies=["SceneBuffer","ColorMarkBuffer"],this._mainPass=new e.ShaderPostPass(f),this.channel="",this.mask=P.ALL}render(t,n,r){t.setRenderTarget(r),t.setClearColor(0,0,0,1),t.clear(!0,!0,!1);const a=n.getBuffer("ColorMarkBuffer"),s=a.attachManager.getAttachIndex(this.channel);this._mainPass.uniforms.tDiffuse=a.output(s)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._mainPass.render(t)}},t.DOFEffect=M,t.Debugger=Kt,t.DefaultEffectComposer=class extends Zt{constructor(t,e,n){super(t,e,n),this.addEffect("SSAO",new U,0),this.addEffect("SSR",new W,1),this.addEffect("ColorCorrection",new b,2),this.addEffect("DOF",new M,3),this.addEffect("Bloom",new S,4),this.addEffect("InnerGlow",new st,10),this.addEffect("Glow",new ft,11),this.addEffect("SoftGlow",new dt,12),this.addEffect("Tailing",new _t,13),this.addEffect("RadialTailing",new pt,14),this.addEffect("Ghosting",new At,15),this.addEffect("FXAA",new R,101),this.addEffect("ChromaticAberration",new N,102),this.addEffect("Vignetting",new J,103),this.addEffect("BlurEdge",new et,104),this.addEffect("Film",new L,105),this._effectList.forEach((t=>t.effect.active=!1))}},t.Effect=F,t.EffectComposer=Zt,t.FXAAEffect=R,t.FilmEffect=L,t.GBufferDebugger=$t,t.GhostingEffect=At,t.GlowEffect=ft,t.HDRMode=E,t.InnerGlowEffect=st,t.MarkBufferDebugger=class extends Kt{constructor(){super(),this.bufferDependencies=["SceneBuffer","MarkBuffer"],this._mainPass=new e.ShaderPostPass(u),this.channel="",this.mask=P.ALL}render(t,n,r){t.setRenderTarget(r),t.setClearColor(0,0,0,1),t.clear(!0,!0,!1);const a=n.getBuffer("MarkBuffer"),s=a.attachManager.getAttachIndex(this.channel),i=a.attachManager.getChannelIndex(this.channel);this._mainPass.uniforms.tDiffuse=a.output(s)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];for(let t=0;t<4;t++)this._mainPass.uniforms.channelMask[t]=t===i?1:0;this._mainPass.render(t)}},t.NonDepthMarkBufferDebugger=class extends Kt{constructor(){super(),this.bufferDependencies=["NonDepthMarkBuffer"],this._mainPass=new e.ShaderPostPass(u),this.channel="",this.mask=P.ALL}render(t,n,r){t.setRenderTarget(r),t.setClearColor(0,0,0,1),t.clear(!0,!0,!1);const a=n.getBuffer("NonDepthMarkBuffer"),s=a.attachManager.getAttachIndex(this.channel),i=a.attachManager.getChannelIndex(this.channel);this._mainPass.uniforms.tDiffuse=a.output(s)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];for(let t=0;t<4;t++)this._mainPass.uniforms.channelMask[t]=t===i?1:0;this._mainPass.render(t)}},t.OutlineEffect=class extends F{constructor(){super(),this.bufferDependencies=[{key:"NonDepthMarkBuffer"}],this.color=new e.Color3(1,1,1),this.thickness=1,this.strength=1.5,this._downsamplerPass=new e.ShaderPostPass(f),this._edgeDetectionPass=new e.ShaderPostPass(rt),this._blurPass=new e.ShaderPostPass(h),this._blendPass=new e.ShaderPostPass(at),this._blendPass.material.premultipliedAlpha=!0}render(t,n,r,a,s){const i=n._renderTargetCache.allocate(1),o=n._renderTargetCache.allocate(1),l=n.getBuffer("NonDepthMarkBuffer"),f=l.attachManager.getAttachIndex(this.name),u=l.attachManager.getChannelIndex(this.name);t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._downsamplerPass.uniforms.tDiffuse=l.output(f)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._downsamplerPass.render(t),t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._edgeDetectionPass.uniforms.tDiffuse=i.texture,this._edgeDetectionPass.uniforms.texSize[0]=i.width,this._edgeDetectionPass.uniforms.texSize[1]=i.height;for(let t=0;t<4;t++)this._edgeDetectionPass.uniforms.channelMask[t]=t===u?1:0;this.color.toArray(this._edgeDetectionPass.uniforms.edgeColor),this._edgeDetectionPass.render(t),t.setRenderTarget(i),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=o.texture,this._blurPass.uniforms.texSize[0]=o.width,this._blurPass.uniforms.texSize[1]=o.height,this._blurPass.uniforms.direction[0]=1,this._blurPass.uniforms.direction[1]=0,this._blurPass.uniforms.kernelRadius=this.thickness,this._blurPass.render(t),t.setRenderTarget(o),t.setClearColor(0,0,0,0),t.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=i.texture,this._blurPass.uniforms.direction[0]=0,this._blurPass.uniforms.direction[1]=1,this._blurPass.render(t),t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1),this._blendPass.uniforms.colorTexture=r.texture,this._blendPass.uniforms.edgeTexture=o.texture,this._blendPass.uniforms.maskTexture=l.output(f)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._blendPass.uniforms.strength=this.strength;for(let t=0;t<4;t++)this._blendPass.uniforms.channelMask[t]=t===u?1:0;s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,1),n._renderTargetCache.release(o,1)}dispose(){this._downsamplerPass.dispose(),this._edgeDetectionPass.dispose(),this._blurPass.dispose(),this._blendPass.dispose()}},t.RadialTailingEffect=pt,t.RenderListMask=P,t.SSAODebugger=class extends Kt{constructor(){super(),this.bufferDependencies=["GBuffer"],this.defaultEffect=new U}render(t,e,n){(e.getEffect("SSAO")||this.defaultEffect).render(t,e,null,n)}resize(t,e){this.defaultEffect.resize(t,e)}dispose(){this.defaultEffect.dispose()}},t.SSAOEffect=U,t.SSRDebugger=class extends Kt{constructor(){super(),this.bufferDependencies=["SceneBuffer","GBuffer"],this.defaultEffect=new W}render(t,e,n){(e.getEffect("SSR")||this.defaultEffect).render(t,e,null,n)}resize(t,e){this.defaultEffect.resize(t,e)}dispose(){this.defaultEffect.dispose()}},t.SSREffect=W,t.SoftGlowEffect=dt,t.TAAEffect=class extends F{constructor(){super(),this.needCameraJitter=!0,this.bufferDependencies=[{key:"AccumulationBuffer"}],this._accumPass=new e.ShaderPostPass(K),this._copyPass=new e.ShaderPostPass(f),this._reset=!0,this._accumulating=!0,this.onFinish=null}reset(){this._reset=!0}resize(t,e){this._reset=!0}render(t,e,n,r,a){const s=e.$cameraJitter;this._reset&&(s.reset(),this._reset=!1);const i=e.getBuffer("AccumulationBuffer");s.accumulating()?(t.setRenderTarget(i.output()),t.setClearColor(0,0,0,0),t.clear(!0,!1,!1),this._accumPass.uniforms.currTexture=n.texture,this._accumPass.uniforms.prevTexture=i.accumRT().texture,this._accumPass.uniforms.mixRatio=0===s.frame()?0:.9,this._accumPass.render(t),this._accumulating=!0):this._accumulating&&(this.onFinish&&this.onFinish(),this._accumulating=!1),t.setRenderTarget(r),t.setClearColor(0,0,0,0),a?t.clear(e.clearColor,e.clearDepth,e.clearStencil):t.clear(!0,!0,!1);const o=this._copyPass;o.uniforms.tDiffuse=i.output().texture,a&&(o.material.transparent=e._tempClearColor[3]<1||!e.clearColor,o.renderStates.camera.rect.fromArray(e._tempViewport)),o.render(t),a&&(o.material.transparent=!1,o.renderStates.camera.rect.set(0,0,1,1)),i.swap()}dispose(){super.dispose(),this._accumPass.dispose(),this._copyPass.dispose()}},t.TailingEffect=_t,t.ToneMappingEffect=class extends F{constructor(){super(),this.toneMapping=x.Reinhard,this.toneMappingExposure=1,this.outputColorSpace=e.TEXEL_ENCODING_TYPE.SRGB,this._mainPass=new e.ShaderPostPass($),this._toneMapping=null,this._outputColorSpace=null}render(t,n,r,a,s){t.setRenderTarget(a),t.setClearColor(0,0,0,0),s?t.clear(n.clearColor,n.clearDepth,n.clearStencil):t.clear(!0,!0,!1);const i=this._mainPass;i.uniforms.tDiffuse=r.texture,i.uniforms.toneMappingExposure=this.toneMappingExposure,this._toneMapping===this.toneMapping&&this._outputColorSpace===this.outputColorSpace||(this._toneMapping=this.toneMapping,this._outputColorSpace=this.outputColorSpace,i.material.defines={},this._toneMapping===x.Linear?i.material.defines.LINEAR_TONE_MAPPING="":this._toneMapping===x.Reinhard?i.material.defines.REINHARD_TONE_MAPPING="":this._toneMapping===x.Cineon?i.material.defines.CINEON_TONE_MAPPING="":this._toneMapping===x.ACESFilmic?i.material.defines.ACES_FILMIC_TONE_MAPPING="":this._toneMapping===x.Neutral?i.material.defines.NEUTRAL_TONE_MAPPING="":this._toneMapping===x.AgX&&(i.material.defines.AGX_TONE_MAPPING=""),this._outputColorSpace===e.TEXEL_ENCODING_TYPE.SRGB&&(i.material.defines.SRGB_COLOR_SPACE=""),i.material.needsUpdate=!0),s&&(i.material.transparent=n._tempClearColor[3]<1||!n.clearColor,i.renderStates.camera.rect.fromArray(n._tempViewport)),i.render(t),s&&(i.material.transparent=!1,i.renderStates.camera.rect.set(0,0,1,1))}dispose(){this._mainPass.dispose()}},t.ToneMappingType=x,t.VignettingEffect=J,t.additiveShader=o,t.blurShader=i,t.channelShader=u,t.copyShader=f,t.defaultVertexShader=r,t.fxaaShader=p,t.getColorBufferFormat=T,t.highlightShader=d,t.horizontalBlurShader=_,t.isDepthStencilAttachment=A,t.maskShader=c,t.multiplyShader=l,t.octahedronToUnitVectorGLSL=s,t.seperableBlurShader=h,t.setupColorTexture=g,t.setupDepthTexture=v,t.unitVectorToOctahedronGLSL=a,t.verticalBlurShader=m}));
