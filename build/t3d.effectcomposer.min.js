// t3d-effect-composer
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("t3d")):"function"==typeof define&&define.amd?define(["exports","t3d"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).t3d=t.t3d||{},t.t3d)}(this,(function(t,e){"use strict";var n=function(){function t(t,e,n){this.autoUpdate=!0,this.needsUpdate=!0}var e=t.prototype;return e.needRender=function(){return!!this.autoUpdate||!!this.needsUpdate&&(this.needsUpdate=!1,!0)},e.setGeometryReplaceFunction=function(t){},e.render=function(t,e,n,r){},e.output=function(t){},e.resize=function(t,e){this.needsUpdate=!0},e.dispose=function(){this.needsUpdate=!0},t}();function r(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,(a=r.key,s=void 0,"symbol"==typeof(s=function(t,e){if("object"!=typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(a,"string"))?s:String(s)),r)}var a,s}function a(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,s(t,e)}function s(t,e){return s=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},s(t,e)}function i(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function o(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(n)return(n=n.call(t)).next.bind(n);if(Array.isArray(t)||(n=function(t,e){if(t){if("string"==typeof t)return i(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?i(t,e):void 0}}(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var r=0;return function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var l=function(){function t(){this.name="",this.bufferDependencies=[],this.active=!0}var e=t.prototype;return e.render=function(t,e,n,r,a){console.error("Effect: .render() must be implemented in subclass.")},e.resize=function(t,e){},e.dispose=function(){},t}(),f="\n\t\tattribute vec3 a_Position;\n\t\tattribute vec2 a_Uv;\n\n\t\tuniform mat4 u_ProjectionView;\n\t\tuniform mat4 u_Model;\n\n\t\tvarying vec2 v_Uv;\n\n\t\tvoid main() {\n\t\t\t\tv_Uv = a_Uv;\n\t\t\t\tgl_Position = u_ProjectionView * u_Model * vec4(a_Position, 1.0);\n\t\t}\n",u={name:"ec_blur",defines:{NORMALTEX_ENABLED:0,DEPTHTEX_ENABLED:0,DEPTH_PACKING:0,KERNEL_SIZE_INT:"5",KERNEL_SIZE_FLOAT:"5.0"},uniforms:{tDiffuse:null,textureSize:[512,512],direction:0,blurSize:1,kernel:[.122581,.233062,.288713,.233062,.122581],normalTex:null,depthTex:null,projection:new Float32Array(16),viewInverseTranspose:new Float32Array(16),depthRange:1},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform vec2 textureSize;\n\t\t\t\tuniform int direction;\n\t\t\t\tuniform float blurSize;\n\t\t\t\tuniform float kernel[KERNEL_SIZE_INT];\n\n\t\t\t\t#if NORMALTEX_ENABLED == 1\n\t\t\t\t\t\tuniform sampler2D normalTex;\n\t\t\t\t\t\tuniform mat4 viewInverseTranspose;\n\t\t\t\t\t\tvec3 getViewNormal(const in vec2 screenPosition) {\n\t\t\t\t\t\t\t\tvec3 normal = texture2D(normalTex, screenPosition).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\t// Convert to view space\n\t\t\t\t\t\t\t\treturn (viewInverseTranspose * vec4(normal, 0.0)).xyz;\n\t\t\t\t\t\t}\n\t\t\t\t#endif\n\n\t\t\t\t#if DEPTHTEX_ENABLED == 1\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\t\t#include <packing>\n\t\t\t#endif\n\t\t\tuniform sampler2D depthTex;\n\t\t\tuniform mat4 projection;\n\t\t\tuniform float depthRange;\n\t\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t\t#if DEPTH_PACKING == 1\n\t\t\t\t\treturn unpackRGBAToDepth( texture2D( depthTex, screenPosition ) );\n\t\t\t\t#else\n\t\t\t\t\treturn texture2D( depthTex, screenPosition ).r;\n\t\t\t\t#endif\n\t\t\t}\n\t\t\tfloat getLinearDepth(vec2 coord) {\n\t\t\t\tfloat depth = getDepth(coord) * 2.0 - 1.0;\n\t\t\t\treturn projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n\t\t\t}\n\t\t#endif\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec2 off = vec2(0.0);\n\t\t\t\t\t\tif (direction == 0) {\n\t\t\t\t\t\t\t\toff[0] = blurSize / textureSize.x;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\toff[1] = blurSize / textureSize.y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec4 sum = vec4(0.0);\n\t\t\t\t\t\tfloat weightAll = 0.0;\n\n\t\t\t\t\t\t#if NORMALTEX_ENABLED == 1\n\t\t\t\t\t\t\t\tvec3 centerNormal = getViewNormal(v_Uv);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if DEPTHTEX_ENABLED == 1\n\t\t\t\t\t\t\t\tfloat centerDepth = getLinearDepth(v_Uv);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tfor (int i = 0; i < KERNEL_SIZE_INT; i++) {\n\t\t\t\tvec2 coord = clamp(v_Uv + vec2(float(i) - (KERNEL_SIZE_FLOAT - 1.) / 2.) * off, vec2(0.0), vec2(1.0));\n\t\t\t\tfloat w = kernel[i];\n\n\t\t\t\t#if NORMALTEX_ENABLED == 1\n\t\t\t\t\tvec3 normal = getViewNormal(coord);\n\t\t\t\t\tw *= clamp(dot(normal, centerNormal), 0.0, 1.0);\n\t\t\t\t#endif\n\t\t\t\t#if DEPTHTEX_ENABLED == 1\n\t\t\t\t\tfloat d = getLinearDepth(coord);\n\t\t\t\t\t\t\t\t// PENDING Better equation?\n\t\t\t\t\t\t\t\t// w *= (1.0 - smoothstep(abs(centerDepth - d) / depthRange, 0.0, 1.0));\n\t\t\t\t\tw *= (1.0 - smoothstep(0.0, 1.0, abs(centerDepth - d) / depthRange));\n\t\t\t\t#endif\n\n\t\t\t\tweightAll += w;\n\t\t\t\tsum += w * texture2D(tDiffuse, coord);\n\t\t\t}\n\n\t\t\tgl_FragColor = sum / weightAll;\n\t\t\t\t}\n\t\t"},d={name:"ec_additive",defines:{},uniforms:{texture1:null,colorWeight1:1,alphaWeight1:1,texture2:null,colorWeight2:1,alphaWeight2:1},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform sampler2D texture1;\n\t\t\t\tuniform float colorWeight1;\n\t\t\t\tuniform float alphaWeight1;\n\n\t\t\t\tuniform sampler2D texture2;\n\t\t\t\tuniform float colorWeight2;\n\t\t\t\tuniform float alphaWeight2;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 texel1 = texture2D(texture1, v_Uv);\n\t\t\t\t\t\tvec4 texel2 = texture2D(texture2, v_Uv);\n\t\t\t\t\t\tvec3 color = texel1.rgb * colorWeight1 + texel2.rgb * colorWeight2;\n\t\t\t\t\t\tfloat alpha = texel1.a * alphaWeight1 + texel2.a * alphaWeight2;\n\t\t\t\t\t\tgl_FragColor = vec4(color, alpha);\n\t\t\t\t}\n\t\t"},c={name:"ec_multiply",defines:{},uniforms:{texture1:null,texture2:null},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform sampler2D texture1;\n\t\t\t\tuniform sampler2D texture2;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 texel1 = texture2D(texture1, v_Uv);\n\t\t\t\t\t\tvec4 texel2 = texture2D(texture2, v_Uv);\n\t\t\t\t\t\tgl_FragColor = texel1 * texel2;\n\t\t\t\t}\n\t\t"},h={name:"ec_copy",defines:{},uniforms:{tDiffuse:null},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform sampler2D tDiffuse;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tgl_FragColor = texture2D(tDiffuse, v_Uv);\n\t\t\t\t}\n\t\t"},_={name:"ec_channel",defines:{},uniforms:{tDiffuse:null,channelMask:[1,0,0,0]},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec4 channelMask;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\tfloat value = dot(texture2D(tDiffuse, v_Uv), channelMask);\n\t\t\t\t\t\tgl_FragColor = vec4(vec3(value), 1.0);\n\t\t\t\t}\n\t\t"},m={name:"ec_mask",defines:{},uniforms:{colorTexture:null,maskTexture:null,additiveTexture:null,channel:[1,0,0,0]},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform sampler2D colorTexture;\n\t\tuniform sampler2D maskTexture;\n\n\t\tuniform sampler2D additiveTexture;\n\n\t\tuniform vec4 channel;\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\tvec4 colorTex = texture2D(colorTexture, v_Uv);\n\t\t\tvec4 maskTex = texture2D(maskTexture, v_Uv);\n\t\t\tvec4 addTex = texture2D(additiveTexture, v_Uv);\n\t\t\t\t\t\tgl_FragColor = colorTex * dot(maskTex, channel) + addTex;\n\t\t\t\t}\n\t\t"},p={name:"ec_highlight",defines:{},uniforms:{tDiffuse:null,threshold:1,smoothWidth:.01},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform float threshold;\n\t\tuniform float smoothWidth;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 texel = texture2D(tDiffuse, v_Uv);\n\t\t\t\t\t\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\t\t\t\t\t\tfloat v = dot(texel.xyz, luma);\n\t\t\t\t\t\tgl_FragColor = smoothstep(threshold, threshold + smoothWidth, v) * texel;\n\t\t\t\t}\n\t\t"},x={name:"ec_seperable_blur",defines:{MAX_RADIUS:4},uniforms:{tDiffuse:null,texSize:[.5,.5],direction:[.5,.5],kernelRadius:1},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\treturn 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\tvec4 diffuseColor = texture2D(tDiffuse, v_Uv);\n\t\t\tvec4 diffuseSum = diffuseColor * weightSum;\n\t\t\tvec2 delta = direction * invSize * kernelRadius / float(MAX_RADIUS);\n\t\t\tvec2 uvOffset = delta;\n\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\tvec4 sample1 = texture2D(tDiffuse, v_Uv + uvOffset);\n\t\t\t\tvec4 sample2 = texture2D(tDiffuse, v_Uv - uvOffset);\n\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\tuvOffset += delta;\n\t\t\t}\n\t\t\tvec4 color = diffuseSum / weightSum;\n\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"},A={name:"ec_h_blur",uniforms:{tDiffuse:null,h:1/512},vertexShader:f,fragmentShader:"\n\t\tuniform float h;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 sum = vec4(0.0);\n\t\t\t\t\t \n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * h, v_Uv.y)) * 0.051;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * h, v_Uv.y)) * 0.0918;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * h, v_Uv.y)) * 0.12245;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * h, v_Uv.y)) * 0.1531;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)) * 0.1633;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x + 1.0 * h, v_Uv.y)) * 0.1531;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * h, v_Uv.y)) * 0.12245;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * h, v_Uv.y)) * 0.0918;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * h, v_Uv.y)) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\t\t\t\t}\n\t\t"},T={name:"ec_v_blur",uniforms:{tDiffuse:null,v:1/512},vertexShader:f,fragmentShader:"\n\t\tuniform float v;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 sum = vec4(0.0);\n\t\t\t\t\t \n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y - 4.0 * v)) * 0.051;\n\t\t\t\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y - 3.0 * v)) * 0.0918;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y - 2.0 * v)) * 0.12245;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y - 1.0 * v)) * 0.1531;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)) * 0.1633;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y + 1.0 * v)) * 0.1531;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y + 2.0 * v)) * 0.12245;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y + 3.0 * v)) * 0.0918;\n\t\t\tsum += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y + 4.0 * v)) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\t\t\t\t}\n\t\t"};function v(t){return t.format===e.PIXEL_FORMAT.DEPTH_STENCIL||t.format===e.PIXEL_FORMAT.DEPTH24_STENCIL8}var P={OPAQUE:1,TRANSPARENT:2,ALL:15},g=function(t){function n(){var n;return(n=t.call(this)||this).threshold=.7,n.smoothWidth=.01,n.blurSize=2,n.strength=1,n._highlightPass=new e.ShaderPostPass(p),n._blurPass=new e.ShaderPostPass(u),n._blendPass=new e.ShaderPostPass(d),n._blendPass.material.premultipliedAlpha=!0,n}a(n,t);var r=n.prototype;return r.resize=function(t,e){this._blurPass.uniforms.textureSize[0]=t,this._blurPass.uniforms.textureSize[1]=e},r.render=function(t,e,n,r,a){var s=e._renderTargetCache.allocate(0),i=e._renderTargetCache.allocate(1),o=e._renderTargetCache.allocate(1);t.renderPass.setRenderTarget(s),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._highlightPass.uniforms.tDiffuse=n.texture,this._highlightPass.uniforms.threshold=this.threshold,this._highlightPass.uniforms.smoothWidth=this.smoothWidth,this._highlightPass.render(t),t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=s.texture,this._blurPass.uniforms.direction=0,this._blurPass.uniforms.blurSize=this.blurSize,this._blurPass.render(t),t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=i.texture,this._blurPass.uniforms.direction=1,this._blurPass.uniforms.blurSize=this.blurSize,this._blurPass.render(t),t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,0),a?t.renderPass.clear(e.clearColor,e.clearDepth,e.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=n.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=this.strength,this._blendPass.uniforms.alphaWeight2=this.strength,a&&(this._blendPass.material.transparent=e._tempClearColor[3]<1||!e.clearColor,this._blendPass.renderStates.camera.rect.fromArray(e._tempViewport)),this._blendPass.render(t),a&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),e._renderTargetCache.release(s,0),e._renderTargetCache.release(i,1),e._renderTargetCache.release(o,1)},n}(l),E=function(t){function n(){var n;return(n=t.call(this)||this).chromaFactor=.025,n._mainPass=new e.ShaderPostPass(F),n._mainPass.material.premultipliedAlpha=!0,n}a(n,t);var r=n.prototype;return r.resize=function(t,e){this._mainPass.uniforms.resolution[0]=1/t,this._mainPass.uniforms.resolution[1]=1/e},r.render=function(t,e,n,r,a){t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,0),a?t.renderPass.clear(e.clearColor,e.clearDepth,e.clearStencil):t.renderPass.clear(!0,!0,!1);var s=this._mainPass;s.uniforms.tDiffuse=n.texture,s.uniforms.uChromaFactor=this.chromaFactor,a&&(s.material.transparent=e._tempClearColor[3]<1||!e.clearColor,s.renderStates.camera.rect.fromArray(e._tempViewport)),s.render(t),a&&(s.material.transparent=!1,s.renderStates.camera.rect.set(0,0,1,1))},n}(l),F={name:"ec_chromatic_aberration",defines:{},uniforms:{tDiffuse:null,uChromaFactor:.025,uResolutionRatio:[1,1],resolution:[1/1024,1/512]},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform float uChromaFactor;\n\t\t\t\tuniform vec2 uResolutionRatio;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec2 uv = v_Uv;\n\t\t\t\t\t\tvec2 dist = uv - 0.5;\n\t\t\t\t\t\tvec2 offset = uChromaFactor * dist * length(dist);\n\t\t\t\t\t\tvec4 col = texture2D(tDiffuse, min(uv, 1.0 - resolution) * uResolutionRatio);\n\t\t\t\t\t\tcol.r = texture2D(tDiffuse, min(uv - offset, 1.0 - resolution) * uResolutionRatio).r;\n\t\t\t\t\t\tcol.b = texture2D(tDiffuse, min(uv + offset, 1.0 - resolution) * uResolutionRatio).b;\n\t\t\t\t\t\tgl_FragColor = col;\n\t\t\t\t}\n\t\t"},S=function(t){function n(){var n;return(n=t.call(this)||this).brightness=0,n.contrast=1.02,n.exposure=0,n.gamma=1,n.saturation=1.02,n._mainPass=new e.ShaderPostPass(b),n._mainPass.material.premultipliedAlpha=!0,n._mainPass.uniforms.contrast=1.02,n._mainPass.uniforms.saturation=1.02,n}return a(n,t),n.prototype.render=function(t,e,n,r,a){t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,0),a?t.renderPass.clear(e.clearColor,e.clearDepth,e.clearStencil):t.renderPass.clear(!0,!0,!1);var s=this._mainPass;s.uniforms.tDiffuse=n.texture,s.uniforms.brightness=this.brightness,s.uniforms.contrast=this.contrast,s.uniforms.exposure=this.exposure,s.uniforms.gamma=this.gamma,s.uniforms.saturation=this.saturation,a&&(s.material.transparent=e._tempClearColor[3]<1||!e.clearColor,s.renderStates.camera.rect.fromArray(e._tempViewport)),s.render(t),a&&(s.material.transparent=!1,s.renderStates.camera.rect.set(0,0,1,1))},n}(l),b={name:"ec_color_correction",defines:{},uniforms:{tDiffuse:null,brightness:0,contrast:1,exposure:0,gamma:1,saturation:1},vertexShader:f,fragmentShader:'\n\t\t\t\tuniform float brightness;\n\t\t\t\tuniform float contrast;\n\t\t\t\tuniform float exposure;\n\t\t\t\tuniform float gamma;\n\t\t\t\tuniform float saturation;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\t// Values from "Graphics Shaders: Theory and Practice" by Bailey and Cunningham\n\t\t\t\tconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 tex = texture2D(tDiffuse, v_Uv);\n\t\t\t\t\t\t// brightness\n\t\t\t\t\t\tvec3 color = clamp(tex.rgb + vec3(brightness), 0.0, 1.0);\n\t\t\t\t\t\t// contrast\n\t\t\t\t\t\tcolor = clamp((color - vec3(0.5)) * contrast + vec3(0.5), 0.0, 1.0);\n\t\t\t\t\t\t// exposure\n\t\t\t\t\t\tcolor = clamp(color * pow(2.0, exposure), 0.0, 1.0);\n\t\t\t\t\t\t// gamma\n\t\t\t\t\t\tcolor = clamp(pow(color, vec3(gamma)), 0.0, 1.0);\n\t\t\t\t\t\tfloat luminance = dot(color, w);\n\t\t\t\t\t\tcolor = mix(vec3(luminance), color, saturation);\n\t\t\t\t\t\tgl_FragColor = vec4(color, tex.a);\n\t\t\t\t}\n\t\t'},N=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"GBuffer"}],n.focalDepth=1,n.focalLength=24,n.fstop=.9,n.maxblur=1,n.threshold=.9,n.gain=1,n.bias=.5,n.dithering=1e-4,n._mainPass=new e.ShaderPostPass(y),n._mainPass.material.premultipliedAlpha=!0,n}a(n,t);var r=n.prototype;return r.resize=function(t,e){this._mainPass.uniforms.resolution[0]=1/t,this._mainPass.uniforms.resolution[1]=1/e},r.render=function(t,n,r,a,s){t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1);var i=n.getBuffer("GBuffer"),o=i.getCurrentRenderStates();this._mainPass.uniforms.tColor=r.texture,this._mainPass.uniforms.tDepth=i.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT];var l=0,f=0,u=o.camera.projectionMatrix;-1===u.elements[11]?(l=u.elements[14]/(u.elements[10]-1),f=u.elements[14]/(u.elements[10]+1)):(l=(u.elements[14]+1)/u.elements[10],f=(u.elements[14]-1)/u.elements[10]),this._mainPass.uniforms.znear=l,this._mainPass.uniforms.zfar=f,this._mainPass.uniforms.focalDepth=this.focalDepth,this._mainPass.uniforms.focalLength=this.focalLength,this._mainPass.uniforms.fstop=this.fstop,this._mainPass.uniforms.maxblur=this.maxblur,this._mainPass.uniforms.threshold=this.threshold,this._mainPass.uniforms.gain=this.gain,this._mainPass.uniforms.bias=this.bias,this._mainPass.uniforms.dithering=this.dithering,s&&(this._mainPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._mainPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._mainPass.render(t),s&&(this._mainPass.material.transparent=!1,this._mainPass.renderStates.camera.rect.set(0,0,1,1))},n}(l);var y={name:"ec_bokeh",defines:{RINGS:3,SAMPLES:4},uniforms:{tColor:null,tDepth:null,resolution:[1/1024,1/512],znear:.1,zfar:100,focalDepth:1,focalLength:24,fstop:.9,maxblur:1,threshold:.5,gain:2,bias:.5,dithering:1e-4},vertexShader:f,fragmentShader:"\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tuniform sampler2D tColor;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\t\n\t\t\t\tuniform vec2 resolution;\t\n\t\t\t\t\n\t\t\t\tuniform float znear;\n\t\t\t\tuniform float zfar;\n\n\t\t\t\tuniform float focalDepth;\n\t\t\t\tuniform float focalLength;\n\t\t\t\tuniform float fstop;\n\n\t\t\t\tuniform float maxblur; // clamp value of max blur (0.0 = no blur, 1.0 default)\n\t\t\t\tuniform float threshold; // highlight threshold\n\t\t\t\tuniform float gain; // highlight gain\n\t\t\t\tuniform float bias; // bokeh edge bias\n\t\t\t\tuniform float dithering;\n\n\t\t\t\tconst int samples = SAMPLES;\n\t\t\t\tconst int rings = RINGS;\n\t\t\t\tconst int maxringsamples = rings * samples;\n\n\t\t\t\tfloat CoC = 0.03; // circle of confusion size in mm (35mm film = 0.03mm)\n\n\t\t\t\tvec4 color(vec2 coords, float blur) {\n\t\t\t\t\t\tvec4 col = texture2D(tColor, coords);\n\t\t\t\t\t\tvec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n\t\t\t\t\t\tfloat lum = dot(col.rgb, lumcoeff);\n\t\t\t\t\t\tfloat thresh = max((lum - threshold) * gain, 0.0);\n\t\t\t\t\t\treturn vec4(col.rgb + mix(vec3(0.0), col.rgb, thresh * blur), col.a);\n\t\t\t\t}\n\n\t\t\t\tfloat linearize(float depth) {\n\t\t\t\t\t\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\n\t\t\t\t}\n\n\t\t\t\tfloat gather(float i, float j, int ringsamples, inout vec3 colorSum, float w, float h, float blur) {\n\t\t\t\t\t\tfloat rings2 = float(rings);\n\t\t\t\t\t\tfloat step = PI * 2.0 / float(ringsamples);\n\t\t\t\t\t\tfloat pw = cos(j * step) * i;\n\t\t\t\t\t\tfloat ph = sin(j * step) * i;\n\t\t\tvec4 sampleColor = color(v_Uv + vec2(pw * w, ph * h), blur);\n\t\t\tfloat weight = mix(1.0, i / rings2, bias) * sampleColor.a;\n\t\t\t\t\t\tcolorSum += sampleColor.rgb\t* weight;\n\t\t\t\t\t\treturn weight;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tfloat depth = linearize(texture2D(tDepth,\tv_Uv).x);\n\t\t\t\t\t\tfloat fDepth = focalDepth;\n\n\t\t\t\t\t\t// dof blur factor calculation\n\n\t\t\t\t\t\tfloat f = focalLength; // focal length in mm\n\t\t\t\t\t\tfloat d = fDepth * 1000.; // focal plane in mm\n\t\t\t\t\t\tfloat o = depth * 1000.; // depth in mm\n\n\t\t\t\t\t\tfloat a = (o * f) / (o - f);\n\t\t\t\t\t\tfloat b = (d * f) / (d - f);\n\t\t\t\t\t\tfloat c = (d - f) / (d * fstop * CoC);\n\n\t\t\t\t\t\tfloat blur = abs(a - b) * c;\n\t\t\t\t\t\tblur = clamp(blur, 0.0, 1.0);\n\n\t\t\t\t\t\t// calculation of pattern for dithering\n\n\t\t\t\t\t\tvec2 noise = vec2(rand( v_Uv), rand( v_Uv + vec2(0.4, 0.6))) * dithering * blur;\n\n\t\t\t\t\t\t// getting blur x and y step factor\n\n\t\t\t\t\t\tfloat w = resolution.x * blur * maxblur + noise.x;\n\t\t\t\t\t\tfloat h = resolution.y * blur * maxblur + noise.y;\n\n\t\t\t\t\t\t// calculation of final color\n\n\t\t\t\t\t\tvec3 col = vec3(0.0);\n\t\t\tvec4 centerColor = texture2D(tColor,\tv_Uv);\n\n\t\t\t\t\t\tif (blur < 0.05) {\n\t\t\t\t\t\t\t\tcol = centerColor.rgb;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcol = centerColor.rgb;\n\n\t\t\t\t\t\t\t\tfloat s = 1.0;\n\t\t\t\t\t\t\t\tint ringsamples;\n\n\t\t\t\t\t\t\t\tfor(int i = 1; i <= rings; i++) {\n\t\t\t\t\t\t\t\t\t\tringsamples = i * samples;\n\n\t\t\t\t\t\t\t\t\t\tfor (int j = 0; j < maxringsamples; j++) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (j >= ringsamples) break;\n\t\t\t\t\t\t\t\t\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcol /= s; // divide by sample count\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl_FragColor = vec4(col, centerColor.a);\n\t\t\t\t}\n\t\t"},C=function(t){function n(){var n;return(n=t.call(this)||this).noiseIntensity=.35,n.scanlinesIntensity=.5,n.scanlinesCount=2048,n.grayscale=!0,n._time=0,n._mainPass=new e.ShaderPostPass(L),n._mainPass.material.premultipliedAlpha=!0,n}return a(n,t),n.prototype.render=function(t,e,n,r,a){t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,0),a?t.renderPass.clear(e.clearColor,e.clearDepth,e.clearStencil):t.renderPass.clear(!0,!0,!1);var s=this._mainPass;s.uniforms.tDiffuse=n.texture,s.uniforms.nIntensity=this.noiseIntensity,s.uniforms.sIntensity=this.scanlinesIntensity,s.uniforms.sCount=this.scanlinesCount,s.uniforms.grayscale=this.grayscale,this._time+=.01667,s.uniforms.time=this._time,a&&(s.material.transparent=e._tempClearColor[3]<1||!e.clearColor,s.renderStates.camera.rect.fromArray(e._tempViewport)),s.render(t),a&&(s.material.transparent=!1,s.renderStates.camera.rect.set(0,0,1,1))},n}(l),L={name:"ec_film",defines:{},uniforms:{tDiffuse:null,time:0,nIntensity:.5,sIntensity:.05,sCount:4096,grayscale:!0},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float nIntensity;\n\t\t\t\tuniform float sIntensity;\n\t\t\t\tuniform float sCount;\n\t\t\t\tuniform bool grayscale;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\t// sample the source\n\t\t\t\t\t\tvec4 cTextureScreen = texture2D(tDiffuse, v_Uv);\n\t\t\t\t\t\t// make some noise\n\t\t\t\t\t\tfloat dx = rand(v_Uv + time);\n\t\t\t\t\t\t// add noise\n\t\t\t\t\t\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp(0.1 + dx, 0.0, 1.0);\n\t\t\t\t\t\t// get us a sine and cosine\n\t\t\t\t\t\tvec2 sc = vec2(sin(v_Uv.y * sCount), cos(v_Uv.y * sCount));\n\t\t\t\t\t\t// add scanlines\n\t\t\t\t\t\tcResult += cTextureScreen.rgb * vec3(sc.x, sc.y, sc.x) * sIntensity;\n\t\t\t\t\t\t// interpolate between source and result by intensity\n\t\t\t\t\t\tcResult = cTextureScreen.rgb + clamp(nIntensity, 0.0, 1.0) * (cResult - cTextureScreen.rgb);\n\t\t\t\t\t\t// convert to grayscale if desired\n\t\t\t\t\t\tif(grayscale) {\n\t\t\t\t\t\t\t\tcResult = vec3(cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgl_FragColor = vec4(cResult, cTextureScreen.a);\n\t\t\t\t}\n\t\t"},I=function(t){function n(){var n;return(n=t.call(this)||this)._mainPass=new e.ShaderPostPass(D),n._mainPass.material.premultipliedAlpha=!0,n}a(n,t);var r=n.prototype;return r.resize=function(t,e){this._mainPass.uniforms.resolution[0]=1/t,this._mainPass.uniforms.resolution[1]=1/e},r.render=function(t,e,n,r,a){t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,0),a?t.renderPass.clear(e.clearColor,e.clearDepth,e.clearStencil):t.renderPass.clear(!0,!0,!1),this._mainPass.uniforms.tDiffuse=n.texture,a&&(this._mainPass.material.transparent=e._tempClearColor[3]<1||!e.clearColor,this._mainPass.renderStates.camera.rect.fromArray(e._tempViewport)),this._mainPass.render(t),a&&(this._mainPass.material.transparent=!1,this._mainPass.renderStates.camera.rect.set(0,0,1,1))},n}(l),D={name:"ec_fxaa",defines:{},uniforms:{tDiffuse:null,resolution:[1/1024,1/512]},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\t\t\t\t\n\t\t\t\tuniform vec2 resolution;\t\n\t\t\t\t\n\t\t\t\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\t\t\t\t\n\t\t\t\t//----------------------------------------------------------------------------------\n\t\t\t\t// File:\t\t\t\tes3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n\t\t\t\t// SDK Version: v3.00\n\t\t\t\t// Email:\t\t\t gameworks@nvidia.com\n\t\t\t\t// Site:\t\t\t\thttp://developer.nvidia.com/\n\t\t\t\t//\n\t\t\t\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t\t\t\t//\n\t\t\t\t// Redistribution and use in source and binary forms, with or without\n\t\t\t\t// modification, are permitted provided that the following conditions\n\t\t\t\t// are met:\n\t\t\t\t//\t* Redistributions of source code must retain the above copyright\n\t\t\t\t//\t\tnotice, this list of conditions and the following disclaimer.\n\t\t\t\t//\t* Redistributions in binary form must reproduce the above copyright\n\t\t\t\t//\t\tnotice, this list of conditions and the following disclaimer in the\n\t\t\t\t//\t\tdocumentation and/or other materials provided with the distribution.\n\t\t\t\t//\t* Neither the name of NVIDIA CORPORATION nor the names of its\n\t\t\t\t//\t\tcontributors may be used to endorse or promote products derived\n\t\t\t\t//\t\tfrom this software without specific prior written permission.\n\t\t\t\t//\n\t\t\t\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS \"AS IS\" AND ANY\n\t\t\t\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t\t\t\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t\t\t\t// PURPOSE ARE DISCLAIMED.\tIN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t\t\t\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t\t\t\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t\t\t\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t\t\t\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t\t\t\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t\t\t\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t\t\t\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t\t\t\t//\n\t\t\t\t//----------------------------------------------------------------------------------\n\t\t\t\t\n\t\t\t\t#define FXAA_PC 1\n\t\t\t\t#define FXAA_GLSL_100 1\n\t\t\t\t#define FXAA_QUALITY_PRESET 39\n\t\t\t\t\n\t\t\t\t#define FXAA_GREEN_AS_LUMA 1\n\t\t\t\t\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_PC_CONSOLE\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// The console algorithm for PC is included\n\t\t\t\t\t\t// for developers targeting really low spec machines.\n\t\t\t\t\t\t// Likely better to just run FXAA_PC, and use a really low preset.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_PC_CONSOLE 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_GLSL_120\n\t\t\t\t\t\t#define FXAA_GLSL_120 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_GLSL_130\n\t\t\t\t\t\t#define FXAA_GLSL_130 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_HLSL_3\n\t\t\t\t\t\t#define FXAA_HLSL_3 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_HLSL_4\n\t\t\t\t\t\t#define FXAA_HLSL_4 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_HLSL_5\n\t\t\t\t\t\t#define FXAA_HLSL_5 0\n\t\t\t\t#endif\n\t\t\t\t/*==========================================================================*/\n\t\t\t\t#ifndef FXAA_GREEN_AS_LUMA\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// For those using non-linear color,\n\t\t\t\t\t\t// and either not able to get luma in alpha, or not wanting to,\n\t\t\t\t\t\t// this enables FXAA to run using green as a proxy for luma.\n\t\t\t\t\t\t// So with this enabled, no need to pack luma in alpha.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// This will turn off AA on anything which lacks some amount of green.\n\t\t\t\t\t\t// Pure red and blue or combination of only R and B, will get no AA.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Might want to lower the settings for both,\n\t\t\t\t\t\t//\t\tfxaaConsoleEdgeThresholdMin\n\t\t\t\t\t\t//\t\tfxaaQualityEdgeThresholdMin\n\t\t\t\t\t\t// In order to insure AA does not get turned off on colors\n\t\t\t\t\t\t// which contain a minor amount of green.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = On.\n\t\t\t\t\t\t// 0 = Off.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_GREEN_AS_LUMA 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_EARLY_EXIT\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Controls algorithm's early exit path.\n\t\t\t\t\t\t// On PS3 turning this ON adds 2 cycles to the shader.\n\t\t\t\t\t\t// On 360 turning this OFF adds 10ths of a millisecond to the shader.\n\t\t\t\t\t\t// Turning this off on console will result in a more blurry image.\n\t\t\t\t\t\t// So this defaults to on.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = On.\n\t\t\t\t\t\t// 0 = Off.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_EARLY_EXIT 1\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_DISCARD\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t\t\t\t//\t\t For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_DISCARD 0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Used for GLSL 120 only.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = GL API supports fast pixel offsets\n\t\t\t\t\t\t// 0 = do not use fast pixel offsets\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#ifdef GL_EXT_gpu_shader4\n\t\t\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 0\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// 1 = API supports gather4 on alpha channel.\n\t\t\t\t\t\t// 0 = API does not support gather4 on alpha channel.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 0\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - TUNING KNOBS\n\t\t\t\t------------------------------------------------------------------------------\n\t\t\t\tNOTE the other tuning knobs are now in the shader function inputs!\n\t\t\t\t============================================================================*/\n\t\t\t\t#ifndef FXAA_QUALITY_PRESET\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Choose the quality preset.\n\t\t\t\t\t\t// This needs to be compiled into the shader as it effects code.\n\t\t\t\t\t\t// Best option to include multiple presets is to\n\t\t\t\t\t\t// in each shader define the preset, then include this file.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// OPTIONS\n\t\t\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t\t\t// 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n\t\t\t\t\t\t// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n\t\t\t\t\t\t// 39\t\t\t - no dither, very expensive\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// NOTES\n\t\t\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t\t\t// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n\t\t\t\t\t\t// 13 = about same speed as FXAA 3.9 and better than 12\n\t\t\t\t\t\t// 23 = closest to FXAA 3.9 visually and performance wise\n\t\t\t\t\t\t//\t_ = the lowest digit is directly related to performance\n\t\t\t\t\t\t// _\t= the highest digit is directly related to style\n\t\t\t\t\t\t//\n\t\t\t\t\t\t#define FXAA_QUALITY_PRESET 12\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - PRESETS\n\t\t\t\t\n\t\t\t\t============================================================================*/\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - MEDIUM DITHER PRESETS\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 10)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 3.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 11)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 3.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 12)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 13)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 14)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 12.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 15)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 12.0\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - LOW DITHER PRESETS\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 20)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 21)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 22)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 23)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 24)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 3.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 25)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 26)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 9\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 27)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 10\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P9 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 28)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 11\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P9 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P10 8.0\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 29)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - EXTREME QUALITY\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_QUALITY_PRESET == 39)\n\t\t\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P1 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P2 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P3 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P4 1.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P5 1.5\n\t\t\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAPI PORTING\n\t\t\t\t\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n\t\t\t\t\t\t#define FxaaBool bool\n\t\t\t\t\t\t#define FxaaDiscard discard\n\t\t\t\t\t\t#define FxaaFloat float\n\t\t\t\t\t\t#define FxaaFloat2 vec2\n\t\t\t\t\t\t#define FxaaFloat3 vec3\n\t\t\t\t\t\t#define FxaaFloat4 vec4\n\t\t\t\t\t\t#define FxaaHalf float\n\t\t\t\t\t\t#define FxaaHalf2 vec2\n\t\t\t\t\t\t#define FxaaHalf3 vec3\n\t\t\t\t\t\t#define FxaaHalf4 vec4\n\t\t\t\t\t\t#define FxaaInt2 ivec2\n\t\t\t\t\t\t#define FxaaSat(x) clamp(x, 0.0, 1.0)\n\t\t\t\t\t\t#define FxaaTex sampler2D\n\t\t\t\t#else\n\t\t\t\t\t\t#define FxaaBool bool\n\t\t\t\t\t\t#define FxaaDiscard clip(-1)\n\t\t\t\t\t\t#define FxaaFloat float\n\t\t\t\t\t\t#define FxaaFloat2 float2\n\t\t\t\t\t\t#define FxaaFloat3 float3\n\t\t\t\t\t\t#define FxaaFloat4 float4\n\t\t\t\t\t\t#define FxaaHalf half\n\t\t\t\t\t\t#define FxaaHalf2 half2\n\t\t\t\t\t\t#define FxaaHalf3 half3\n\t\t\t\t\t\t#define FxaaHalf4 half4\n\t\t\t\t\t\t#define FxaaSat(x) saturate(x)\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t#define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_GLSL_120 == 1)\n\t\t\t\t\t\t// Requires,\n\t\t\t\t\t\t//\t#version 120\n\t\t\t\t\t\t// And at least,\n\t\t\t\t\t\t//\t#extension GL_EXT_gpu_shader4 : enable\n\t\t\t\t\t\t//\t(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n\t\t\t\t\t\t#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n\t\t\t\t\t\t#if (FXAA_FAST_PIXEL_OFFSET == 1)\n\t\t\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_GLSL_130 == 1)\n\t\t\t\t\t\t// Requires '#version 130' or better\n\t\t\t\t\t\t#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n\t\t\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_HLSL_3 == 1)\n\t\t\t\t\t\t#define FxaaInt2 float2\n\t\t\t\t\t\t#define FxaaTex sampler2D\n\t\t\t\t\t\t#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_HLSL_4 == 1)\n\t\t\t\t\t\t#define FxaaInt2 int2\n\t\t\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t\t\t#define FxaaInt2 int2\n\t\t\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n\t\t\t\t\t\t#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\tGREEN AS LUMA OPTION SUPPORT FUNCTION\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n\t\t\t\t#else\n\t\t\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t/*============================================================================\n\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\t\t\t\t\n\t\t\t\t============================================================================*/\n\t\t\t\t#if (FXAA_PC == 1)\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat4 FxaaPixelShader(\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t\t\t// {xy} = center of pixel\n\t\t\t\t\t\tFxaaFloat2 pos,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Used only for FXAA Console, and not used on the 360 version.\n\t\t\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t\t\t// {xy_} = upper left of pixel\n\t\t\t\t\t\t// {_zw} = lower right of pixel\n\t\t\t\t\t\tFxaaFloat4 fxaaConsolePosPos,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Input color texture.\n\t\t\t\t\t\t// {rgb_} = color in linear or perceptual color space\n\t\t\t\t\t\t// if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t//\t\t {__a} = luma in perceptual color space (not linear)\n\t\t\t\t\t\tFxaaTex tex,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t\t\t// For everything but 360, just use the same input here as for 'tex'.\n\t\t\t\t\t\t// For 360, same diffuseMap, just alias with a 2nd sampler.\n\t\t\t\t\t\t// This sampler needs to have an exponent bias of -1.\n\t\t\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t\t\t// For everything but 360, just use the same input here as for 'tex'.\n\t\t\t\t\t\t// For 360, same diffuseMap, just alias with a 3nd sampler.\n\t\t\t\t\t\t// This sampler needs to have an exponent bias of -2.\n\t\t\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t\t\t// {x_} = 1.0/screenWidthInPixels\n\t\t\t\t\t\t// {_y} = 1.0/screenHeightInPixels\n\t\t\t\t\t\tFxaaFloat2 fxaaQualityRcpFrame,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t\t\t// This effects sub-pixel AA quality and inversely sharpness.\n\t\t\t\t\t\t//\t Where N ranges between,\n\t\t\t\t\t\t//\t\t N = 0.50 (default)\n\t\t\t\t\t\t//\t\t N = 0.33 (sharper)\n\t\t\t\t\t\t// {x__} = -N/screenWidthInPixels\n\t\t\t\t\t\t// {_y_} = -N/screenHeightInPixels\n\t\t\t\t\t\t// {_z_} =\tN/screenWidthInPixels\n\t\t\t\t\t\t// {__w} =\tN/screenHeightInPixels\n\t\t\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// Not used on 360, but used on PS3 and PC.\n\t\t\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t\t\t// {x__} = -2.0/screenWidthInPixels\n\t\t\t\t\t\t// {_y_} = -2.0/screenHeightInPixels\n\t\t\t\t\t\t// {_z_} =\t2.0/screenWidthInPixels\n\t\t\t\t\t\t// {__w} =\t2.0/screenHeightInPixels\n\t\t\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n\t\t\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t\t\t// {x__} =\t8.0/screenWidthInPixels\n\t\t\t\t\t\t// {_y_} =\t8.0/screenHeightInPixels\n\t\t\t\t\t\t// {_z_} = -4.0/screenWidthInPixels\n\t\t\t\t\t\t// {__w} = -4.0/screenHeightInPixels\n\t\t\t\t\t\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t\t\t// This used to be the FXAA_QUALITY_SUBPIX define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// Choose the amount of sub-pixel aliasing removal.\n\t\t\t\t\t\t// This can effect sharpness.\n\t\t\t\t\t\t//\t 1.00 - upper limit (softer)\n\t\t\t\t\t\t//\t 0.75 - default amount of filtering\n\t\t\t\t\t\t//\t 0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n\t\t\t\t\t\t//\t 0.25 - almost off\n\t\t\t\t\t\t//\t 0.00 - completely off\n\t\t\t\t\t\tFxaaFloat fxaaQualitySubpix,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// The minimum amount of local contrast required to apply algorithm.\n\t\t\t\t\t\t//\t 0.333 - too little (faster)\n\t\t\t\t\t\t//\t 0.250 - low quality\n\t\t\t\t\t\t//\t 0.166 - default\n\t\t\t\t\t\t//\t 0.125 - high quality\n\t\t\t\t\t\t//\t 0.063 - overkill (slower)\n\t\t\t\t\t\tFxaaFloat fxaaQualityEdgeThreshold,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t\t\t//\t 0.0833 - upper limit (default, the start of visible unfiltered edges)\n\t\t\t\t\t\t//\t 0.0625 - high quality (faster)\n\t\t\t\t\t\t//\t 0.0312 - visible limit (slower)\n\t\t\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\t\t\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n\t\t\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t\t\t//\t there are only three safe values here: 2 and 4 and 8.\n\t\t\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t\t\t// For all other platforms can be a non-power of two.\n\t\t\t\t\t\t//\t 8.0 is sharper (default!!!)\n\t\t\t\t\t\t//\t 4.0 is softer\n\t\t\t\t\t\t//\t 2.0 is really soft (good only for vector graphics inputs)\n\t\t\t\t\t\tFxaaFloat fxaaConsoleEdgeSharpness,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n\t\t\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t\t\t//\t there are only two safe values here: 1/4 and 1/8.\n\t\t\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t\t\t// Other platforms can use other values.\n\t\t\t\t\t\t//\t 0.125 leaves less aliasing, but is softer (default!!!)\n\t\t\t\t\t\t//\t 0.25 leaves more aliasing, and is sharper\n\t\t\t\t\t\tFxaaFloat fxaaConsoleEdgeThreshold,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n\t\t\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t\t\t// This only applies when FXAA_EARLY_EXIT is 1.\n\t\t\t\t\t\t// This does not apply to PS3,\n\t\t\t\t\t\t// PS3 was simplified to avoid more shader instructions.\n\t\t\t\t\t\t//\t 0.06 - faster but more aliasing in darks\n\t\t\t\t\t\t//\t 0.05 - default\n\t\t\t\t\t\t//\t 0.04 - slower and less aliasing in darks\n\t\t\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\t\t\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Extra constants for 360 FXAA Console only.\n\t\t\t\t\t\t// Use zeros or anything else for other platforms.\n\t\t\t\t\t\t// These must be in physical constant registers and NOT immedates.\n\t\t\t\t\t\t// Immedates will result in compiler un-optimizing.\n\t\t\t\t\t\t// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n\t\t\t\t\t\tFxaaFloat4 fxaaConsole360ConstDir\n\t\t\t\t) {\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat2 posM;\n\t\t\t\t\t\tposM.x = pos.x;\n\t\t\t\t\t\tposM.y = pos.y;\n\t\t\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t\t\t#if (FXAA_DISCARD == 0)\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n\t\t\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\t\t\t#define lumaM luma4A.w\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#define lumaE luma4A.z\n\t\t\t\t\t\t\t\t#define lumaS luma4A.x\n\t\t\t\t\t\t\t\t#define lumaSE luma4A.y\n\t\t\t\t\t\t\t\t#define lumaNW luma4B.w\n\t\t\t\t\t\t\t\t#define lumaN luma4B.z\n\t\t\t\t\t\t\t\t#define lumaW luma4B.x\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat maxSM = max(lumaS, lumaM);\n\t\t\t\t\t\tFxaaFloat minSM = min(lumaS, lumaM);\n\t\t\t\t\t\tFxaaFloat maxESM = max(lumaE, maxSM);\n\t\t\t\t\t\tFxaaFloat minESM = min(lumaE, minSM);\n\t\t\t\t\t\tFxaaFloat maxWN = max(lumaN, lumaW);\n\t\t\t\t\t\tFxaaFloat minWN = min(lumaN, lumaW);\n\t\t\t\t\t\tFxaaFloat rangeMax = max(maxWN, maxESM);\n\t\t\t\t\t\tFxaaFloat rangeMin = min(minWN, minESM);\n\t\t\t\t\t\tFxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n\t\t\t\t\t\tFxaaFloat range = rangeMax - rangeMin;\n\t\t\t\t\t\tFxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n\t\t\t\t\t\tFxaaBool earlyExit = range < rangeMaxClamped;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tif(earlyExit)\n\t\t\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\t\t\tFxaaDiscard;\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\treturn rgbyM;\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_GATHER4_ALPHA == 0)\n\t\t\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat lumaNS = lumaN + lumaS;\n\t\t\t\t\t\tFxaaFloat lumaWE = lumaW + lumaE;\n\t\t\t\t\t\tFxaaFloat subpixRcpRange = 1.0/range;\n\t\t\t\t\t\tFxaaFloat subpixNSWE = lumaNS + lumaWE;\n\t\t\t\t\t\tFxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n\t\t\t\t\t\tFxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat lumaNESE = lumaNE + lumaSE;\n\t\t\t\t\t\tFxaaFloat lumaNWNE = lumaNW + lumaNE;\n\t\t\t\t\t\tFxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n\t\t\t\t\t\tFxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat lumaNWSW = lumaNW + lumaSW;\n\t\t\t\t\t\tFxaaFloat lumaSWSE = lumaSW + lumaSE;\n\t\t\t\t\t\tFxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n\t\t\t\t\t\tFxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n\t\t\t\t\t\tFxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n\t\t\t\t\t\tFxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n\t\t\t\t\t\tFxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n\t\t\t\t\t\tFxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n\t\t\t\t\t\tFxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n\t\t\t\t\t\tFxaaBool horzSpan = edgeHorz >= edgeVert;\n\t\t\t\t\t\tFxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tif(!horzSpan) lumaN = lumaW;\n\t\t\t\t\t\tif(!horzSpan) lumaS = lumaE;\n\t\t\t\t\t\tif(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n\t\t\t\t\t\tFxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat gradientN = lumaN - lumaM;\n\t\t\t\t\t\tFxaaFloat gradientS = lumaS - lumaM;\n\t\t\t\t\t\tFxaaFloat lumaNN = lumaN + lumaM;\n\t\t\t\t\t\tFxaaFloat lumaSS = lumaS + lumaM;\n\t\t\t\t\t\tFxaaBool pairN = abs(gradientN) >= abs(gradientS);\n\t\t\t\t\t\tFxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n\t\t\t\t\t\tif(pairN) lengthSign = -lengthSign;\n\t\t\t\t\t\tFxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat2 posB;\n\t\t\t\t\t\tposB.x = posM.x;\n\t\t\t\t\t\tposB.y = posM.y;\n\t\t\t\t\t\tFxaaFloat2 offNP;\n\t\t\t\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\t\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\t\t\t\t\t\tif(!horzSpan) posB.x += lengthSign * 0.5;\n\t\t\t\t\t\tif( horzSpan) posB.y += lengthSign * 0.5;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat2 posN;\n\t\t\t\t\t\tposN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n\t\t\t\t\t\tposN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n\t\t\t\t\t\tFxaaFloat2 posP;\n\t\t\t\t\t\tposP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n\t\t\t\t\t\tposP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n\t\t\t\t\t\tFxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n\t\t\t\t\t\tFxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n\t\t\t\t\t\tFxaaFloat subpixE = subpixC * subpixC;\n\t\t\t\t\t\tFxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tif(!pairN) lumaNN = lumaSS;\n\t\t\t\t\t\tFxaaFloat gradientScaled = gradient * 1.0/4.0;\n\t\t\t\t\t\tFxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n\t\t\t\t\t\tFxaaFloat subpixF = subpixD * subpixE;\n\t\t\t\t\t\tFxaaBool lumaMLTZero = lumaMM < 0.0;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tlumaEndN -= lumaNN * 0.5;\n\t\t\t\t\t\tlumaEndP -= lumaNN * 0.5;\n\t\t\t\t\t\tFxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\tFxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n\t\t\t\t\t\tFxaaBool doneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 3)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 4)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 5)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 6)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 7)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 8)\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 9)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 10)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 11)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 12)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat dstN = posM.x - posN.x;\n\t\t\t\t\t\tFxaaFloat dstP = posP.x - posM.x;\n\t\t\t\t\t\tif(!horzSpan) dstN = posM.y - posN.y;\n\t\t\t\t\t\tif(!horzSpan) dstP = posP.y - posM.y;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n\t\t\t\t\t\tFxaaFloat spanLength = (dstP + dstN);\n\t\t\t\t\t\tFxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n\t\t\t\t\t\tFxaaFloat spanLengthRcp = 1.0/spanLength;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaBool directionN = dstN < dstP;\n\t\t\t\t\t\tFxaaFloat dst = min(dstN, dstP);\n\t\t\t\t\t\tFxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n\t\t\t\t\t\tFxaaFloat subpixG = subpixF * subpixF;\n\t\t\t\t\t\tFxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n\t\t\t\t\t\tFxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n\t\t\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\tFxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n\t\t\t\t\t\tFxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n\t\t\t\t\t\tif(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n\t\t\t\t\t\tif( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\treturn FxaaTexTop(tex, posM);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\treturn FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n\t\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t/*==========================================================================*/\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\t\tv_Uv,\n\t\t\t\t\t\tvec4(0.0),\n\t\t\t\t\t\ttDiffuse,\n\t\t\t\t\t\ttDiffuse,\n\t\t\t\t\t\ttDiffuse,\n\t\t\t\t\t\tresolution,\n\t\t\t\t\t\tvec4(0.0),\n\t\t\t\t\t\tvec4(0.0),\n\t\t\t\t\t\tvec4(0.0),\n\t\t\t\t\t\t0.75,\n\t\t\t\t\t\t0.166,\n\t\t\t\t\t\t0.0833,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\tvec4(0.0)\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t// TODO avoid querying texture twice for same texel\n\t\t\t\tgl_FragColor.a = texture2D(tDiffuse, v_Uv).a;\n\t\t\t\t}\n\t\t"},M=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"GBuffer"}],n._ssaoPass=new e.ShaderPostPass(Q),n.radius=.5,n.power=1,n.bias=.1,n.intensity=1,n.quality="Medium",n._kernelCode="",n._kernelSize=-1,n._setNoiseSize(64),n._setKernelSize(16),n._blurPass=new e.ShaderPostPass(u),n._blurPass.material.defines.NORMALTEX_ENABLED=1,n._blurPass.material.defines.DEPTHTEX_ENABLED=1,n.blurSize=1,n.depthRange=1,n._blendPass=new e.ShaderPostPass(c),n._blendPass.material.premultipliedAlpha=!0,n}a(n,t);var r=n.prototype;return r.render=function(t,n,r,a,s){var i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("GBuffer"),f=l.getCurrentRenderStates();R.copy(f.camera.projectionMatrix),U.copy(f.camera.projectionMatrix).inverse(),O.copy(f.camera.viewMatrix).inverse().transpose(),t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(1,1,1,1),t.renderPass.clear(!0,!0,!1),this._ssaoPass.uniforms.normalTex=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._ssaoPass.uniforms.depthTex=l.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._ssaoPass.uniforms.texSize[0]=l.output().width,this._ssaoPass.uniforms.texSize[1]=l.output().height,R.toArray(this._ssaoPass.uniforms.projection),U.toArray(this._ssaoPass.uniforms.projectionInv),O.toArray(this._ssaoPass.uniforms.viewInverseTranspose),this._setKernelSize(w[this.quality]),this._ssaoPass.uniforms.radius=this.radius,this._ssaoPass.uniforms.power=this.power,this._ssaoPass.uniforms.bias=this.bias,this._ssaoPass.uniforms.intensity=this.intensity,this._ssaoPass.render(t),t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.normalTex=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._blurPass.uniforms.depthTex=l.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._blurPass.uniforms.textureSize[0]=l.output().width,this._blurPass.uniforms.textureSize[1]=l.output().height,R.toArray(this._blurPass.uniforms.projection),O.toArray(this._blurPass.uniforms.viewInverseTranspose),this._blurPass.uniforms.blurSize=this.blurSize,this._blurPass.uniforms.depthRange=this.depthRange,this._blurPass.uniforms.direction=0,this._blurPass.uniforms.tDiffuse=i.texture,this._blurPass.render(t),t.renderPass.setRenderTarget(r?i:a),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.direction=1,this._blurPass.uniforms.tDiffuse=o.texture,this._blurPass.render(t),r&&(t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=i.texture,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1))),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)},r._setKernelSize=function(t,e){void 0===e&&(e=0);var n=t+"_"+e;this._kernelCode!==n&&(this._kernelCode=n,H[n]||(H[n]=function(t,e){void 0===e&&(e=0);for(var n=new Float32Array(3*t),r=0;r<t;r++){var a=X(r+e,2)*Math.PI*2,s=1-(.85*X(r+e,3)+.15),i=Math.sqrt(1-s*s),o=Math.random(),l=Math.cos(a)*i*o,f=Math.sin(a)*i*o,u=s*o;n[3*r]=l,n[3*r+1]=f,n[3*r+2]=u}return n}(t,e*t)),this._ssaoPass.uniforms.kernel=H[n],this._ssaoPass.material.defines.KERNEL_SIZE=t,this._ssaoPass.material.needsUpdate=!0)},r._setNoiseSize=function(t){if(this._noiseSize!==t){this._noiseSize=t;var n=this._ssaoPass.uniforms;n.noiseTex?(n.noiseTex.image.data=k(t),n.noiseTex.image.width=t,n.noiseTex.image.height=t,n.noiseTex.version++):n.noiseTex=function(t){var n=new e.Texture2D;return n.image={data:k(t),width:t,height:t},n.type=e.PIXEL_TYPE.UNSIGNED_BYTE,n.magFilter=e.TEXTURE_FILTER.NEAREST,n.minFilter=e.TEXTURE_FILTER.NEAREST,n.wrapS=e.TEXTURE_WRAP.REPEAT,n.wrapT=e.TEXTURE_WRAP.REPEAT,n.generateMipmaps=!1,n.flipY=!1,n.version++,n}(t),n.noiseTexSize[0]=t,n.noiseTexSize[1]=t}},n}(l),R=new e.Matrix4,U=new e.Matrix4,O=new e.Matrix4,w={Low:6,Medium:12,High:32,Ultra:64};function X(t,e){for(var n=0,r=1/e,a=t;a>0;)n+=r*(a%e),a=Math.floor(a/e),r/=e;return n}var H={};function k(t){for(var n=new Uint8Array(t*t*4),r=0,a=new e.Vector3,s=0;s<t;s++)for(var i=0;i<t;i++)a.set(2*Math.random()-1,2*Math.random()-1,0).normalize(),n[r++]=255*(.5*a.x+.5),n[r++]=255*(.5*a.y+.5),n[r++]=0,n[r++]=255;return n}var Q={name:"ec_ssao",defines:{ALCHEMY:!1,DEPTH_PACKING:0,KERNEL_SIZE:64},uniforms:{normalTex:null,depthTex:null,texSize:[512,512],noiseTex:null,noiseTexSize:[4,4],projection:new Float32Array(16),projectionInv:new Float32Array(16),viewInverseTranspose:new Float32Array(16),kernel:null,radius:.2,power:1,bias:1e-4,intensity:1},vertexShader:f,fragmentShader:"\n\t\t\t\t#include <packing>\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tuniform sampler2D normalTex;\n\t\t\t\tuniform sampler2D depthTex;\n\t\t\t\tuniform vec2 texSize;\n\n\t\t\t\tuniform sampler2D noiseTex;\n\t\t\t\tuniform vec2 noiseTexSize;\n\n\t\t\t\tuniform mat4 projection;\n\t\t\t\tuniform mat4 projectionInv;\n\t\t\t\tuniform mat4 viewInverseTranspose;\n\n\t\t\t\tuniform vec3 kernel[KERNEL_SIZE];\n\n\t\t\t\tuniform float radius;\n\t\t\t\tuniform float power;\n\t\t\t\tuniform float bias;\n\t\t\t\tuniform float intensity;\n\n\t\t\t\tfloat getDepth(const in vec2 screenPosition) {\n\t\t\t\t\t\t#if DEPTH_PACKING == 1\n\t\t\t\t\t\t\t\treturn unpackRGBAToDepth(texture2D(depthTex, screenPosition));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\treturn texture2D(depthTex, screenPosition).r;\n\t\t\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tvec3 getViewNormal(const in vec2 screenPosition) {\n\t\t\t\t\t\tvec3 normal = texture2D(normalTex, screenPosition).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t// Convert to view space\n\t\t\t\t\t\treturn (viewInverseTranspose * vec4(normal, 0.0)).xyz;\n\t\t\t\t}\n\n\t\t\t\tfloat ssaoEstimator(in mat3 kernelBasis, in vec3 originPos, in vec3 N) {\n\t\t\t\t\t\tfloat occlusion = 0.0;\n\n\t\t\t\t\t\tfor (int i = 0; i < KERNEL_SIZE; i++) {\n\t\t\t\t\t\t\t\tvec3 samplePos = kernel[i];\n\t\t\t\t\t\t\t\tsamplePos = kernelBasis * samplePos;\n\t\t\t\t\t\t\t\tsamplePos = samplePos * radius + originPos;\n\n\t\t\t\t\t\t\t\tvec4 texCoord = projection * vec4(samplePos, 1.0);\n\t\t\t\t\t\t\t\ttexCoord.xy /= texCoord.w;\n\t\t\t\t\t\t\t\ttexCoord.xy = texCoord.xy * 0.5 + 0.5;\n\n\t\t\t\t\t\t\t\tfloat sampleDepth = getDepth(texCoord.xy);\n\t\t\t\t\t\t\t\tfloat z = sampleDepth * 2.0 - 1.0;\n\n\t\t\t\t\t\t\t\t#ifdef ALCHEMY\n\t\t\t\t\t\t\t\t\t\tvec4 projectedPos = vec4(texCoord.xy * 2.0 - 1.0, z, 1.0);\n\t\t\t\t\t\t\t\t\t\tvec4 p4 = projectionInv * projectedPos;\n\t\t\t\t\t\t\t\t\t\tp4.xyz /= p4.w;\n\n\t\t\t\t\t\t\t\t\t\tvec3 cDir = p4.xyz - originPos;\n\n\t\t\t\t\t\t\t\t\t\tfloat vv = dot(cDir, cDir);\n\t\t\t\t\t\t\t\t\t\tfloat vn = dot(cDir, N);\n\n\t\t\t\t\t\t\t\t\t\tfloat radius2 = radius * radius;\n\t\t\t\t\t\t\t\t\t\tvn = max(vn + p4.z * bias, 0.0);\n\t\t\t\t\t\t\t\t\t\tfloat f = max(radius2 - vv, 0.0) / radius2;\n\t\t\t\t\t\t\t\t\t\tocclusion += f * f * f * max(vn / (0.01 + vv), 0.0);\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tif (projection[3][3] == 0.0) {\n\t\t\t\t\t\t\t\t\t\t\t\tz = projection[3][2] / (z * projection[2][3] - projection[2][2]);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tz = (z - projection[3][2]) / projection[2][2];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tfloat factor = step(samplePos.z, z - bias);\n\t\t\t\t\t\t\t\t\t\tfloat rangeCheck = smoothstep(0.0, 1.0, radius / abs(originPos.z - z));\n\t\t\t\t\t\t\t\t\t\tocclusion += rangeCheck * factor;\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tocclusion = 1.0 - occlusion / float(KERNEL_SIZE);\n\n\t\t\t\t\t\treturn pow(occlusion, power);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tfloat centerDepth = getDepth(v_Uv);\n\t\t\t\t\t\tif(centerDepth >= (1.0 - EPSILON)) {\n\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec3 N = getViewNormal(v_Uv);\n\n\t\t\t\t\t\tvec2 noiseTexCoord = texSize / vec2(noiseTexSize) * v_Uv;\n\t\t\t\t\t\tvec3 rvec = texture2D(noiseTex, noiseTexCoord).rgb * 2.0 - 1.0;\n\n\t\t\t\t\t\t// Tangent\n\t\t\t\t\t\tvec3 T = normalize(rvec - N * dot(rvec, N));\n\t\t\t\t\t\t// Bitangent\n\t\t\t\t\t\tvec3 BT = normalize(cross(N, T));\n\n\t\t\t\t\t\tmat3 kernelBasis = mat3(T, BT, N);\n\n\t\t\t\t\t\t// view position\n\t\t\t\t\t\tfloat z = centerDepth * 2.0 - 1.0;\n\t\t\t\t\t\tvec4 projectedPos = vec4(v_Uv * 2.0 - 1.0, z, 1.0);\n\t\t\t\t\t\tvec4 p4 = projectionInv * projectedPos;\n\t\t\t\t\t\tvec3 position = p4.xyz / p4.w;\n\n\t\t\t\t\t\tfloat ao = ssaoEstimator(kernelBasis, position, N);\n\t\t\t\t\t\tao = clamp(1.0 - (1.0 - ao) * intensity, 0.0, 1.0);\n\n\t\t\t\t\t\tgl_FragColor = vec4(vec3(ao), 1.0);\n\t\t\t\t}\n\t\t"},W=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"SceneBuffer"},{key:"GBuffer"}],n._ssrPass=new e.ShaderPostPass(G),n.maxRayDistance=200,n.pixelStride=16,n.pixelStrideZCutoff=50,n.screenEdgeFadeStart=.9,n.eyeFadeStart=.4,n.eyeFadeEnd=.8,n.minGlossiness=.2,n._blurPass=new e.ShaderPostPass(u),n._blurPass.material.defines.NORMALTEX_ENABLED=1,n._blurPass.material.defines.DEPTHTEX_ENABLED=1,n.blurSize=2,n.depthRange=1,n._blendPass=new e.ShaderPostPass(d),n._blendPass.material.premultipliedAlpha=!0,n}return a(n,t),n.prototype.render=function(t,n,r,a,s){var i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("GBuffer"),u=f.getCurrentRenderStates();B.copy(u.camera.projectionMatrix),Y.copy(u.camera.projectionMatrix).inverse(),z.copy(u.camera.viewMatrix).inverse().transpose(),t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,1),t.renderPass.clear(!0,!0,!1),this._ssrPass.uniforms.colorTex=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._ssrPass.uniforms.gBufferTexture1=f.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._ssrPass.uniforms.gBufferTexture2=f.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._ssrPass.uniforms.viewportSize[0]=f.output().width,this._ssrPass.uniforms.viewportSize[1]=f.output().height,B.toArray(this._ssrPass.uniforms.projection),Y.toArray(this._ssrPass.uniforms.projectionInv),z.toArray(this._ssrPass.uniforms.viewInverseTranspose),this._ssrPass.uniforms.maxRayDistance=this.maxRayDistance,this._ssrPass.uniforms.pixelStride=this.pixelStride,this._ssrPass.uniforms.pixelStrideZCutoff=this.pixelStrideZCutoff,this._ssrPass.uniforms.screenEdgeFadeStart=this.screenEdgeFadeStart,this._ssrPass.uniforms.eyeFadeStart=this.eyeFadeStart,this._ssrPass.uniforms.eyeFadeEnd=this.eyeFadeEnd,this._ssrPass.uniforms.minGlossiness=this.minGlossiness,this._ssrPass.render(t),t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.normalTex=f.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._blurPass.uniforms.depthTex=f.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._blurPass.uniforms.textureSize[0]=f.output().width,this._blurPass.uniforms.textureSize[1]=f.output().height,B.toArray(this._blurPass.uniforms.projection),z.toArray(this._blurPass.uniforms.viewInverseTranspose),this._blurPass.uniforms.blurSize=this.blurSize,this._blurPass.uniforms.depthRange=this.depthRange,this._blurPass.uniforms.direction=0,this._blurPass.uniforms.tDiffuse=i.texture,this._blurPass.render(t),t.renderPass.setRenderTarget(r?i:a),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.direction=1,this._blurPass.uniforms.tDiffuse=o.texture,this._blurPass.render(t),r&&(t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=i.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1))),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)},n}(l),B=new e.Matrix4,Y=new e.Matrix4,z=new e.Matrix4,G={name:"ec_ssr",defines:{},uniforms:{colorTex:null,gBufferTexture1:null,gBufferTexture2:null,projection:new Float32Array(16),projectionInv:new Float32Array(16),viewInverseTranspose:new Float32Array(16),maxRayDistance:4,pixelStride:16,pixelStrideZCutoff:10,screenEdgeFadeStart:.9,eyeFadeStart:.4,eyeFadeEnd:.8,minGlossiness:.2,zThicknessThreshold:.1,jitterOffset:0,nearZ:0,viewportSize:[512,512],maxMipmapLevel:5},vertexShader:f,fragmentShader:"\n\t\t#define MAX_ITERATION 20;\n\t\t#define MAX_BINARY_SEARCH_ITERATION 5;\n\n\t\tvarying vec2 v_Uv;\n\n\t\tuniform sampler2D colorTex;\n\t\tuniform sampler2D gBufferTexture1;\n\t\tuniform sampler2D gBufferTexture2;\n\n\t\tuniform mat4 projection;\n\t\tuniform mat4 projectionInv;\n\t\tuniform mat4 viewInverseTranspose;\n\n\t\tuniform float maxRayDistance;\n\n\t\tuniform float pixelStride;\n\t\t// ray origin Z at this distance will have a pixel stride of 1.0\n\t\tuniform float pixelStrideZCutoff;\n\n\t\t// distance to screen edge that ray hits will start to fade (0.0 -> 1.0)\n\t\tuniform float screenEdgeFadeStart;\n\n\t\t// ray direction's Z that ray hits will start to fade (0.0 -> 1.0)\n\t\tuniform float eyeFadeStart;\n\t\t// ray direction's Z that ray hits will be cut (0.0 -> 1.0)\n\t\tuniform float eyeFadeEnd;\n\n\t\t// Object larger than minGlossiness will have ssr effect\n\t\tuniform float minGlossiness;\n\t\tuniform float zThicknessThreshold;\n\t\tuniform float jitterOffset;\n\n\t\tuniform float nearZ;\n\t\tuniform vec2 viewportSize;\n\n\t\tuniform float maxMipmapLevel;\n\n\t\tfloat fetchDepth(sampler2D depthTexture, vec2 uv) {\n\t\t\tvec4 depthTexel = texture2D(depthTexture, uv);\n\t\t\treturn depthTexel.r * 2.0 - 1.0;\n\t\t}\n\n\t\tfloat linearDepth(float depth) {\n\t\t\treturn projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n\t\t}\n\n\t\tbool rayIntersectDepth(float rayZNear, float rayZFar, vec2 hitPixel) {\n\t\t\t// Swap if bigger\n\t\t\tif (rayZFar > rayZNear) {\n\t\t\t\tfloat t = rayZFar; rayZFar = rayZNear; rayZNear = t;\n\t\t\t}\n\t\t\tfloat cameraZ = linearDepth(fetchDepth(gBufferTexture2, hitPixel));\n\t\t\t// float cameraBackZ = linearDepth(fetchDepth(backDepthTex, hitPixel));\n\t\t\t// Cross z\n\t\t\treturn rayZFar <= cameraZ && rayZNear >= cameraZ - zThicknessThreshold;\n\t\t}\n\n\t\t// Trace a ray in screenspace from rayOrigin (in camera space) pointing in rayDir (in camera space)\n\t\t//\n\t\t// With perspective correct interpolation\n\t\t//\n\t\t// Returns true if the ray hits a pixel in the depth buffer\n\t\t// and outputs the hitPixel (in UV space), the hitPoint (in camera space) and the number\n\t\t// of iterations it took to get there.\n\t\t//\n\t\t// Based on Morgan McGuire & Mike Mara's GLSL implementation:\n\t\t// http://casual-effects.blogspot.com/2014/08/screen-space-ray-tracing.html\n\t\tbool traceScreenSpaceRay(vec3 rayOrigin, vec3 rayDir, float jitter, out vec2 hitPixel, out vec3 hitPoint, out float iterationCount) {\n\t\t\t// Clip to the near plane\n\t\t\tfloat rayLength = ((rayOrigin.z + rayDir.z * maxRayDistance) > -nearZ) ? (-nearZ - rayOrigin.z) / rayDir.z : maxRayDistance;\n\n\t\t\tvec3 rayEnd = rayOrigin + rayDir * rayLength;\n\n\t\t\t// Project into homogeneous clip space\n\t\t\tvec4 H0 = projection * vec4(rayOrigin, 1.0);\n\t\t\tvec4 H1 = projection * vec4(rayEnd, 1.0);\n\n\t\t\tfloat k0 = 1.0 / H0.w, k1 = 1.0 / H1.w;\n\n\t\t\t// The interpolated homogeneous version of the camera space points\n\t\t\tvec3 Q0 = rayOrigin * k0, Q1 = rayEnd * k1;\n\n\t\t\t// Screen space endpoints\n\t\t\t// PENDING viewportSize ?\n\t\t\tvec2 P0 = (H0.xy * k0 * 0.5 + 0.5) * viewportSize;\n\t\t\tvec2 P1 = (H1.xy * k1 * 0.5 + 0.5) * viewportSize;\n\n\t\t\t// If the line is degenerate, make it cover at least one pixel to avoid handling\n\t\t\t// zero-pixel extent as a special case later\n\t\t\tP1 += dot(P1 - P0, P1 - P0) < 0.0001 ? 0.01 : 0.0;\n\t\t\tvec2 delta = P1 - P0;\n\n\t\t\t// Permute so that the primary iteration is in x to collapse\n\t\t\t// all quadrant-specific DDA case later\n\t\t\tbool permute = false;\n\t\t\tif (abs(delta.x) < abs(delta.y)) {\n\t\t\t\t// More vertical line\n\t\t\t\tpermute = true;\n\t\t\t\tdelta = delta.yx;\n\t\t\t\tP0 = P0.yx;\n\t\t\t\tP1 = P1.yx;\n\t\t\t}\n\t\t\tfloat stepDir = sign(delta.x);\n\t\t\tfloat invdx = stepDir / delta.x;\n\n\t\t\t// Track the derivatives of Q and K\n\t\t\tvec3 dQ = (Q1 - Q0) * invdx;\n\t\t\tfloat dk = (k1 - k0) * invdx;\n\n\t\t\tvec2 dP = vec2(stepDir, delta.y * invdx);\n\n\t\t\t// Calculate pixel stride based on distance of ray origin from camera.\n\t\t\t// Since perspective means distant objects will be smaller in screen space\n\t\t\t// we can use this to have higher quality reflections for far away objects\n\t\t\t// while still using a large pixel stride for near objects (and increase performance)\n\t\t\t// this also helps mitigate artifacts on distant reflections when we use a large\n\t\t\t// pixel stride.\n\t\t\tfloat strideScaler = 1.0 - min(1.0, -rayOrigin.z / pixelStrideZCutoff);\n\t\t\tfloat pixStride = 1.0 + strideScaler * pixelStride;\n\n\t\t\t// Scale derivatives by the desired pixel stride and the offset the starting values by the jitter fraction\n\t\t\tdP *= pixStride; dQ *= pixStride; dk *= pixStride;\n\n\t\t\t// Track ray step and derivatives in a vec4 to parallelize\n\t\t\tvec4 pqk = vec4(P0, Q0.z, k0);\n\t\t\tvec4 dPQK = vec4(dP, dQ.z, dk);\n\n\t\t\tpqk += dPQK * jitter;\n\t\t\tfloat rayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n\t\t\tfloat rayZNear;\n\n\t\t\tbool intersect = false;\n\n\t\t\tvec2 texelSize = 1.0 / viewportSize;\n\n\t\t\titerationCount = 0.0;\n\n\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\tpqk += dPQK;\n\n\t\t\t\trayZNear = rayZFar;\n\t\t\t\trayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n\n\t\t\t\thitPixel = permute ? pqk.yx : pqk.xy;\n\t\t\t\thitPixel *= texelSize;\n\n\t\t\t\tintersect = rayIntersectDepth(rayZNear, rayZFar, hitPixel);\n\n\t\t\t\titerationCount += 1.0;\n\n\t\t\t\t// PENDING Right on all platforms?\n\t\t\t\tif (intersect) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Binary search refinement\n\t\t\t// FIXME If intersect in first iteration binary search may easily lead to the pixel of reflect object it self\n\t\t\tif (pixStride > 1.0 && intersect && iterationCount > 1.0) {\n\t\t\t\t// Roll back\n\t\t\t\tpqk -= dPQK;\n\t\t\t\tdPQK /= pixStride;\n\n\t\t\t\tfloat originalStride = pixStride * 0.5;\n\t\t\t\tfloat stride = originalStride;\n\n\t\t\t\trayZNear = pqk.z / pqk.w;\n\t\t\t\trayZFar = rayZNear;\n\n\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\tpqk += dPQK * stride;\n\t\t\t\t\trayZNear = rayZFar;\n\t\t\t\t\trayZFar = (dPQK.z * -0.5 + pqk.z) / (dPQK.w * -0.5 + pqk.w);\n\t\t\t\t\thitPixel = permute ? pqk.yx : pqk.xy;\n\t\t\t\t\thitPixel *= texelSize;\n\n\t\t\t\t\toriginalStride *= 0.5;\n\t\t\t\t\tstride = rayIntersectDepth(rayZNear, rayZFar, hitPixel) ? -originalStride : originalStride;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ0.xy += dQ.xy * iterationCount;\n\t\t\tQ0.z = pqk.z;\n\t\t\thitPoint = Q0 / pqk.w;\n\n\t\t\treturn intersect;\n\t\t}\n\n\t\tfloat calculateAlpha(float iterationCount, float reflectivity, vec2 hitPixel, vec3 hitPoint, float dist, vec3 rayDir) {\n\t\t\tfloat alpha = clamp(reflectivity, 0.0, 1.0);\n\t\t\t// Fade ray hits that approach the maximum iterations\n\t\t\talpha *= 1.0 - (iterationCount / float(20));\n\t\t\t// Fade ray hits that approach the screen edge\n\t\t\tvec2 hitPixelNDC = hitPixel * 2.0 - 1.0;\n\t\t\tfloat maxDimension = min(1.0, max(abs(hitPixelNDC.x), abs(hitPixelNDC.y)));\n\t\t\talpha *= 1.0 - max(0.0, maxDimension - screenEdgeFadeStart) / (1.0 - screenEdgeFadeStart);\n\n\t\t\t// Fade ray hits base on how much they face the camera\n\t\t\tfloat _eyeFadeStart = eyeFadeStart;\n\t\t\tfloat _eyeFadeEnd = eyeFadeEnd;\n\t\t\tif (_eyeFadeStart > _eyeFadeEnd) {\n\t\t\t\tfloat tmp = _eyeFadeEnd;\n\t\t\t\t_eyeFadeEnd = _eyeFadeStart;\n\t\t\t\t_eyeFadeStart = tmp;\n\t\t\t}\n\n\t\t\tfloat eyeDir = clamp(rayDir.z, _eyeFadeStart, _eyeFadeEnd);\n\t\t\talpha *= 1.0 - (eyeDir - _eyeFadeStart) / (_eyeFadeEnd - _eyeFadeStart);\n\n\t\t\t// Fade ray hits based on distance from ray origin\n\t\t\talpha *= 1.0 - clamp(dist / maxRayDistance, 0.0, 1.0);\n\n\t\t\treturn alpha;\n\t\t}\n\n\t\tvoid main() {\n\t\t\tvec4 normalAndGloss = texture2D(gBufferTexture1, v_Uv);\n\n\t\t\t// Is empty\n\t\t\tif (dot(normalAndGloss.rgb, vec3(1.0)) == 0.0) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat g = normalAndGloss.a;\n\t\t\tif (g <= minGlossiness) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat reflectivity = (g - minGlossiness) / (1.0 - minGlossiness);\n\n\t\t\tvec3 N = normalAndGloss.rgb * 2.0 - 1.0;\n\t\t\tN = normalize((viewInverseTranspose * vec4(N, 0.0)).xyz);\n\n\t\t\t// Position in view\n\t\t\tvec4 projectedPos = vec4(v_Uv * 2.0 - 1.0, fetchDepth(gBufferTexture2, v_Uv), 1.0);\n\t\t\tvec4 pos = projectionInv * projectedPos;\n\t\t\tvec3 rayOrigin = pos.xyz / pos.w;\n\n\t\t\tvec3 rayDir = normalize(reflect(normalize(rayOrigin), N));\n\t\t\tvec2 hitPixel;\n\t\t\tvec3 hitPoint;\n\t\t\tfloat iterationCount;\n\n\t\t\t// Get jitter\n\t\t\tvec2 uv2 = v_Uv * viewportSize;\n\t\t\tfloat jitter = fract((uv2.x + uv2.y) * 0.25);\n\n\t\t\tbool intersect = traceScreenSpaceRay(rayOrigin, rayDir, jitter, hitPixel, hitPoint, iterationCount);\n\n\t\t\tfloat dist = distance(rayOrigin, hitPoint);\n\n\t\t\tfloat alpha = calculateAlpha(iterationCount, reflectivity, hitPixel, hitPoint, dist, rayDir) * float(intersect);\n\n\t\t\tvec3 hitNormal = texture2D(gBufferTexture1, hitPixel).rgb * 2.0 - 1.0;\n\t\t\thitNormal = normalize((viewInverseTranspose * vec4(hitNormal, 0.0)).xyz);\n\n\t\t\t// Ignore the pixel not face the ray\n\t\t\t// TODO fadeout ?\n\t\t\t// PENDING Can be configured?\n\t\t\tif (dot(hitNormal, rayDir) >= 0.0) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\t// vec4 color = decodeHDR(texture2DLodEXT(colorTex, hitPixel, clamp(dist / maxRayDistance, 0.0, 1.0) * maxMipmapLevel));\n\n\t\t\tif (!intersect) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tvec4 color = texture2D(colorTex, hitPixel);\n\t\t\tgl_FragColor = vec4(color.rgb * alpha, color.a);\n\n\t\t\t// gl_FragColor = vec4(vec3(iterationCount / 2.0), 1.0);\n\n\t\t}\n\t\t"},Z=function(t){function n(){var n;return(n=t.call(this)||this).color=new e.Color3(0,0,0),n.offset=1,n._vignettingPass=new e.ShaderPostPass(j),n._vignettingPass.material.premultipliedAlpha=!0,n}return a(n,t),n.prototype.render=function(t,e,n,r,a){var s=this._vignettingPass;s.uniforms.tDiffuse=n.texture,this.color.toArray(s.uniforms.vignettingColor),s.uniforms.vignettingOffset=this.offset,t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,0),a?t.renderPass.clear(e.clearColor,e.clearDepth,e.clearStencil):t.renderPass.clear(!0,!0,!1),a&&(s.material.transparent=e._tempClearColor[3]<1||!e.clearColor,s.renderStates.camera.rect.fromArray(e._tempViewport)),s.render(t),a&&(s.material.transparent=!1,s.renderStates.camera.rect.set(0,0,1,1))},n}(l),j={name:"ec_vignetting_blend",defines:{},uniforms:{tDiffuse:null,vignettingColor:[0,0,0],vignettingOffset:1},vertexShader:f,fragmentShader:"\n\t\tuniform vec3 vignettingColor;\n\t\tuniform float vignettingOffset;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 color = texture2D(tDiffuse, v_Uv);\n\t\t\t\t\t\tvec2 uv = (v_Uv - vec2(0.5)) * vec2(vignettingOffset);\n\t\t\tcolor.rgb = mix(color.rgb, vignettingColor, clamp(dot(uv, uv), 0.0, 1.0));\n\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"},V=function(t){function n(){var n;return(n=t.call(this)||this).offset=1,n._hBlurPass=new e.ShaderPostPass(A),n._vBlurPass=new e.ShaderPostPass(T),n._blendPass=new e.ShaderPostPass(q),n._blendPass.material.premultipliedAlpha=!0,n}a(n,t);var r=n.prototype;return r.resize=function(t,e){this._hBlurPass.uniforms.h=4/t,this._vBlurPass.uniforms.v=4/e},r.render=function(t,e,n,r,a){var s=e._renderTargetCache.allocate(1),i=e._renderTargetCache.allocate(1),o=this._blendPass;t.renderPass.setRenderTarget(s),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._hBlurPass.uniforms.tDiffuse=n.texture,this._hBlurPass.render(t),t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._vBlurPass.uniforms.tDiffuse=s.texture,this._vBlurPass.render(t),o.uniforms.tDiffuse=n.texture,o.uniforms.blurOffset=this.offset,o.uniforms.blurTexture=i.texture,t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,0),a?t.renderPass.clear(e.clearColor,e.clearDepth,e.clearStencil):t.renderPass.clear(!0,!0,!1),a&&(o.material.transparent=e._tempClearColor[3]<1||!e.clearColor,o.renderStates.camera.rect.fromArray(e._tempViewport)),o.render(t),a&&(o.material.transparent=!1,o.renderStates.camera.rect.set(0,0,1,1)),e._renderTargetCache.release(s,1),e._renderTargetCache.release(i,1)},n}(l),q={name:"ec_blur_blend",defines:{},uniforms:{tDiffuse:null,blurOffset:1,blurTexture:null},vertexShader:f,fragmentShader:"\n\t\tuniform float blurOffset;\n\n\t\t\t\tuniform sampler2D blurTexture;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 color = texture2D(tDiffuse, v_Uv);\n\t\t\t\t\t\tvec2 uv = (v_Uv - vec2(0.5)) * vec2(blurOffset);\n\n\t\t\t\t\t\tvec3 color2 = texture2D(blurTexture, v_Uv).rgb;\n\n\t\t\tcolor.rgb = mix(color.rgb, color2, clamp(dot(uv, uv), 0.0, 1.0));\n\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"},K=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"NonDepthMarkBuffer"}],n.color=new e.Color3(1,1,1),n.thickness=1,n.strength=1.5,n._downsamplerPass=new e.ShaderPostPass(h),n._edgeDetectionPass=new e.ShaderPostPass($),n._blurPass=new e.ShaderPostPass(x),n._blendPass=new e.ShaderPostPass(J),n._blendPass.material.premultipliedAlpha=!0,n}return a(n,t),n.prototype.render=function(t,n,r,a,s){var i=n._renderTargetCache.allocate(1),o=n._renderTargetCache.allocate(1),l=n.getBuffer("NonDepthMarkBuffer"),f=l.attachManager.getAttachIndex(this.name),u=l.attachManager.getChannelIndex(this.name);t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._downsamplerPass.uniforms.tDiffuse=l.output(f)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._downsamplerPass.render(t),t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._edgeDetectionPass.uniforms.tDiffuse=i.texture,this._edgeDetectionPass.uniforms.texSize[0]=i.width,this._edgeDetectionPass.uniforms.texSize[1]=i.height;for(var d=0;d<4;d++)this._edgeDetectionPass.uniforms.channelMask[d]=d===u?1:0;this.color.toArray(this._edgeDetectionPass.uniforms.edgeColor),this._edgeDetectionPass.render(t),t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=o.texture,this._blurPass.uniforms.texSize[0]=o.width,this._blurPass.uniforms.texSize[1]=o.height,this._blurPass.uniforms.direction[0]=1,this._blurPass.uniforms.direction[1]=0,this._blurPass.uniforms.kernelRadius=this.thickness,this._blurPass.render(t),t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=i.texture,this._blurPass.uniforms.direction[0]=0,this._blurPass.uniforms.direction[1]=1,this._blurPass.render(t),t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.colorTexture=r.texture,this._blendPass.uniforms.edgeTexture=o.texture,this._blendPass.uniforms.maskTexture=l.output(f)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._blendPass.uniforms.strength=this.strength;for(var c=0;c<4;c++)this._blendPass.uniforms.channelMask[c]=c===u?1:0;s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,1),n._renderTargetCache.release(o,1)},n}(l),$={name:"ec_outline_edge",defines:{},uniforms:{tDiffuse:null,texSize:[.5,.5],edgeColor:[1,1,1],channelMask:[1,0,0,0]},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 edgeColor;\n\n\t\tuniform vec4 channelMask;\n\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\tfloat c1 = dot(texture2D(tDiffuse, v_Uv + uvOffset.xy), channelMask);\n\t\t\tfloat c2 = dot(texture2D(tDiffuse, v_Uv - uvOffset.xy), channelMask);\n\t\t\tfloat c3 = dot(texture2D(tDiffuse, v_Uv + uvOffset.yw), channelMask);\n\t\t\tfloat c4 = dot(texture2D(tDiffuse, v_Uv - uvOffset.yw), channelMask);\n\t\t\tfloat b1 = max(c1, c2);\n\t\t\tfloat b2 = max(c3, c4);\n\t\t\tfloat a = max(b1, b2);\n\t\t\tgl_FragColor = vec4(edgeColor, a);\n\t\t\t\t}\n\t\t"},J={name:"ec_outline_blend",defines:{},uniforms:{maskTexture:null,edgeTexture:null,colorTexture:null,strength:1,channelMask:[1,0,0,0]},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture;\n\t\t\t\tuniform float strength;\n\n\t\tuniform vec4 channelMask;\n\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 edgeColor = texture2D(edgeTexture, v_Uv);\n\t\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, v_Uv);\n\n\t\t\t\t\t\tvec4 outlineColor = edgeColor * strength;\n\t\t\toutlineColor.a *= (1.0 - dot(maskColor, channelMask));\n\n\t\t\t\t\t\tvec4 color = texture2D(colorTexture, v_Uv);\n\t\t\t\n\t\t\t\t\t\tcolor.rgb = outlineColor.rgb * outlineColor.a + color.rgb * (1. - outlineColor.a);\n\t\t\tcolor.a = outlineColor.a + color.a * (1. - outlineColor.a);\n\n\t\t\t\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"},tt=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"MarkBuffer"}],n.color=new e.Color3(1,1,1),n.strength=1.5,n.stride=5,n._channelPass=new e.ShaderPostPass(_),n._blurXPass=new e.ShaderPostPass(et),n._blurYPass=new e.ShaderPostPass(nt),n._blendPass=new e.ShaderPostPass(rt),n._blendPass.material.premultipliedAlpha=!0,n}a(n,t);var r=n.prototype;return r.resize=function(t,e){this._blurXPass.uniforms.texSize[0]=t,this._blurXPass.uniforms.texSize[1]=e,this._blurYPass.uniforms.texSize[0]=t,this._blurYPass.uniforms.texSize[1]=e},r.render=function(t,n,r,a,s){var i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n._renderTargetCache.allocate(0),f=n.getBuffer("MarkBuffer"),u=f.attachManager.getAttachIndex(this.name),d=f.attachManager.getChannelIndex(this.name);t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._channelPass.uniforms.tDiffuse=f.output(u)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];for(var c=0;c<4;c++)this._channelPass.uniforms.channelMask[c]=c===d?1:0;this._channelPass.render(t),t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurXPass.uniforms.tDiffuse=i.texture,this._blurXPass.uniforms.stride=this.stride,this._blurXPass.render(t),t.renderPass.setRenderTarget(l),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurYPass.uniforms.tDiffuse=i.texture,this._blurYPass.uniforms.blurX=o.texture,this._blurYPass.uniforms.stride=this.stride,this._blurYPass.uniforms.glowness=this.strength,this.color.toArray(this._blurYPass.uniforms.glowColor),this._blurYPass.render(t),t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=l.texture,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0),n._renderTargetCache.release(l,0)},n}(l),et={name:"ec_innerglow_x",defines:{},uniforms:{tDiffuse:null,texSize:[1,1],stride:10},vertexShader:f,fragmentShader:"\n\t\t#define WT9_0 1.0\n\t\t#define WT9_1 0.8\n\t\t#define WT9_2 0.6\n\t\t#define WT9_3 0.4\n\t\t#define WT9_4 0.2\n\t\t#define WT9_NORMALIZE 5.2\n\n\t\tvarying vec2 v_Uv;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 texSize;\n\t\tuniform float stride;\n\n\t\tvoid main() {\n\t\t\tfloat texelIncrement = 0.25 * stride / texSize.x;\n\n\t\t\tfloat colour = texture2D(tDiffuse,vec2(v_Uv.x + texelIncrement, v_Uv.y)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * texelIncrement, v_Uv.y)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * texelIncrement, v_Uv.y)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = 0.5 * stride / texSize.x;\n\t\t\tcolour += texture2D(tDiffuse,vec2(v_Uv.x + texelIncrement, v_Uv.y)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * texelIncrement, v_Uv.y)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * texelIncrement, v_Uv.y)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = 0.75 * stride / texSize.x;\n\t\t\tcolour += texture2D(tDiffuse,vec2(v_Uv.x + texelIncrement, v_Uv.y)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * texelIncrement, v_Uv.y)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * texelIncrement, v_Uv.y)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = stride / texSize.x;\n\t\t\tcolour += texture2D(tDiffuse,vec2(v_Uv.x + texelIncrement, v_Uv.y)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x + 4.0 * texelIncrement, v_Uv.y)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 1.0 * texelIncrement, v_Uv.y)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 2.0 * texelIncrement, v_Uv.y)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 3.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(tDiffuse, vec2(v_Uv.x - 4.0 * texelIncrement, v_Uv.y)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\tfloat col = 1.0 - colour * 0.25;\n\n\t\t\tgl_FragColor = vec4(col,col,col,col);\n\t\t}\n\t\t"},nt={name:"ec_innerglow_y",defines:{},uniforms:{tDiffuse:null,blurX:null,texSize:[1,1],stride:10,glowness:2,glowColor:[1,0,0]},vertexShader:f,fragmentShader:"\n\t\t#define WT9_0 1.0\n\t\t#define WT9_1 0.8\n\t\t#define WT9_2 0.6\n\t\t#define WT9_3 0.4\n\t\t#define WT9_4 0.2\n\t\t#define WT9_NORMALIZE 5.2\n\n\t\tvarying vec2 v_Uv;\n\t\tuniform vec2 texSize;\n\t\tuniform float stride;\n\t\tuniform float glowness;\n\t\tuniform vec3 glowColor;\n\t\tuniform sampler2D blurX;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvoid main() {\n\t\t\tfloat texelIncrement = 0.25 * stride / texSize.y;\n\n\t\t\tfloat colour = texture2D(blurX, vec2(v_Uv.x , v_Uv.y + texelIncrement)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y + 2.0 * texelIncrement)).x* (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 3.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 4.0 * texelIncrement)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y - 1.0 * texelIncrement)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 2.0 * texelIncrement)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 3.0 * texelIncrement)).x* (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y- 4.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = 0.5 * stride / texSize.y;\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + texelIncrement)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y + 2.0 * texelIncrement)).x* (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 3.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 4.0 * texelIncrement)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y - 1.0 * texelIncrement)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 2.0 * texelIncrement)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 3.0 * texelIncrement)).x* (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y- 4.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = 0.75 * stride / texSize.y;\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + texelIncrement)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y + 2.0 * texelIncrement)).x* (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 3.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 4.0 * texelIncrement)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y - 1.0 * texelIncrement)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 2.0 * texelIncrement)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 3.0 * texelIncrement)).x* (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y- 4.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\ttexelIncrement = stride / texSize.y;\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + texelIncrement)).x * (0.8 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y + 2.0 * texelIncrement)).x* (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 3.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y + 4.0 * texelIncrement)).x * (WT9_4 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y)).x * (WT9_0 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y - 1.0 * texelIncrement)).x * (WT9_1 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 2.0 * texelIncrement)).x * (WT9_2 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x, v_Uv.y - 3.0 * texelIncrement)).x* (WT9_3 / WT9_NORMALIZE);\n\t\t\tcolour += texture2D(blurX, vec2(v_Uv.x , v_Uv.y- 4.0 * texelIncrement)).x * (WT9_3 / WT9_NORMALIZE);\n\n\t\t\tvec3 glo = (0.25 * glowness * colour) * glowColor;\n\t\t\tvec4 maskTexel = texture2D(tDiffuse, v_Uv);\n\t\t\t\n\t\t\tgl_FragColor = vec4(maskTexel.x * glo, 1.);\n\t\t}\n\t\t"},rt={name:"ec_tint",defines:{},uniforms:{texture1:null,texture2:null},vertexShader:f,fragmentShader:"\n\t\t\t\tuniform sampler2D texture1;\n\t\t\t\tuniform sampler2D texture2;\n\t\t\t\tvarying vec2 v_Uv;\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tvec4 texel1 = texture2D(texture1, v_Uv);\n\t\t\t\t\t\tvec4 texel2 = texture2D(texture2, v_Uv);\n\n\t\t\t\t\t\tfloat v = max(max(texel2.x, texel2.y), texel2.z);\n\n\t\t\t\t\t\tvec4 color = mix(texel1, vec4(texel2.rgb, texel1.a), v);\n\t\t\t\t\t\tgl_FragColor = color;\n\t\t\t\t}\n\t\t"},at=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],n.strength=1,n.radius=.4,n.threshold=.01,n.smoothWidth=.1,n._maskPass=new e.ShaderPostPass(m),n._highlightPass=new e.ShaderPostPass(p),n._blurPass=new e.ShaderPostPass(x),n._compositePass=new e.ShaderPostPass(it),n._blendPass=new e.ShaderPostPass(d),n._blendPass.material.premultipliedAlpha=!0,n._compositePass.uniforms.bloomFactors=new Float32Array([1,.8,.6,.4,.2]),n._compositePass.uniforms.bloomTintColors=new Float32Array([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]),n._tempRTList=[],n}return a(n,t),n.prototype.render=function(t,n,r,a,s){var i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(1),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("MarkBuffer"),u=n.getBuffer("ColorMarkBuffer"),d=f.attachManager.has(this.name),c=u.attachManager.getAttachIndex(this.name),h=u.output(c)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(d){var _=f.attachManager.getAttachIndex(this.name),m=f.attachManager.getChannelIndex(this.name);t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=f.output(_)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=h;for(var p=0;p<4;p++)this._maskPass.uniforms.channel[p]=p===m?1:0;this._maskPass.render(t)}t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._highlightPass.uniforms.tDiffuse=d?o.texture:h,this._highlightPass.uniforms.threshold=this.threshold,this._highlightPass.uniforms.smoothWidth=this.smoothWidth,this._highlightPass.render(t);for(var x=i,A=0;A<st.length;A++){var T=n._renderTargetCache.allocate(A+1);t.renderPass.setRenderTarget(T),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=x.texture,this._blurPass.uniforms.texSize[0]=x.width,this._blurPass.uniforms.texSize[1]=x.height,this._blurPass.uniforms.direction[0]=1,this._blurPass.uniforms.direction[1]=0,this._blurPass.uniforms.kernelRadius=st[A],this._blurPass.render(t);var v=n._renderTargetCache.allocate(A+1);t.renderPass.setRenderTarget(v),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blurPass.uniforms.tDiffuse=T.texture,this._blurPass.uniforms.direction[0]=0,this._blurPass.uniforms.direction[1]=1,this._blurPass.render(t),n._renderTargetCache.release(T,A+1),x=v,this._tempRTList[A]=v}t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._compositePass.uniforms.blurTexture1=this._tempRTList[0].texture,this._compositePass.uniforms.blurTexture2=this._tempRTList[1].texture,this._compositePass.uniforms.blurTexture3=this._tempRTList[2].texture,this._compositePass.uniforms.blurTexture4=this._tempRTList[3].texture,this._compositePass.uniforms.blurTexture5=this._tempRTList[4].texture,this._compositePass.uniforms.bloomRadius=this.radius,this._compositePass.uniforms.bloomStrength=this.strength,this._compositePass.render(t),t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,1),this._tempRTList.forEach((function(t,e){return n._renderTargetCache.release(t,e+1)}))},n}(l),st=[3,5,7,9,11],it={name:"ec_bloom_composite",defines:{NUM_MIPS:5},uniforms:{blurTexture1:null,blurTexture2:null,blurTexture3:null,blurTexture4:null,blurTexture5:null,bloomStrength:1,bloomRadius:0,bloomFactors:null,bloomTintColors:null},vertexShader:f,fragmentShader:"\n\t\tuniform sampler2D blurTexture1;\n\t\tuniform sampler2D blurTexture2;\n\t\tuniform sampler2D blurTexture3;\n\t\tuniform sampler2D blurTexture4;\n\t\tuniform sampler2D blurTexture5;\n\t\tuniform float bloomStrength;\n\t\tuniform float bloomRadius;\n\t\tuniform float bloomFactors[NUM_MIPS];\n\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tvarying vec2 v_Uv;\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\tgl_FragColor = bloomStrength * (\n\t\t\t\tlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, v_Uv) +\n\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, v_Uv) +\n\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, v_Uv) +\n\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, v_Uv) +\n\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, v_Uv)\n\t\t\t);\n\t\t\t\t}\n\t\t"},ot=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],n.strength=.5,n.blendRate=.4,n.blurSize=1,n._maskPass=new e.ShaderPostPass(m),n._downSamplerPass=new e.ShaderPostPass(lt),n._hBlurPass=new e.ShaderPostPass(A),n._vBlurPass=new e.ShaderPostPass(T),n._blendPass=new e.ShaderPostPass(d),n._blendPass.material.premultipliedAlpha=!0,n._tempRTList=[],n._tempRTList2=[],n}return a(n,t),n.prototype.render=function(t,n,r,a,s){for(var i=0;i<6;i++)this._tempRTList[i]=n._renderTargetCache.allocate(i),this._tempRTList2[i]=n._renderTargetCache.allocate(i);var o=n.getBuffer("SceneBuffer"),l=n.getBuffer("MarkBuffer"),f=n.getBuffer("ColorMarkBuffer"),u=l.attachManager.has(this.name),d=f.attachManager.getAttachIndex(this.name),c=f.output(d)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(u){var h=l.attachManager.getAttachIndex(this.name),_=l.attachManager.getChannelIndex(this.name);t.renderPass.setRenderTarget(this._tempRTList[0]),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=o.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=l.output(h)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=c;for(var m=0;m<4;m++)this._maskPass.uniforms.channel[m]=m===_?1:0;this._maskPass.render(t)}t.renderPass.setRenderTarget(this._tempRTList[1]),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._downSamplerPass.uniforms.tDiffuse=u?this._tempRTList[0].texture:c,this._downSamplerPass.uniforms.texSize[0]=this._tempRTList[0].width,this._downSamplerPass.uniforms.texSize[1]=this._tempRTList[0].height,this._downSamplerPass.uniforms.bright=4,this._downSamplerPass.render(t);for(var p=2;p<6;p++)t.renderPass.setRenderTarget(this._tempRTList[p]),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._downSamplerPass.uniforms.tDiffuse=this._tempRTList[p-1].texture,this._downSamplerPass.uniforms.texSize[0]=this._tempRTList[p-1].width,this._downSamplerPass.uniforms.texSize[1]=this._tempRTList[p-1].height,this._downSamplerPass.uniforms.bright=1,this._downSamplerPass.render(t);for(var x=0;x<5;x++)t.renderPass.setRenderTarget(this._tempRTList[x]),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._hBlurPass.uniforms.tDiffuse=this._tempRTList[x+1].texture,this._hBlurPass.uniforms.h=2*this.blurSize/this._tempRTList[x].width,this._hBlurPass.render(t);for(var A=0;A<5;A++)t.renderPass.setRenderTarget(this._tempRTList2[A]),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._vBlurPass.uniforms.tDiffuse=this._tempRTList[A].texture,this._vBlurPass.uniforms.v=2*this.blurSize/this._tempRTList[A].height,this._vBlurPass.render(t);for(var T=3;T>=0;T--)t.renderPass.setRenderTarget(this._tempRTList[T]),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=this._tempRTList2[T].texture,this._blendPass.uniforms.texture2=T<3?this._tempRTList[T+1].texture:this._tempRTList2[T+1].texture,this._blendPass.uniforms.colorWeight1=(1-this.blendRate)*this.strength,this._blendPass.uniforms.alphaWeight1=(1-this.blendRate)*this.strength,this._blendPass.uniforms.colorWeight2=this.blendRate*this.strength,this._blendPass.uniforms.alphaWeight2=this.blendRate*this.strength,this._blendPass.render(t);t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=this._tempRTList[0].texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),this._tempRTList.forEach((function(t,e){return n._renderTargetCache.release(t,e)})),this._tempRTList2.forEach((function(t,e){return n._renderTargetCache.release(t,e)}))},n}(l),lt={name:"ec_sg_downsample",defines:{},uniforms:{tDiffuse:null,texSize:[512,512],bright:1},vertexShader:f,fragmentShader:"\n\t\tvarying vec2 v_Uv;\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 texSize;\n\t\n\t\tuniform float bright;\n\t\t\n\t\tvoid main() {\n\t\t\t\tvec4 d = vec4(-1.0, -1.0, 1.0, 1.0) / texSize.xyxy;\n\t\t\tgl_FragColor = (texture2D(tDiffuse, v_Uv + d.xy) +\n\t\t\t\ttexture2D(tDiffuse, v_Uv + d.zy) +\n\t\t\t\ttexture2D(tDiffuse, v_Uv + d.xw) +\n\t\t\t\ttexture2D(tDiffuse, v_Uv + d.zw)) * bright * 0.25;\n\t\t}\n\t"},ft=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],n.center=new e.Vector2(.5,.5),n.direction=new e.Vector2(0,1),n.strength=1,n._maskPass=new e.ShaderPostPass(m),n._tailingPass=new e.ShaderPostPass(ut),n._blendPass=new e.ShaderPostPass(d),n._blendPass.material.premultipliedAlpha=!0,n}return a(n,t),n.prototype.render=function(t,n,r,a,s){var i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("MarkBuffer"),u=n.getBuffer("ColorMarkBuffer"),d=f.attachManager.has(this.name),c=u.attachManager.getAttachIndex(this.name),h=u.output(c)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(d){var _=f.attachManager.getAttachIndex(this.name),m=f.attachManager.getChannelIndex(this.name);t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=f.output(_)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=h;for(var p=0;p<4;p++)this._maskPass.uniforms.channel[p]=p===m?1:0;this._maskPass.render(t)}t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._tailingPass.uniforms.blurMap=d?i.texture:h,this._tailingPass.uniforms.center[0]=this.center.x,this._tailingPass.uniforms.center[1]=this.center.y,this._tailingPass.uniforms.direction[0]=this.direction.x,this._tailingPass.uniforms.direction[1]=this.direction.y,this._tailingPass.uniforms.intensity=10*this.strength,this._tailingPass.render(t),t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)},n}(l),ut={name:"ec_tailing",defines:{},uniforms:{blurMap:null,blurStart:1,blurWidth:-.1,direction:[0,1],intensity:10,glowGamma:.8,center:[.5,.5]},vertexShader:f,fragmentShader:"\n\t\tvarying vec2 v_Uv;\n\t\tuniform sampler2D blurMap;\n\t\tuniform float blurStart;\n\t\tuniform float blurWidth;\n\t\tuniform vec2 direction;\n\t\tuniform float intensity;\n\t\tuniform float glowGamma;\n\t\tuniform vec2 center;\n\n\t\tvoid main() {\n\t\t\tvec2 texCoord = v_Uv;\n\t\t\tvec4 blurred = texture2D(blurMap, texCoord);\n\t\t\tvec2 resCoord = vec2(0.0);\n\n\t\t\tfor(float i = 0.0; i < 31.0; i++) {\n\t\t\t\tfloat scale = blurStart + blurWidth * ((31.0 - i) / (31.0 - 1.0));\n\t\t\t\tvec2 tmp = texCoord * scale;\n\t\t\t\tresCoord = mix(texCoord, tmp, direction);\n\t\t\t\tvec4 tmpc = texture2D(blurMap, resCoord) * (i / 31.0) * (i / 31.0);\n\t\t\t\tblurred += tmpc / 31.0;\n\t\t\t}\n\n\t\t\tblurred.r = pow(blurred.r, glowGamma);\n\t\t\tblurred.g = pow(blurred.g, glowGamma);\n\t\t\tblurred.b = pow(blurred.b, glowGamma);\n\t\t\tblurred.rgb *= intensity;\n\t\t\tblurred.rgb = clamp(blurred.rgb, 0.0, 1.0);\n\n\t\t\tvec4 origTex = texture2D(blurMap, texCoord);\n\t\t\tvec4 blurResult = origTex + blurred;\n\t\t\t// blurResult *= 2;\n\n\t\t\tvec2 dir = texCoord - center;\n\t\t\tfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\n\t\t\tfloat t = dist * 1.0;\n\t\t\tt = clamp(t, 0.0, 1.0); // We need 0 <= t <= 1\n\n\t\t\tgl_FragColor = blurResult * t;\n\t\t}\n\t\t"},dt=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],n.center=new e.Vector2(.5,.5),n.strength=1,n._maskPass=new e.ShaderPostPass(m),n._radialTailingPass=new e.ShaderPostPass(ct),n._blendPass=new e.ShaderPostPass(d),n._blendPass.material.premultipliedAlpha=!0,n}return a(n,t),n.prototype.render=function(t,n,r,a,s){var i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("MarkBuffer"),u=n.getBuffer("ColorMarkBuffer"),d=f.attachManager.has(this.name),c=u.attachManager.getAttachIndex(this.name),h=u.output(c)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(d){var _=f.attachManager.getAttachIndex(this.name),m=f.attachManager.getChannelIndex(this.name);t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=f.output(_)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=h;for(var p=0;p<4;p++)this._maskPass.uniforms.channel[p]=p===m?1:0;this._maskPass.render(t)}t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._radialTailingPass.uniforms.blurMap=d?i.texture:h,this._radialTailingPass.uniforms.center[0]=this.center.x,this._radialTailingPass.uniforms.center[1]=this.center.y,this._radialTailingPass.uniforms.intensity=10*this.strength,this._radialTailingPass.render(t),t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)},n}(l),ct={name:"ec_radial_tailing",defines:{},uniforms:{blurMap:null,blurStart:1,blurWidth:-.1,intensity:10,glowGamma:.8,center:[.5,.5]},vertexShader:f,fragmentShader:"\n\t\tvarying vec2 v_Uv;\n\t\tuniform sampler2D blurMap;\n\t\tuniform float blurStart;\n\t\tuniform float blurWidth;\n\t\tuniform float intensity;\n\t\tuniform float glowGamma;\n\t\tuniform vec2 center;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 texCoord = v_Uv;\n\t\t\tvec2 ctrPt = center;\n\t\t\tvec4 blurred = texture2D(blurMap, texCoord);\n\t\t\n\t\t\tfor(float i = 0.0; i < 31.0; i++) {\n\t\t\t\tfloat scale = blurStart + blurWidth * ((31.0 - i) / (31.0 - 1.0));\n\t\t\t\tvec2 tmp = (texCoord - ctrPt) * scale + ctrPt;\n\t\t\t\tvec4 tmpc = texture2D(blurMap, tmp) * (i / 31.0) * (i / 31.0);\n\t\t\n\t\t\t\tblurred += tmpc / 31.0;\n\t\t\t}\n\t\t\n\t\t\tblurred.r = pow(blurred.r, glowGamma);\n\t\t\tblurred.g = pow(blurred.g, glowGamma);\n\t\t\tblurred.b = pow(blurred.b, glowGamma);\n\t\t\tblurred.rgb *= intensity;\n\t\t\tblurred.rgb = clamp(blurred.rgb, 0.0, 1.0);\n\t\t\n\t\t\tvec4 origTex = texture2D(blurMap, texCoord);\n\t\t\tvec4 blurResult = origTex + blurred;\n\t\t\t// blurResult *= 2;\n\t\t\n\t\t\tvec2 dir = texCoord - ctrPt;\n\t\t\tfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\n\t\t\tfloat t = dist * 1.0;\n\t\t\tt = clamp(t, 0.0, 1.0); // We need 0 <= t <= 1\n\t\t\n\t\t\tgl_FragColor = blurResult * t;\n\t\t}\n\t\t"},ht=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=[{key:"SceneBuffer"},{key:"MarkBuffer",mask:P.OPAQUE},{key:"ColorMarkBuffer",mask:P.TRANSPARENT}],n.center=new e.Vector2(.5,.5),n.strength=1,n._maskPass=new e.ShaderPostPass(m),n._ghostingPass=new e.ShaderPostPass(_t),n._blendPass=new e.ShaderPostPass(d),n._blendPass.material.premultipliedAlpha=!0,n}return a(n,t),n.prototype.render=function(t,n,r,a,s){var i=n._renderTargetCache.allocate(0),o=n._renderTargetCache.allocate(0),l=n.getBuffer("SceneBuffer"),f=n.getBuffer("MarkBuffer"),u=n.getBuffer("ColorMarkBuffer"),d=f.attachManager.has(this.name),c=u.attachManager.getAttachIndex(this.name),h=u.output(c)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];if(d){var _=f.attachManager.getAttachIndex(this.name),m=f.attachManager.getChannelIndex(this.name);t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._maskPass.uniforms.colorTexture=l.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.maskTexture=f.output(_)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._maskPass.uniforms.additiveTexture=h;for(var p=0;p<4;p++)this._maskPass.uniforms.channel[p]=p===m?1:0;this._maskPass.render(t)}t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1),this._ghostingPass.uniforms.blurMap=d?i.texture:h,this._ghostingPass.uniforms.center[0]=this.center.x,this._ghostingPass.uniforms.center[1]=this.center.y,this._ghostingPass.uniforms.intensity=3*this.strength,this._ghostingPass.render(t),t.renderPass.setRenderTarget(a),t.renderPass.setClearColor(0,0,0,0),s?t.renderPass.clear(n.clearColor,n.clearDepth,n.clearStencil):t.renderPass.clear(!0,!0,!1),this._blendPass.uniforms.texture1=r.texture,this._blendPass.uniforms.texture2=o.texture,this._blendPass.uniforms.colorWeight1=1,this._blendPass.uniforms.alphaWeight1=1,this._blendPass.uniforms.colorWeight2=1,this._blendPass.uniforms.alphaWeight2=0,s&&(this._blendPass.material.transparent=n._tempClearColor[3]<1||!n.clearColor,this._blendPass.renderStates.camera.rect.fromArray(n._tempViewport)),this._blendPass.render(t),s&&(this._blendPass.material.transparent=!1,this._blendPass.renderStates.camera.rect.set(0,0,1,1)),n._renderTargetCache.release(i,0),n._renderTargetCache.release(o,0)},n}(l),_t={name:"ec_ghosting",defines:{},uniforms:{blurMap:null,blurStart:1,blurWidth:-.1,intensity:3,glowGamma:.8,center:[.5,.5]},vertexShader:f,fragmentShader:"\n\t\tvarying vec2 v_Uv;\n\t\tuniform sampler2D blurMap;\n\t\tuniform float blurStart;\n\t\tuniform float blurWidth;\n\t\tuniform float intensity;\n\t\tuniform float glowGamma;\n\t\tuniform vec2 center;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 uv = v_Uv;\n\t\t\tvec2 ctrPt = center;\n\t\t\n\t\t\tfloat scale = blurStart + blurWidth * 1.0;\n\t\t\tvec2 tmp = (uv - ctrPt) * scale + ctrPt;\n\n\t\t\tvec4 blurred = texture2D(blurMap, tmp);\n\t\t\tblurred.rgb = pow(blurred.rgb, vec3(glowGamma));\n\t\t\tblurred.rgb *= intensity;\n\t\t\tblurred.rgb = clamp(blurred.rgb, 0.0, 1.0);\n\t\t\t\n\t\t\tvec2 dir = uv - ctrPt;\n\t\t\tfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\n\t\t\n\t\t\tgl_FragColor = blurred * clamp(dist, 0.0, 1.0);\n\t\t}\n\t\t"},mt=function(t){function n(n,r,a){var s;(s=t.call(this,n,r,a)||this)._rt=new e.RenderTarget2D(n,r),s._rt.texture.minFilter=e.TEXTURE_FILTER.NEAREST,s._rt.texture.magFilter=e.TEXTURE_FILTER.NEAREST,s._rt.texture.generateMipmaps=!1,a.floatColorBuffer?s._rt.texture.type=e.PIXEL_TYPE.FLOAT:s._rt.texture.type=e.PIXEL_TYPE.HALF_FLOAT;var i=new e.Texture2D;return i.image={data:null,width:n,height:r},i.type=e.PIXEL_TYPE.UNSIGNED_INT_24_8,i.format=e.PIXEL_FORMAT.DEPTH_STENCIL,i.magFilter=e.TEXTURE_FILTER.NEAREST,i.minFilter=e.TEXTURE_FILTER.NEAREST,i.generateMipmaps=!1,i.flipY=!1,s._rt.attach(i,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),s._renderOptions={getMaterial:pt(),ifRender:function(t){return!!t.geometry.getAttribute("a_Normal")}},s._renderStates=null,s.layers=[0],s}a(n,t);var r=n.prototype;return r.setGeometryReplaceFunction=function(t){t?this._renderOptions.getGeometry=t:delete this._renderOptions.getGeometry},r.setMaterialReplaceFunction=function(t){this._renderOptions.getMaterial=t?pt(t):pt()},r.render=function(t,e,n,r){if(this.needRender()){t.renderPass.setRenderTarget(this._rt),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!0,!1);var a=this._renderOptions,s=n.getRenderStates(r),i=n.getRenderQueue(r);this._renderStates=s;for(var o=this.layers,l=0,f=o.length;l<f;l++){var u=i.getLayer(o[l]);t.renderRenderableList(u.opaque,s,a),t.renderRenderableList(u.transparent,s,a)}}},r.output=function(){return this._rt},r.getCurrentRenderStates=function(){return this._renderStates},r.resize=function(e,n){t.prototype.resize.call(this,e,n),this._rt.resize(e,n)},r.dispose=function(){t.prototype.dispose.call(this),this._rt.dispose()},n}(n);function pt(t){return void 0===t&&(t=Tt),function(e){var n=t(e);return n.diffuseMap=e.material.diffuseMap,n.uniforms.roughness=void 0!==e.material.roughness?e.material.roughness:.5,n.roughnessMap=e.material.roughnessMap,n.side=e.material.side,n}}var xt=new Map,At=new WeakMap;function Tt(t){var n=At.get(t.material);if(!n){var r=!t.geometry.attributes.a_Normal||t.material.shading===e.SHADING_TYPE.FLAT_SHADING,a=!!t.material.diffuseMap,s=!!t.material.roughnessMap,i=t.object.isSkinnedMesh&&t.object.skeleton,o=!!t.object.morphTargetInfluences,l=!!t.object.morphTargetInfluences&&t.object.geometry.morphAttributes.normal,f=t.material.side,u=0;i&&(u=t.object.skeleton.boneTexture?1024:t.object.skeleton.bones.length);var d=r+"_"+a+"_"+s+"_"+i+"_"+u+"_"+o+"_"+l+"_"+f;if(!(n=xt.get(d))){var c=new e.ShaderMaterial(vt);c.shading=r?e.SHADING_TYPE.FLAT_SHADING:e.SHADING_TYPE.SMOOTH_SHADING,c.alphaTest=a?.999:0,c.side=f,n={refCount:0,material:c},xt.set(d,n)}At.set(t.material,n),n.refCount++,t.material.addEventListener("dispose",(function e(){t.material.removeEventListener("dispose",e),At.delete(t.material),n.refCount--,n.refCount<=0&&xt.delete(d)}))}return n.material}var vt={name:"ec_gbuffer_ng",defines:{G_USE_ROUGHNESSMAP:!1},uniforms:{roughness:.5,roughnessMap:null},vertexShader:"\n\t\t\t\t#include <common_vert>\n\t\t\t\t#include <morphtarget_pars_vert>\n\t\t\t\t#include <skinning_pars_vert>\n\t\t\t\t#include <normal_pars_vert>\n\t\t\t\t#include <uv_pars_vert>\n\t\t#include <logdepthbuf_pars_vert>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <uv_vert>\n\t\t\t\t\t#include <begin_vert>\n\t\t\t\t\t#include <morphtarget_vert>\n\t\t\t\t\t#include <morphnormal_vert>\n\t\t\t\t\t#include <skinning_vert>\n\t\t\t\t\t#include <skinnormal_vert>\n\t\t\t\t\t#include <normal_vert>\n\t\t\t\t\t#include <pvm_vert>\n\t\t\t#include <logdepthbuf_vert>\n\t\t\t\t}\n\t\t",fragmentShader:"\n\t\t\t\t#include <common_frag>\n\t\t\t\t#include <diffuseMap_pars_frag>\n\n\t\t\t\t#include <uv_pars_frag>\n\n\t\t\t\t#include <packing>\n\t\t\t\t#include <normal_pars_frag>\n\n\t\t\t\tuniform float roughness;\n\n\t\t\t\t#ifdef USE_ROUGHNESSMAP\n\t\t\t\t\t\tuniform sampler2D roughnessMap;\n\t\t\t\t#endif\n\n\t\t#include <logdepthbuf_pars_frag>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\t#if defined(USE_DIFFUSE_MAP) && defined(ALPHATEST)\n\t\t\t\t\t\t\t\tvec4 texelColor = texture2D(diffuseMap, v_Uv);\n\t\t\t\t\t\t\t\tfloat alpha = texelColor.a * u_Opacity;\n\t\t\t\t\t\t\t\tif(alpha < ALPHATEST) discard;\n\t\t\t\t\t\t#endif\n\n\t\t\t#include <logdepthbuf_frag>\n\n\t\t\t\t\t\tvec3 normal = normalize(v_Normal);\n\n\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\tnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t\t#endif \n\n\t\t\t\t\t\tfloat roughnessFactor = roughness;\n\t\t\t\t\t\t#ifdef USE_ROUGHNESSMAP\n\t\t\t\t\t\t\t\troughnessFactor *= texture2D(roughnessMap, v_Uv).g;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tvec4 packedNormalGlossiness;\n\t\t\t\t\t\tpackedNormalGlossiness.xyz = normal * 0.5 + 0.5;\n\t\t\t\t\t\tpackedNormalGlossiness.w = clamp(1. - roughnessFactor, 0., 1.);\n\t\t\t\t\t\t\n\t\t\t\t\t\tgl_FragColor = packedNormalGlossiness;\n\t\t\t\t}\n\t\t"},Pt=function(){function t(t){this.keys=new Array,this.masks=new Array,this.attachChannelSize=t}var e=t.prototype;return e.allocate=function(t,e){return void 0===e&&(e=P.ALL),this.keys.push(t),this.masks.push(e),this.keys.length-1},e.getAttachIndex=function(t){var e=this.keys.indexOf(t);return Math.max(0,Math.floor(e/this.attachChannelSize))},e.getChannelIndex=function(t){var e=this.keys.indexOf(t);return Math.max(0,e%this.attachChannelSize)},e.has=function(t){return this.keys.indexOf(t)>-1},e.count=function(){return this.keys.length},e.attachCount=function(){return Math.ceil(this.keys.length/this.attachChannelSize)},e.getKey=function(t,e){return this.keys[t*this.attachChannelSize+e]},e.getMask=function(t,e){return this.masks[t*this.attachChannelSize+e]},e.getAttachInfo=function(t,e){void 0===e&&(e={count:0,keys:[],masks:[]}),e.count=0;for(var n=0;n<this.attachChannelSize;n++){var r=this.getKey(t,n),a=this.getMask(t,n);void 0!==r&&void 0!==a&&(e.keys[e.count]=r,e.masks[e.count]=a,e.count++)}return e},e.reset=function(){this.keys.length=0,this.masks.length=0},t}(),gt=function(t){function n(n,r,a){var s;(s=t.call(this,n,r,a)||this)._rts=[];for(var i=0;i<a.maxMarkAttachment;i++){var o=new e.RenderTarget2D(n,r);o.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),s._rts.push(o)}s._mrts=[];for(var l=0;l<a.maxMarkAttachment;l++){var f=new e.RenderTarget2D(n,r);f.attach(new e.RenderBuffer(n,r,e.PIXEL_FORMAT.RGBA8,a.samplerNumber),e.ATTACHMENT.COLOR_ATTACHMENT0),f.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),s._mrts.push(f)}s._state={attachIndex:0,attachInfo:{count:0,keys:[],masks:[]}};var u=new Pt(4);return s._opacityRenderOptions={getMaterial:Et(void 0,s._state,u,P.OPAQUE),ifRender:Ft(s._state,P.OPAQUE)},s._transparentRenderOptions={getMaterial:Et(void 0,s._state,u,P.TRANSPARENT),ifRender:Ft(s._state,P.TRANSPARENT)},s.attachManager=u,s.layers=[0],s}a(n,t);var r=n.prototype;return r.setGeometryReplaceFunction=function(t){t?(this._opacityRenderOptions.getGeometry=t,this._transparentRenderOptions.getGeometry=t):(delete this._opacityRenderOptions.getGeometry,delete this._transparentRenderOptions.getGeometry)},r.setMaterialReplaceFunction=function(t){t?(this._opacityRenderOptions.getMaterial=Et(t,this._state,this.attachManager,P.OPAQUE),this._transparentRenderOptions.getMaterial=Et(t,this._state,this.attachManager,P.TRANSPARENT)):(this._opacityRenderOptions.getMaterial=Et(void 0,this._state,this.attachManager,P.OPAQUE),this._transparentRenderOptions.getMaterial=Et(void 0,this._state,this.attachManager,P.TRANSPARENT))},r.render=function(t,e,n,r){if(this.needRender()){var a=this.attachManager.attachCount();a>this._rts.length&&console.error("XXMarkBuffer: attachCount<"+a+"> bigger then options.maxMarkAttachment<"+this._rts.length+">.");for(var s=0;s<a;s++){var i=this._rts[s],o=this._mrts[s];e.$useMSAA?(t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!1,!1)):(t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!1,!1));var l=n.getRenderStates(r),f=n.getRenderQueue(r);this._state.attachIndex=s,this.attachManager.getAttachInfo(s,this._state.attachInfo);for(var u=0,d=this._state.attachInfo.masks,c=this._state.attachInfo.count,h=0;h<c;h++)u|=d[h];for(var _=this.layers,m=0,p=_.length;m<p;m++){var x=f.getLayer(_[m]);u&P.OPAQUE&&t.renderRenderableList(x.opaque,l,this._opacityRenderOptions),u&P.TRANSPARENT&&t.renderRenderableList(x.transparent,l,this._transparentRenderOptions)}e.$useMSAA&&(t.renderPass.setRenderTarget(i),t.renderPass.blitRenderTarget(o,i,!0,!1,!1)),t.renderPass.updateRenderTargetMipmap(i)}}},r.output=function(t){return void 0===t&&(t=0),this._rts[t]},r.resize=function(e,n){t.prototype.resize.call(this,e,n),this._rts.forEach((function(t){return t.resize(e,n)})),this._mrts.forEach((function(t){return t.resize(e,n)}))},r.dispose=function(){t.prototype.dispose.call(this),this._rts.forEach((function(t){return t.dispose()})),this._mrts.forEach((function(t){return t.dispose()}))},n}(n);function Et(t,n,r,a){return void 0===t&&(t=bt),function(s){var i=t(s);i.side=e.DRAW_SIDE.DOUBLE;for(var o=0;o<4;o++){var l=r.getKey(n.attachIndex,o),f=r.getMask(n.attachIndex,o);i.uniforms.mColor[o]=f&a&&s.object.effects[l]||0}return i}}function Ft(t,e){return function(n){if(!n.object.effects)return!1;for(var r=0,a=0;a<t.attachInfo.count;a++){var s=t.attachInfo.keys[a];n.object.effects[s]&&(r|=t.attachInfo.masks[a])}return r&e}}var St=new Map;function bt(t){var n,r=t.object.isSkinnedMesh&&t.object.skeleton,a=!!t.object.morphTargetInfluences,s=t.material.drawMode,i=r+"_"+a+"_"+s;return St.has(i)?n=St.get(i):((n=new e.ShaderMaterial(Nt)).premultipliedAlpha=!0,n.transparent=!0,n.blending=e.BLEND_TYPE.ADD,n.drawMode=s,St.set(i,n)),n}var Nt={name:"ec_mark",defines:{},uniforms:{mColor:[1,1,1,1]},vertexShader:"\n\t\t\t\t#include <common_vert>\n\t\t\t\t#include <morphtarget_pars_vert>\n\t\t\t\t#include <skinning_pars_vert>\n\t\t\t\t#include <uv_pars_vert>\n\t\t#include <logdepthbuf_pars_vert>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <uv_vert>\n\t\t\t\t\t#include <begin_vert>\n\t\t\t\t\t#include <morphtarget_vert>\n\t\t\t\t\t#include <skinning_vert>\n\t\t\t\t\t#include <pvm_vert>\n\t\t\t#include <logdepthbuf_vert>\n\t\t\t\t}\n\t\t",fragmentShader:"\n\t\t\t\t#include <common_frag>\n\t\t\t\t#include <diffuseMap_pars_frag>\n\n\t\t\t\t#include <uv_pars_frag>\n\n\t\t#include <logdepthbuf_pars_frag>\n\n\t\tuniform vec4 mColor;\n\n\t\t\t\tvoid main() {\n\t\t\t#include <logdepthbuf_frag>\n\t\t\t\n\t\t\t\t\t\t#if defined(USE_DIFFUSE_MAP) && defined(ALPHATEST)\n\t\t\t\t\t\t\t\tvec4 texelColor = texture2D(diffuseMap, v_Uv);\n\t\t\t\t\t\t\t\tfloat alpha = texelColor.a * u_Opacity;\n\t\t\t\t\t\t\t\tif(alpha < ALPHATEST) discard;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tgl_FragColor = mColor;\n\t\t\t\t}\n\t\t"},yt=function(t){function n(e,n,r){return t.call(this,e,n,r)||this}return a(n,t),n.prototype.syncDepthAttachments=function(t,n){this._rts.forEach((function(t){return t.dispose()})),this._mrts.forEach((function(t){return t.dispose()})),v(t)?this._rts.forEach((function(n){n.attach(t,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),n.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)})):this._rts.forEach((function(n){n.attach(t,e.ATTACHMENT.DEPTH_ATTACHMENT),n.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)})),v(n)?this._mrts.forEach((function(t){t.attach(n,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),t.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)})):this._mrts.forEach((function(t){t.attach(n,e.ATTACHMENT.DEPTH_ATTACHMENT),t.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)})),this.needsUpdate=!0},n}(gt),Ct=function(t){function n(n,r,a){var s;(s=t.call(this,n,r,a)||this)._rts=[];for(var i=0;i<a.maxColorAttachment;i++){var o=new e.RenderTarget2D(n,r);o.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),s._rts.push(o)}s._mrts=[];for(var l=0;l<a.maxColorAttachment;l++){var f=new e.RenderTarget2D(n,r);f.attach(new e.RenderBuffer(n,r,e.PIXEL_FORMAT.RGBA8,a.samplerNumber),e.ATTACHMENT.COLOR_ATTACHMENT0),f.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),s._mrts.push(f)}var u={key:null};s._state=u;var d=new Pt(1);return s._renderOptions={getMaterial:Lt(void 0,u),ifRender:function(t){return!!t.object.effects&&!!t.object.effects[u.key]}},s.attachManager=d,s.layers=[0],s}a(n,t);var r=n.prototype;return r.setGeometryReplaceFunction=function(t){t?this._renderOptions.getGeometry=t:delete this._renderOptions.getGeometry},r.setMaterialReplaceFunction=function(t){this._renderOptions.getMaterial=Lt(t||void 0,this._state)},r.syncDepthAttachments=function(t,n){this._rts.forEach((function(t){return t.dispose()})),this._mrts.forEach((function(t){return t.dispose()})),v(t)?this._rts.forEach((function(n){n.attach(t,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),n.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)})):this._rts.forEach((function(n){n.attach(t,e.ATTACHMENT.DEPTH_ATTACHMENT),n.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)})),v(n)?this._mrts.forEach((function(t){t.attach(n,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),t.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)})):this._mrts.forEach((function(t){t.attach(n,e.ATTACHMENT.DEPTH_ATTACHMENT),t.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)})),this.needsUpdate=!0},r.render=function(t,e,n,r){if(this.needRender()){var a=this.attachManager.attachCount();a>this._rts.length&&console.error("ColorMarkBuffer: attachCount<"+a+"> bigger then options.maxColorAttachment<"+this._rts.length+">.");for(var s=0;s<a;s++){var i=this._rts[s],o=this._mrts[s];e.$useMSAA?(t.renderPass.setRenderTarget(o),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!1,!1)):(t.renderPass.setRenderTarget(i),t.renderPass.setClearColor(0,0,0,0),t.renderPass.clear(!0,!1,!1));var l=this._renderOptions,f=this.attachManager,u=n.getRenderStates(r),d=n.getRenderQueue(r);this._state.key=f.getKey(s,0);for(var c=f.getMask(s,0),h=this.layers,_=0,m=h.length;_<m;_++){var p=d.getLayer(h[_]);c&P.OPAQUE&&t.renderRenderableList(p.opaque,u,l),c&P.TRANSPARENT&&t.renderRenderableList(p.transparent,u,l)}e.$useMSAA&&(t.renderPass.setRenderTarget(i),t.renderPass.blitRenderTarget(o,i,!0,!1,!1)),t.renderPass.updateRenderTargetMipmap(i)}}},r.output=function(t){return void 0===t&&(t=0),this._rts[t]},r.resize=function(e,n){t.prototype.resize.call(this,e,n),this._rts.forEach((function(t){return t.resize(e,n)})),this._mrts.forEach((function(t){return t.resize(e,n)}))},r.dispose=function(){t.prototype.dispose.call(this),this._rts.forEach((function(t){return t.dispose()})),this._mrts.forEach((function(t){return t.dispose()}))},n}(n);function Lt(t,n){return void 0===t&&(t=Dt),function(r){var a=t(r);return a.side=e.DRAW_SIDE.DOUBLE,a.uniforms.strength=r.object.effects[n.key]||0,a}}var It=new Map;function Dt(t){var n,r=t.object.isSkinnedMesh&&t.object.skeleton,a=!!t.object.morphTargetInfluences,s=t.material.drawMode,i=r+"_"+a+"_"+s+!!t.material.diffuseMap;return It.has(i)?n=It.get(i):((n=new e.ShaderMaterial(Mt)).premultipliedAlpha=!1,n.drawMode=s,It.set(i,n)),n.transparent=t.material.transparent,n.blending=t.material.blending,n.opacity=t.material.opacity,n.diffuse.copy(t.material.diffuse),n.diffuseMap=t.material.diffuseMap,n}var Mt={name:"ec_color",defines:{},uniforms:{strength:1},vertexShader:"\n\t\t\t\t#include <common_vert>\n\t\t\t\t#include <morphtarget_pars_vert>\n\t\t\t\t#include <skinning_pars_vert>\n\t\t\t\t#include <uv_pars_vert>\n\t\t#include <logdepthbuf_pars_vert>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <uv_vert>\n\t\t\t\t\t#include <begin_vert>\n\t\t\t\t\t#include <morphtarget_vert>\n\t\t\t\t\t#include <skinning_vert>\n\t\t\t\t\t#include <pvm_vert>\n\t\t\t#include <logdepthbuf_vert>\n\t\t\t\t}\n\t\t",fragmentShader:"\n\t\t\t\t#include <common_frag>\n\t\t\t\t#include <diffuseMap_pars_frag>\n\n\t\t\t\t#include <uv_pars_frag>\n\n\t\t#include <logdepthbuf_pars_frag>\n\n\t\tuniform float strength;\n\n\t\t\t\tvoid main() {\n\t\t\t#include <logdepthbuf_frag>\n\n\t\t\tvec4 outColor = vec4(u_Color, u_Opacity);\n\n\t\t\t#ifdef USE_DIFFUSE_MAP\n\t\t\t\toutColor *= texture2D(diffuseMap, v_Uv);\n\t\t\t#endif\n\n\t\t\t#ifdef ALPHATEST\n\t\t\t\tif(outColor.a < ALPHATEST) discard;\n\t\t\t#endif\n\n\t\t\toutColor.a *= strength;\n\n\t\t\t\t\t\tgl_FragColor = outColor;\n\t\t\t\t}\n\t\t"},Rt=function(t){function n(n,r,a){var s;return(s=t.call(this,n,r,a)||this)._rt=new e.RenderTarget2D(n,r),s._rt.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),s._mrt=new e.RenderTarget2D(n,r),s._mrt.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),s.clearColor=!0,s.clearDepth=!0,s.clearStencil=!0,s.renderLayers=[{id:0,mask:P.ALL}],s._sceneRenderOptions={},s}a(n,t);var r=n.prototype;return r.syncAttachments=function(t,n,r,a){this._rt.dispose(),this._mrt.dispose(),this._rt.attach(t,e.ATTACHMENT.COLOR_ATTACHMENT0),v(n)?(this._rt.attach(n,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),this._rt.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)):(this._rt.attach(n,e.ATTACHMENT.DEPTH_ATTACHMENT),this._rt.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)),this._mrt.attach(r,e.ATTACHMENT.COLOR_ATTACHMENT0),v(a)?(this._mrt.attach(a,e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),this._mrt.detach(e.ATTACHMENT.DEPTH_ATTACHMENT)):(this._mrt.attach(a,e.ATTACHMENT.DEPTH_ATTACHMENT),this._mrt.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT)),this.needsUpdate=!0},r.setGeometryReplaceFunction=function(t){t?this._sceneRenderOptions.getGeometry=t:delete this._sceneRenderOptions.getGeometry},r.setOutputEncoding=function(t){this._rt.texture.encoding=t},r.getOutputEncoding=function(){return this._rt.texture.encoding},r.render=function(t,n,r,a){if(this.needRender()){var s,i=n.$useMSAA,o=i?this._mrt:this._rt,l=!!o._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT];if(t.renderPass.setRenderTarget(o),n.clearColor)(s=t.renderPass).setClearColor.apply(s,n._tempClearColor);else t.renderPass.setClearColor(0,0,0,0);t.renderPass.clear(this.clearColor,this.clearDepth,this.clearStencil&&l);var f=r.getRenderStates(a),u=r.getRenderQueue(a);this.$renderScene(t,u,f),i&&(t.renderPass.setRenderTarget(this._rt),t.renderPass.blitRenderTarget(this._mrt,this._rt,!0,!0,l)),t.renderPass.updateRenderTargetMipmap(this._rt)}},r.output=function(){return this._rt},r.resize=function(e,n){t.prototype.resize.call(this,e,n),this._rt.resize(e,n),this._mrt.resize(e,n)},r.dispose=function(){t.prototype.dispose.call(this),this._rt.dispose(),this._mrt.dispose()},r.$renderScene=function(t,e,n){for(var r=this._sceneRenderOptions,a=this.renderLayers,s=0,i=a.length;s<i;s++){var o=a[s],l=o.id,f=o.mask,u=o.options,d=void 0===u?r:u,c=e.getLayer(l);c&&(c.opaqueCount>0&&f&P.OPAQUE&&t.renderRenderableList(c.opaque,n,d),c.transparentCount>0&&f&P.TRANSPARENT&&t.renderRenderableList(c.transparent,n,d))}var h=e.getLayer(1);h&&h.opaqueCount+h.transparentCount>0&&(t.renderPass.clear(!1,!0,!1),t.renderRenderableList(h.opaque,n,r),t.renderRenderableList(h.transparent,n,r))},n}(n),Ut=function(){function t(t,e){this._width=t,this._height=e,this._map=new Map}var n=t.prototype;return n.allocate=function(t){void 0===t&&(t=0);var n=this._map.get(t);if(n||(n=[],this._map.set(t,n)),n.length>0)return n.shift();var r=Math.pow(2,t),a=Math.ceil(this._width/r),s=Math.ceil(this._height/r),i=new e.RenderTarget2D(a,s),o=i._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];return o.minFilter=e.TEXTURE_FILTER.LINEAR,o.magFilter=e.TEXTURE_FILTER.LINEAR,o.format=e.PIXEL_FORMAT.RGBA,o.generateMipmaps=!1,i.detach(e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT),i},n.release=function(t,e){void 0===e&&(e=0),this._map.get(e).push(t)},n.resize=function(t,e){var n=this;this._width=t,this._height=e,this._map.forEach((function(t,e){var r=Math.pow(2,e),a=Math.ceil(n._width/r),s=Math.ceil(n._height/r);t.forEach((function(t){t.resize(a,s)}))}))},n.updateStats=function(t){var e=0;this._map.forEach((function(t,n){var r=Math.pow(2,n);e+=t.length/(r*r)})),t.fboCache=e},n.dispose=function(){this._map.forEach((function(t){t.forEach((function(t){t.dispose()}))})),this._map.clear()},t}(),Ot=function(){function t(t,n,r){void 0===r&&(r={}),this._size=new e.Vector2(t,n),r.webgl2=r.webgl2||!1,r.floatColorBuffer=r.floatColorBuffer||!1,r.samplerNumber=r.samplerNumber||8,r.maxMarkAttachment=r.maxMarkAttachment||5,r.maxColorAttachment=r.maxColorAttachment||5;var a=new Rt(t,n,r),s=new mt(t,n,r),i=new gt(t,n,r),o=new yt(t,n,r),l=new Ct(t,n,r);this._bufferMap=new Map([["SceneBuffer",a],["GBuffer",s],["NonDepthMarkBuffer",i],["MarkBuffer",o],["ColorMarkBuffer",l]]),this._defaultColorTexture=new e.Texture2D,this._defaultMSColorRenderBuffer=new e.RenderBuffer(t,n,e.PIXEL_FORMAT.RGBA8,r.samplerNumber),this._defaultDepthRenderBuffer=new e.RenderBuffer(t,n,e.PIXEL_FORMAT.DEPTH_COMPONENT16),this._defaultMSDepthRenderBuffer=new e.RenderBuffer(t,n,e.PIXEL_FORMAT.DEPTH_COMPONENT16,r.samplerNumber),this._defaultDepthStencilRenderBuffer=new e.RenderBuffer(t,n,e.PIXEL_FORMAT.DEPTH_STENCIL),this._defaultMSDepthStencilRenderBuffer=new e.RenderBuffer(t,n,e.PIXEL_FORMAT.DEPTH24_STENCIL8,r.samplerNumber),this._externalColorAttachment=null,this._externalDepthAttachment=null,this._samplerNumber=r.samplerNumber,this._externalMSAA=null,this._stencilBuffer=!1,this._syncAttachments(),this._renderTargetCache=new Ut(t,n),this._effectList=[],this._tempClearColor=[0,0,0,1],this._tempViewport=[0,0,1,1],this._tempBufferNames=new Set,this._stats={fboCache:0,markBuffers:0,colorMarkBuffers:0,currentBufferUsage:{}},this.sceneMSAA=!1,this.clearColor=!0,this.clearDepth=!0,this.clearStencil=!1,this.debugger=null}var n,a,s,i=t.prototype;return i.getSize=function(){return this._size},i._syncAttachments=function(){var t=this._externalColorAttachment,e=this._externalDepthAttachment,n=!!t&&!!e,r=this._externalMSAA,a=this._stencilBuffer;n&&(a=v(e));var s,i,o,l,f,u,d=a?this._defaultDepthStencilRenderBuffer:this._defaultDepthRenderBuffer,c=a?this._defaultMSDepthStencilRenderBuffer:this._defaultMSDepthRenderBuffer;n?r?(s=this._defaultColorTexture,i=d,o=t,l=e,f=d,u=e):(s=t,i=e,o=this._defaultMSColorRenderBuffer,l=c,f=e,u=c):(s=this._defaultColorTexture,i=d,o=this._defaultMSColorRenderBuffer,l=c,f=d,u=c),this._bufferMap.forEach((function(t){t.syncAttachments?t.syncAttachments(s,i,o,l):t.syncDepthAttachments&&t.syncDepthAttachments(f,u)}))},i.setExternalAttachment=function(t,e){var n=Ht(t);n===Ht(e)?(this._externalColorAttachment=t,this._externalDepthAttachment=e,this._externalMSAA=n>0,this._syncAttachments()):console.warn("EffectComposer.setExternalAttachment: color and depth attachment MultipleSampling not match.")},i.clearExternalAttachment=function(){this._externalColorAttachment=null,this._externalDepthAttachment=null,this._externalMSAA=null,this._syncAttachments()},i.addBuffer=function(t,e){this._bufferMap.set(t,e)},i.removeBuffer=function(t){this._bufferMap.delete(t)},i.getBuffer=function(t){return this._bufferMap.get(t)},i.addEffect=function(t,e,n){void 0===n&&(n=0),this.getEffect(t)?console.warn(""):(e.name=t,this._effectList.push({name:t,effect:e,order:n}),e.resize(this._size.x,this._size.y))},i.removeEffect=function(t){var e=this._effectList.findIndex((function(e){return e.name===t}));e>-1&&this._effectList.splice(e,1)},i.getEffect=function(t){var e=this._effectList.find((function(e){return e.name===t}));return e?e.effect:null},i.render=function(t,e,n,r){var a,s,i=this,o=e.getRenderStates(n);if(t.renderPass.getClearColor().toArray(this._tempClearColor),n.rect.toArray(this._tempViewport),n.rect.set(0,0,1,1),o.camera.rect.set(0,0,1,1),this._bufferMap.forEach((function(t){t.attachManager&&t.attachManager.reset()})),this.debugger)return this.debugger.bufferDependencies.forEach((function(r){var a=i._bufferMap.get(r);i.debugger.channel&&a.attachManager&&a.attachManager.allocate(i.debugger.channel,i.debugger.mask),a.render(t,i,e,n)})),this.debugger.render(t,this,r),void(s=t.renderPass).setClearColor.apply(s,this._tempClearColor);this._effectList.sort(Xt);var l=this._effectList.findIndex((function(t){return t.effect.active})),f=l>-1;if(this._tempBufferNames.clear(),f){this._tempBufferNames.add("SceneBuffer"),this._effectList.forEach((function(t){t.effect.active&&t.effect.bufferDependencies.forEach((function(e){var n=e.key,r=e.mask;i._tempBufferNames.add(n),i._bufferMap.get(n).attachManager&&i._bufferMap.get(n).attachManager.allocate(t.name,r)}))})),this._tempBufferNames.forEach((function(r){i._bufferMap.get(r).render(t,i,e,n)}));var u,d=this._renderTargetCache.allocate(),c=this._renderTargetCache.allocate();this._effectList.sort(wt);var h=this._effectList.length,_=this._effectList.findIndex((function(t){return t.effect.active}));l=h-1-l,this._effectList.forEach((function(e,n){if(e.effect.active){var a=n<l;e.effect.render(t,i,n===_?i._bufferMap.get("SceneBuffer").output():d,a?c:r,!a),u=d,d=c,c=u}})),this._renderTargetCache.release(d),this._renderTargetCache.release(c)}else{var m;t.renderPass.setRenderTarget(r),(m=t.renderPass).setClearColor.apply(m,this._tempClearColor),t.renderPass.clear(this.clearColor,this.clearDepth,this.clearStencil),o.camera.rect.fromArray(this._tempViewport);var p=e.getRenderQueue(n);this._bufferMap.get("SceneBuffer").$renderScene(t,p,o)}(a=t.renderPass).setClearColor.apply(a,this._tempClearColor),n.rect.fromArray(this._tempViewport),o.camera.rect.fromArray(this._tempViewport)},i.getStats=function(){this._renderTargetCache.updateStats(this._stats);var t=this.getBuffer("MarkBuffer").attachManager.attachCount(),e=this.getBuffer("NonDepthMarkBuffer").attachManager.attachCount(),n=this.getBuffer("ColorMarkBuffer").attachManager.attachCount();this._stats.markBuffers=t+e,this._stats.colorMarkBuffers=n;for(var r,a=o(this._bufferMap);!(r=a()).done;){var s=r.value,i=s[0];s[1].attachManager||(this._stats.currentBufferUsage[i]=this._tempBufferNames.has(i)?1:0)}return this._stats},i.resize=function(t,e){this._size.set(t,e),this._bufferMap.forEach((function(n){return n.resize(t,e)})),this._renderTargetCache.resize(t,e),this._effectList.forEach((function(n){return n.effect.resize(t,e)}))},i.dispose=function(){this._bufferMap.forEach((function(t){return t.dispose()})),this._renderTargetCache.dispose(),this._effectList.forEach((function(t){return t.effect.dispose()}))},n=t,(a=[{key:"stencilBuffer",get:function(){return this._stencilBuffer},set:function(t){this._stencilBuffer=t,this._syncAttachments()}},{key:"$useMSAA",get:function(){return(null!==this._externalMSAA?this._externalMSAA:this.sceneMSAA)&&this._samplerNumber>1}}])&&r(n.prototype,a),s&&r(n,s),Object.defineProperty(n,"prototype",{writable:!1}),t}();function wt(t,e){return t.order-e.order}function Xt(t,e){return e.order-t.order}function Ht(t){return t.isTexture?0:t.multipleSampling}var kt=function(t){function e(e,n,r){var a;return(a=t.call(this,e,n,r)||this).addEffect("SSAO",new M,0),a.addEffect("SSR",new W,1),a.addEffect("ColorCorrection",new S,2),a.addEffect("DOF",new N,3),a.addEffect("Bloom",new g,4),a.addEffect("InnerGlow",new tt,10),a.addEffect("Glow",new at,11),a.addEffect("SoftGlow",new ot,12),a.addEffect("Tailing",new ft,13),a.addEffect("RadialTailing",new dt,14),a.addEffect("Ghosting",new ht,15),a.addEffect("FXAA",new I,101),a.addEffect("ChromaticAberration",new E,102),a.addEffect("Vignetting",new Z,103),a.addEffect("BlurEdge",new V,104),a.addEffect("Film",new C,105),a._effectList.forEach((function(t){return t.effect.active=!1})),a}return a(e,t),e}(Ot),Qt=function(){function t(){this.bufferDependencies=[]}var e=t.prototype;return e.render=function(t,e,n){console.error("Debugger: .render() must be implemented in subclass.")},e.resize=function(t,e){},e.dispose=function(){},t}(),Wt=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=["SceneBuffer","ColorMarkBuffer"],n._mainPass=new e.ShaderPostPass(h),n.channel="",n.mask=P.ALL,n}return a(n,t),n.prototype.render=function(t,n,r){t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,1),t.renderPass.clear(!0,!0,!1);var a=n.getBuffer("ColorMarkBuffer"),s=a.attachManager.getAttachIndex(this.channel);this._mainPass.uniforms.tDiffuse=a.output(s)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._mainPass.render(t)},n}(Qt),Bt=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=["GBuffer"],n._mainPass=new e.ShaderPostPass(zt),n.debugType=Yt.Normal,n}return a(n,t),n.prototype.render=function(t,n,r){t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,1),t.renderPass.clear(!0,!0,!1);var a=n.getBuffer("GBuffer"),s=a.getCurrentRenderStates();this._mainPass.uniforms.normalGlossinessTexture=a.output()._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0],this._mainPass.uniforms.depthTexture=a.output()._attachments[e.ATTACHMENT.DEPTH_STENCIL_ATTACHMENT],this._mainPass.uniforms.debug=this.debugType||0,s.camera.projectionViewMatrix.toArray(this._mainPass.uniforms.projectionView),this._mainPass.render(t)},n}(Qt),Yt={Normal:0,Depth:1,Position:2,Glossiness:3};Bt.DebugTypes=Yt;var zt={name:"ec_debug_gbuffer",defines:{},uniforms:{normalGlossinessTexture:null,depthTexture:null,projectionView:new Float32Array(16),debug:0},vertexShader:f,fragmentShader:"\n\t\tuniform sampler2D normalGlossinessTexture;\n\t\tuniform sampler2D depthTexture;\n\t\tuniform int debug;\n\n\t\tuniform mat4 projectionView;\n\n\t\tvarying vec2 v_Uv;\n\n\t\tvoid main() {\n\t\t\tvec2 texCoord = v_Uv;\n\t\t\tvec4 texel = texture2D(normalGlossinessTexture, texCoord);\n\n\t\t\tif (dot(texel.rgb, vec3(1.0)) == 0.0) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat depth = texture2D(depthTexture, texCoord).r;\n\n\t\t\tvec2 xy = texCoord * 2.0 - 1.0;\n\t\t\tfloat z = depth * 2.0 - 1.0;\n\n\t\t\tvec4 projectedPos = vec4(xy, z, 1.0);\n\t\t\tvec4 p4 = inverse(projectionView) * projectedPos;\n\n\t\t\tvec3 position = p4.xyz / p4.w;\n\n\t\t\tif (debug == 0) {\n\t\t\t\tgl_FragColor = vec4(texel.rgb, 1.0);\n\t\t\t} else if (debug == 1) {\n\t\t\t\tgl_FragColor = vec4(vec3(depth), 1.0);\n\t\t\t} else if (debug == 2) {\n\t\t\t\tgl_FragColor = vec4(position, 1.0);\n\t\t\t} else {\n\t\t\t\tgl_FragColor = vec4(vec3(texel.a), 1.0);\n\t\t\t}\n\t\t}\n\t"},Gt=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=["SceneBuffer","MarkBuffer"],n._mainPass=new e.ShaderPostPass(_),n.channel="",n.mask=P.ALL,n}return a(n,t),n.prototype.render=function(t,n,r){t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,1),t.renderPass.clear(!0,!0,!1);var a=n.getBuffer("MarkBuffer"),s=a.attachManager.getAttachIndex(this.channel),i=a.attachManager.getChannelIndex(this.channel);this._mainPass.uniforms.tDiffuse=a.output(s)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];for(var o=0;o<4;o++)this._mainPass.uniforms.channelMask[o]=o===i?1:0;this._mainPass.render(t)},n}(Qt),Zt=function(t){function n(){var n;return(n=t.call(this)||this).bufferDependencies=["NonDepthMarkBuffer"],n._mainPass=new e.ShaderPostPass(_),n.channel="",n.mask=P.ALL,n}return a(n,t),n.prototype.render=function(t,n,r){t.renderPass.setRenderTarget(r),t.renderPass.setClearColor(0,0,0,1),t.renderPass.clear(!0,!0,!1);var a=n.getBuffer("NonDepthMarkBuffer"),s=a.attachManager.getAttachIndex(this.channel),i=a.attachManager.getChannelIndex(this.channel);this._mainPass.uniforms.tDiffuse=a.output(s)._attachments[e.ATTACHMENT.COLOR_ATTACHMENT0];for(var o=0;o<4;o++)this._mainPass.uniforms.channelMask[o]=o===i?1:0;this._mainPass.render(t)},n}(Qt),jt=function(t){function e(){var e;return(e=t.call(this)||this).bufferDependencies=["GBuffer"],e.defaultEffect=new M,e}a(e,t);var n=e.prototype;return n.render=function(t,e,n){(e.getEffect("SSAO")||this.defaultEffect).render(t,e,null,n)},n.resize=function(t,e){this.defaultEffect.resize(t,e)},n.dispose=function(){this.defaultEffect.dispose()},e}(Qt),Vt=function(t){function e(){var e;return(e=t.call(this)||this).bufferDependencies=["SceneBuffer","GBuffer"],e.defaultEffect=new W,e}a(e,t);var n=e.prototype;return n.render=function(t,e,n){(e.getEffect("SSR")||this.defaultEffect).render(t,e,null,n)},n.resize=function(t,e){this.defaultEffect.resize(t,e)},n.dispose=function(){this.defaultEffect.dispose()},e}(Qt);Ot.prototype.setGeometryReplaceFunction=function(t){console.warn("EffectComposer.setGeometryReplaceFunction has been removed, use SceneBuffer.setGeometryReplaceFunction instead."),this._bufferMap.get("SceneBuffer").setGeometryReplaceFunction(t)},Object.defineProperties(Ot.prototype,{customRenderLayers:{set:function(t){console.error("EffectComposer.customRenderLayers has been removed, use SceneBuffer.renderLayers instead.")},get:function(){console.error("EffectComposer.customRenderLayers has been removed, use SceneBuffer.renderLayers instead.")}}}),t.BloomEffect=g,t.BlurEdgeEffect=V,t.Buffer=n,t.ChromaticAberrationEffect=E,t.ColorCorrectionEffect=S,t.ColorMarkBufferDebugger=Wt,t.DOFEffect=N,t.Debugger=Qt,t.DefaultEffectComposer=kt,t.Effect=l,t.EffectComposer=Ot,t.FXAAEffect=I,t.FilmEffect=C,t.GBufferDebugger=Bt,t.GhostingEffect=ht,t.GlowEffect=at,t.InnerGlowEffect=tt,t.MarkBufferDebugger=Gt,t.NonDepthMarkBufferDebugger=Zt,t.OutlineEffect=K,t.RadialTailingEffect=dt,t.RenderLayer={Background:2,Main:0,Overlay:1},t.RenderListMask=P,t.SSAODebugger=jt,t.SSAOEffect=M,t.SSRDebugger=Vt,t.SSREffect=W,t.SoftGlowEffect=ot,t.TailingEffect=ft,t.VignettingEffect=Z,t.additiveShader=d,t.blurShader=u,t.channelShader=_,t.copyShader=h,t.defaultVertexShader=f,t.highlightShader=p,t.horizontalBlurShader=A,t.isDepthStencilAttachment=v,t.maskShader=m,t.multiplyShader=c,t.seperableBlurShader=x,t.verticalBlurShader=T,Object.defineProperty(t,"__esModule",{value:!0})}));
